/**
 * 🎬 YouTube 영상 필터링 서비스
 * 
 * MCP 서버의 모든 영상 필터링 기능을 완전 구현
 * - 재생 가능 여부 확인 (embeddable, privacy, region)
 * - Shorts 길이 필터링 (5-60초)
 * - 품질 기반 필터링 (조회수, 좋아요 등)
 * - 중복 제거 및 정렬
 */

import axios from 'axios';

class VideoFilter {
  constructor(apiKey) {
    this.apiKey = apiKey;
    this.youtubeApiUrl = 'https://www.googleapis.com/youtube/v3';
    
    // 필터링 통계
    this.stats = {
      totalProcessed: 0,
      playableVideos: 0,
      blockedVideos: 0,
      duplicatesRemoved: 0,
      filteringRatio: 0
    };
  }

  /**
   * 🎯 재생 가능한 영상만 필터링 (MCP 서버 핵심 기능)
   */
  async filterPlayableVideos(videoIds, options = {}) {
    if (!this.apiKey) {
      throw new Error('YouTube API 키가 설정되지 않았습니다.');
    }

    if (!videoIds || videoIds.length === 0) {
      return { playableVideos: [], filteringStats: this.getEmptyStats() };
    }

    const {
      regionCode = 'KR',
      maxDuration = 60,
      minDuration = 5,
      requireEmbeddable = true,
      requirePublic = true,
      checkRegionRestrictions = true,
      includeStatistics = true
    } = options;

    console.log(`🎯 영상 필터링 시작: ${videoIds.length}개 영상 검사`);

    try {
      // 배치 처리 (YouTube API는 최대 50개까지 한 번에 처리 가능)
      const batches = this.createBatches(videoIds, 50);
      let allPlayableVideos = [];
      let totalApiUnits = 0;

      for (let i = 0; i < batches.length; i++) {
        const batch = batches[i];
        console.log(`📦 배치 ${i + 1}/${batches.length} 처리 중... (${batch.length}개 영상)`);

        // videos.list API 호출
        const parts = ['snippet', 'contentDetails', 'status'];
        if (includeStatistics) parts.push('statistics');

        const response = await axios.get(`${this.youtubeApiUrl}/videos`, {
          params: {
            key: this.apiKey,
            part: parts.join(','),
            id: batch.join(','),
            hl: 'ko',
            regionCode: regionCode
          }
        });

        const videos = response.data.items || [];
        console.log(`📊 배치 ${i + 1} API 응답: ${videos.length}/${batch.length}개 영상 정보 수신`);

        // 각 영상에 대해 재생 가능 여부 검사
        const batchPlayableVideos = videos.filter(video => {
          return this.isVideoPlayable(video, {
            regionCode,
            maxDuration,
            minDuration,
            requireEmbeddable,
            requirePublic,
            checkRegionRestrictions
          });
        });

        allPlayableVideos.push(...batchPlayableVideos);

        // API 사용량 계산 (1 + parts.length * 2)
        const batchApiUnits = 1 + (parts.length * 2);
        totalApiUnits += batchApiUnits;

        console.log(`✅ 배치 ${i + 1} 필터링 완료: ${batchPlayableVideos.length}/${videos.length}개 재생 가능`);

        // API 호출 간격 (Rate Limiting 방지)
        if (i < batches.length - 1) {
          await this.delay(100);
        }
      }

      // 통계 업데이트
      this.stats.totalProcessed += videoIds.length;
      this.stats.playableVideos += allPlayableVideos.length;
      this.stats.blockedVideos += (videoIds.length - allPlayableVideos.length);
      this.stats.filteringRatio = this.stats.totalProcessed > 0 
        ? (this.stats.playableVideos / this.stats.totalProcessed * 100).toFixed(1)
        : 0;

      console.log(`🎊 필터링 완료!`);
      console.log(`  📊 총 검사: ${videoIds.length}개`);
      console.log(`  ✅ 재생 가능: ${allPlayableVideos.length}개`);
      console.log(`  ❌ 재생 불가: ${videoIds.length - allPlayableVideos.length}개`);
      console.log(`  📈 성공률: ${((allPlayableVideos.length / videoIds.length) * 100).toFixed(1)}%`);
      console.log(`  💰 API 사용량: ${totalApiUnits} units`);

      return {
        playableVideos: allPlayableVideos,
        filteringStats: {
          totalChecked: videoIds.length,
          playableCount: allPlayableVideos.length,
          blockedCount: videoIds.length - allPlayableVideos.length,
          successRate: ((allPlayableVideos.length / videoIds.length) * 100).toFixed(1) + '%',
          apiUnitsUsed: totalApiUnits,
          batchesProcessed: batches.length
        }
      };

    } catch (error) {
      console.error('❌ 영상 필터링 실패:', error);
      throw error;
    }
  }

  /**
   * 🔍 개별 영상 재생 가능 여부 검사 (MCP 서버 로직)
   */
  isVideoPlayable(video, options = {}) {
    const {
      regionCode = 'KR',
      maxDuration = 60,
      minDuration = 5,
      requireEmbeddable = true,
      requirePublic = true,
      checkRegionRestrictions = true
    } = options;

    try {
      // 1. 임베드 가능 여부 확인
      if (requireEmbeddable && !video.status?.embeddable) {
        console.log(`❌ ${video.id}: 임베드 불가능`);
        return false;
      }

      // 2. 공개 상태 확인
      if (requirePublic && video.status?.privacyStatus !== 'public') {
        console.log(`❌ ${video.id}: 비공개 영상 (${video.status?.privacyStatus})`);
        return false;
      }

      // 3. 지역 차단 확인
      if (checkRegionRestrictions) {
        const restrictions = video.contentDetails?.regionRestriction;
        if (restrictions) {
          // 차단된 지역 목록에 포함되어 있는지 확인
          if (restrictions.blocked?.includes(regionCode)) {
            console.log(`❌ ${video.id}: 지역 차단됨 (${regionCode})`);
            return false;
          }
          
          // 허용된 지역 목록이 있고, 해당 지역이 포함되지 않은 경우
          if (restrictions.allowed && !restrictions.allowed.includes(regionCode)) {
            console.log(`❌ ${video.id}: 지역 허용 목록에 없음 (${regionCode})`);
            return false;
          }
        }
      }

      // 4. 영상 길이 확인 (Shorts 기준)
      const duration = this.parseISO8601Duration(video.contentDetails?.duration);
      if (duration > maxDuration) {
        console.log(`❌ ${video.id}: 너무 긴 영상 (${duration}초 > ${maxDuration}초)`);
        return false;
      }
      
      if (duration < minDuration) {
        console.log(`❌ ${video.id}: 너무 짧은 영상 (${duration}초 < ${minDuration}초)`);
        return false;
      }

      // 5. 업로드 실패 또는 처리 중인 영상 확인
      if (video.status?.uploadStatus !== 'processed') {
        console.log(`❌ ${video.id}: 업로드 미완료 (${video.status?.uploadStatus})`);
        return false;
      }

      // 6. 연령 제한 확인 (선택적)
      if (video.contentDetails?.contentRating?.ytRating === 'ytAgeRestricted') {
        console.log(`⚠️ ${video.id}: 연령 제한 영상`);
        // 연령 제한 영상도 허용하지만 로그는 남김
      }

      console.log(`✅ ${video.id}: 재생 가능 (${duration}초)`);
      return true;

    } catch (error) {
      console.error(`❌ ${video.id}: 필터링 검사 오류:`, error);
      return false;
    }
  }

  /**
   * 🎯 품질 기반 필터링 (조회수, 좋아요 등)
   */
  filterByQuality(videos, options = {}) {
    const {
      minViewCount = 1000,
      minLikeCount = 10,
      maxDislikeRatio = 0.1,
      minEngagementRate = 0.01,
      sortBy = 'viewCount' // viewCount, likeCount, publishedAt, relevance
    } = options;

    console.log(`🎯 품질 기반 필터링 시작: ${videos.length}개 영상`);

    const qualityVideos = videos.filter(video => {
      const stats = video.statistics;
      if (!stats) return true; // 통계가 없으면 통과

      const viewCount = parseInt(stats.viewCount) || 0;
      const likeCount = parseInt(stats.likeCount) || 0;
      const dislikeCount = parseInt(stats.dislikeCount) || 0;
      const commentCount = parseInt(stats.commentCount) || 0;

      // 최소 조회수 확인
      if (viewCount < minViewCount) {
        console.log(`❌ ${video.id}: 조회수 부족 (${viewCount} < ${minViewCount})`);
        return false;
      }

      // 최소 좋아요 수 확인
      if (likeCount < minLikeCount) {
        console.log(`❌ ${video.id}: 좋아요 부족 (${likeCount} < ${minLikeCount})`);
        return false;
      }

      // 싫어요 비율 확인
      const totalRatings = likeCount + dislikeCount;
      if (totalRatings > 0) {
        const dislikeRatio = dislikeCount / totalRatings;
        if (dislikeRatio > maxDislikeRatio) {
          console.log(`❌ ${video.id}: 싫어요 비율 높음 (${(dislikeRatio * 100).toFixed(1)}%)`);
          return false;
        }
      }

      // 참여도 확인 (좋아요 + 댓글) / 조회수
      const engagementRate = viewCount > 0 ? (likeCount + commentCount) / viewCount : 0;
      if (engagementRate < minEngagementRate) {
        console.log(`❌ ${video.id}: 참여도 낮음 (${(engagementRate * 100).toFixed(2)}%)`);
        return false;
      }

      return true;
    });

    // 정렬
    const sortedVideos = this.sortVideos(qualityVideos, sortBy);

    console.log(`✅ 품질 필터링 완료: ${sortedVideos.length}/${videos.length}개 영상 통과`);

    return sortedVideos;
  }

  /**
   * 🔄 중복 영상 제거
   */
  removeDuplicates(videos, options = {}) {
    const { 
      dedupeBy = 'videoId', // videoId, title, channelId
      keepFirst = true 
    } = options;

    console.log(`🔄 중복 제거 시작: ${videos.length}개 영상 (기준: ${dedupeBy})`);

    const seen = new Set();
    const uniqueVideos = [];

    for (const video of videos) {
      let key;
      
      switch (dedupeBy) {
        case 'videoId':
          key = video.id;
          break;
        case 'title':
          key = video.snippet?.title?.toLowerCase().trim();
          break;
        case 'channelId':
          key = video.snippet?.channelId;
          break;
        default:
          key = video.id;
      }

      if (!seen.has(key)) {
        seen.add(key);
        uniqueVideos.push(video);
      } else {
        console.log(`🔄 중복 제거: ${video.id} (${dedupeBy}: ${key})`);
        this.stats.duplicatesRemoved++;
      }
    }

    console.log(`✅ 중복 제거 완료: ${uniqueVideos.length}개 고유 영상 (${videos.length - uniqueVideos.length}개 제거)`);

    return uniqueVideos;
  }

  /**
   * 📊 영상 정렬
   */
  sortVideos(videos, sortBy = 'relevance') {
    console.log(`📊 영상 정렬: ${sortBy} 기준`);

    const sortedVideos = [...videos].sort((a, b) => {
      switch (sortBy) {
        case 'viewCount':
          return (parseInt(b.statistics?.viewCount) || 0) - (parseInt(a.statistics?.viewCount) || 0);
        
        case 'likeCount':
          return (parseInt(b.statistics?.likeCount) || 0) - (parseInt(a.statistics?.likeCount) || 0);
        
        case 'publishedAt':
          return new Date(b.snippet?.publishedAt) - new Date(a.snippet?.publishedAt);
        
        case 'duration':
          const durationA = this.parseISO8601Duration(a.contentDetails?.duration);
          const durationB = this.parseISO8601Duration(b.contentDetails?.duration);
          return durationA - durationB;
        
        case 'engagement':
          const engagementA = this.calculateEngagementRate(a);
          const engagementB = this.calculateEngagementRate(b);
          return engagementB - engagementA;
        
        case 'relevance':
        default:
          // 기본 관련성 정렬 (YouTube API 기본 순서 유지)
          return 0;
      }
    });

    return sortedVideos;
  }

  /**
   * 📈 참여도 계산
   */
  calculateEngagementRate(video) {
    const stats = video.statistics;
    if (!stats) return 0;

    const viewCount = parseInt(stats.viewCount) || 0;
    const likeCount = parseInt(stats.likeCount) || 0;
    const commentCount = parseInt(stats.commentCount) || 0;

    return viewCount > 0 ? (likeCount + commentCount) / viewCount : 0;
  }

  /**
   * ⏱️ ISO 8601 Duration 파싱 (MCP 서버와 동일)
   */
  parseISO8601Duration(duration) {
    if (!duration || typeof duration !== 'string') {
      return 0;
    }

    try {
      const match = duration.match(/PT(\d+H)?(\d+M)?(\d+S)?/);
      if (!match) return 0;

      const hours = match[1] ? parseInt(match[1].replace('H', '')) || 0 : 0;
      const minutes = match[2] ? parseInt(match[2].replace('M', '')) || 0 : 0;
      const seconds = match[3] ? parseInt(match[3].replace('S', '')) || 0 : 0;

      return hours * 3600 + minutes * 60 + seconds;
    } catch (error) {
      console.error('Duration parsing error:', error);
      return 0;
    }
  }

  /**
   * 📦 배치 생성 (API 호출 최적화)
   */
  createBatches(items, batchSize) {
    const batches = [];
    for (let i = 0; i < items.length; i += batchSize) {
      batches.push(items.slice(i, i + batchSize));
    }
    return batches;
  }

  /**
   * 📊 필터링 통계 조회
   */
  getStats() {
    return {
      ...this.stats,
      successRate: this.stats.totalProcessed > 0 
        ? ((this.stats.playableVideos / this.stats.totalProcessed) * 100).toFixed(1) + '%'
        : '0%'
    };
  }

  /**
   * 📊 빈 통계 객체
   */
  getEmptyStats() {
    return {
      totalChecked: 0,
      playableCount: 0,
      blockedCount: 0,
      successRate: '0%',
      apiUnitsUsed: 0,
      batchesProcessed: 0
    };
  }

  /**
   * 🔄 지연 함수
   */
  async delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

export default VideoFilter;

/**
 * 🎯 편의 함수들 - 직접 사용 가능
 */

// 전역 인스턴스 생성 함수
function createVideoFilter() {
  const apiKey = process.env.YOUTUBE_API_KEY;
  return new VideoFilter(apiKey);
}

/**
 * 🎯 재생 가능한 영상 필터링 (편의 함수)
 */
export async function filterVideos(videoIds, options = {}) {
  const filter = createVideoFilter();
  const result = await filter.filterPlayableVideos(videoIds, options);
  return result.playableVideos;
}

/**
 * 📊 영상 정렬 (편의 함수)
 */
export function sortVideos(videos, sortBy = 'relevance') {
  const filter = createVideoFilter();
  return filter.sortVideos(videos, sortBy);
}

/**
 * 🔄 중복 제거 (편의 함수)
 */
export function removeDuplicates(videos, options = {}) {
  const filter = createVideoFilter();
  return filter.removeDuplicates(videos, options);
}

/**
 * 📊 필터링 통계 조회 (편의 함수)
 */
export function getFilterStats() {
  const filter = createVideoFilter();
  return filter.getStats();
} 