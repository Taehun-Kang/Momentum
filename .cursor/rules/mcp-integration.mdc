---
description: 
globs: 
alwaysApply: true
---
# ü§ñ MCP ÌÜµÌï© Í∞ÄÏù¥Îìú (Model Context Protocol)

## üéØ MCP Íµ¨ÌòÑ Ï†ÑÎûµ

### ÌïµÏã¨ MCP ÏÑúÎ≤ÑÎì§
- **Claude API**: ÏûêÏó∞Ïñ¥ Ïù¥Ìï¥ Î∞è ÎåÄÌôîÌòï Í≤ÄÏÉâ
- **Bright Data MCP**: Ïã§ÏãúÍ∞Ñ Ïõπ Ìä∏Î†åÎìú ÏàòÏßë
- **Supabase MCP**: Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Í¥ÄÎ¶¨ Î∞è ÏøºÎ¶¨
- **SerpAPI MCP**: Í≤ÄÏÉâ ÏóîÏßÑ Îç∞Ïù¥ÌÑ∞ (Î∞±ÏóÖ)

### MCP ÏïÑÌÇ§ÌÖçÏ≤ò
```
Frontend (Vanilla JS)
    ‚Üì WebSocket/REST
Backend (Express.js)
    ‚Üì MCP Protocol
MCP Servers (Claude, Bright Data, Supabase)
    ‚Üì External APIs
External Services (YouTube, Google, etc.)
```

## üõ†Ô∏è MCP ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Íµ¨ÌòÑ

### Í∏∞Î≥∏ MCP ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ ÌÅ¥ÎûòÏä§
```javascript
// backend/services/mcpClient.js
class MCPClient {
  constructor(serverName, config) {
    this.serverName = serverName;
    this.config = config;
    this.isConnected = false;
    this.tools = new Map();
    this.prompts = new Map();
  }

  // MCP ÏÑúÎ≤Ñ Ïó∞Í≤∞
  async connect() {
    try {
      this.transport = new SSEClientTransport(this.config.url);
      this.client = new Client(
        { name: "youtube-shorts-curator", version: "1.0.0" },
        { capabilities: {} }
      );

      await this.client.connect(this.transport);
      this.isConnected = true;

      // ÏÇ¨Ïö© Í∞ÄÎä•Ìïú ÎèÑÍµ¨ÏôÄ ÌîÑÎ°¨ÌîÑÌä∏ Î°úÎìú
      await this.loadCapabilities();

      console.log(`‚úÖ Connected to ${this.serverName} MCP`);
    } catch (error) {
      console.error(`‚ùå Failed to connect to ${this.serverName}:`, error);
      throw error;
    }
  }

  // ÎèÑÍµ¨ Î∞è ÌîÑÎ°¨ÌîÑÌä∏ Î°úÎìú
  async loadCapabilities() {
    try {
      const tools = await this.client.request(
        { method: "tools/list" },
        ListToolsRequestSchema
      );

      const prompts = await this.client.request(
        { method: "prompts/list" },
        ListPromptsRequestSchema
      );

      tools.tools.forEach(tool => this.tools.set(tool.name, tool));
      prompts.prompts.forEach(prompt => this.prompts.set(prompt.name, prompt));
    } catch (error) {
      console.error(`Failed to load capabilities for ${this.serverName}:`, error);
    }
  }

  // ÎèÑÍµ¨ Ïã§Ìñâ
  async callTool(name, arguments_obj) {
    if (!this.tools.has(name)) {
      throw new Error(`Tool ${name} not available on ${this.serverName}`);
    }

    try {
      const result = await this.client.request(
        {
          method: "tools/call",
          params: { name, arguments: arguments_obj }
        },
        CallToolRequestSchema
      );

      return result.content;
    } catch (error) {
      console.error(`Tool ${name} failed:`, error);
      throw error;
    }
  }

  // ÌîÑÎ°¨ÌîÑÌä∏ Ïã§Ìñâ
  async getPrompt(name, arguments_obj) {
    if (!this.prompts.has(name)) {
      throw new Error(`Prompt ${name} not available on ${this.serverName}`);
    }

    try {
      const result = await this.client.request(
        {
          method: "prompts/get",
          params: { name, arguments: arguments_obj }
        },
        GetPromptRequestSchema
      );

      return result.messages;
    } catch (error) {
      console.error(`Prompt ${name} failed:`, error);
      throw error;
    }
  }

  // Ïó∞Í≤∞ Ìï¥Ï†ú
  async disconnect() {
    if (this.isConnected && this.client) {
      await this.client.close();
      this.isConnected = false;
    }
  }
}

module.exports = MCPClient;
```

### Claude MCP ÏÑúÎπÑÏä§
```javascript
// backend/services/claudeMcpService.js
const MCPClient = require('./mcpClient');

class ClaudeMcpService extends MCPClient {
  constructor() {
    super('claude', {
      url: process.env.CLAUDE_MCP_URL,
      apiKey: process.env.ANTHROPIC_API_KEY
    });
  }

  // ÏûêÏó∞Ïñ¥ ÏøºÎ¶¨Î•º ÌÇ§ÏõåÎìúÎ°ú Î≥ÄÌôò
  async extractKeywords(userMessage) {
    try {
      const prompt = await this.getPrompt('extract_keywords', {
        user_message: userMessage,
        context: 'youtube_shorts_search',
        language: 'korean'
      });

      const response = await this.callTool('analyze_text', {
        text: userMessage,
        task: 'keyword_extraction',
        format: 'json'
      });

      return this.parseKeywordResponse(response);
    } catch (error) {
      console.error('Keyword extraction failed:', error);
      // Ìè¥Î∞±: Í∞ÑÎã®Ìïú ÌÇ§ÏõåÎìú Ï∂îÏ∂ú
      return this.fallbackKeywordExtraction(userMessage);
    }
  }

  // ÎåÄÌôîÌòï Í≤ÄÏÉâ Ï≤òÎ¶¨
  async processChatSearch(userMessage, conversationHistory = []) {
    try {
      const context = {
        message: userMessage,
        history: conversationHistory,
        domain: 'youtube_shorts',
        preferences: await this.getUserPreferences()
      };

      const response = await this.callTool('chat_search', context);

      return {
        keywords: response.extracted_keywords,
        intent: response.search_intent,
        filters: response.suggested_filters,
        explanation: response.explanation
      };
    } catch (error) {
      console.error('Chat search failed:', error);
      throw error;
    }
  }

  // Í≤ÄÏÉâ Í≤∞Í≥º Í∞úÏÑ† Ï†úÏïà
  async improveSuggestions(searchResults, userFeedback) {
    try {
      const response = await this.callTool('improve_search', {
        results: searchResults,
        feedback: userFeedback,
        context: 'youtube_shorts'
      });

      return response.improved_suggestions;
    } catch (error) {
      console.error('Improve suggestions failed:', error);
      return [];
    }
  }

  // ÏùëÎãµ ÌååÏã±
  parseKeywordResponse(response) {
    try {
      const parsed = JSON.parse(response[0]?.text || '{}');
      return {
        primary: parsed.primary_keywords || [],
        secondary: parsed.secondary_keywords || [],
        categories: parsed.categories || [],
        intent: parsed.search_intent || 'general'
      };
    } catch (error) {
      console.error('Failed to parse keyword response:', error);
      return { primary: [], secondary: [], categories: [], intent: 'general' };
    }
  }

  // Ìè¥Î∞± ÌÇ§ÏõåÎìú Ï∂îÏ∂ú
  fallbackKeywordExtraction(message) {
    const keywords = message
      .replace(/[^\w\sÍ∞Ä-Ìû£]/g, '')
      .split(/\s+/)
      .filter(word => word.length > 1)
      .slice(0, 5);

    return {
      primary: keywords,
      secondary: [],
      categories: ['ÏùºÎ∞ò'],
      intent: 'general'
    };
  }

  // ÏÇ¨Ïö©Ïûê ÏÑ†Ìò∏ÎèÑ Ï°∞Ìöå
  async getUserPreferences() {
    // Ïã§Ï†ú Íµ¨ÌòÑÏóêÏÑúÎäî Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ÏóêÏÑú Ï°∞Ìöå
    return {
      categories: ['Î∏åÏù¥Î°úÍ∑∏', 'Î®πÎ∞©', 'ÎåÑÏä§'],
      keywords: ['ÌûêÎßÅ', 'ÏõÉÍ∏¥', 'Ïã†ÎÇòÎäî']
    };
  }
}

module.exports = new ClaudeMcpService();
```

### Bright Data MCP ÏÑúÎπÑÏä§
```javascript
// backend/services/brightDataMcpService.js
const MCPClient = require('./mcpClient');

class BrightDataMcpService extends MCPClient {
  constructor() {
    super('bright-data', {
      url: process.env.BRIGHT_DATA_MCP_URL,
      apiKey: process.env.BRIGHT_DATA_API_KEY
    });
  }

  // Ïã§ÏãúÍ∞Ñ Ìä∏Î†åÎìú ÏàòÏßë
  async getTrendingKeywords() {
    try {
      const response = await this.callTool('scrape_trends', {
        sources: ['google_trends', 'youtube_trending', 'twitter_trends'],
        region: 'KR',
        language: 'ko',
        categories: ['entertainment', 'music', 'gaming', 'lifestyle']
      });

      return this.processTrendData(response);
    } catch (error) {
      console.error('Failed to get trending keywords:', error);
      return [];
    }
  }

  // ÌÇ§ÏõåÎìúÎ≥Ñ Ìä∏Î†åÎìú Î∂ÑÏÑù
  async analyzeKeywordTrend(keyword) {
    try {
      const response = await this.callTool('analyze_keyword', {
        keyword,
        timeframe: '24h',
        sources: ['google_trends', 'youtube'],
        metrics: ['search_volume', 'growth_rate', 'related_terms']
      });

      return {
        keyword,
        trendScore: response.trend_score,
        searchVolume: response.search_volume,
        growthRate: response.growth_rate,
        relatedTerms: response.related_terms,
        updatedAt: new Date()
      };
    } catch (error) {
      console.error(`Failed to analyze keyword ${keyword}:`, error);
      return null;
    }
  }

  // Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Ìä∏Î†åÎìú
  async getCategoryTrends(category) {
    try {
      const response = await this.callTool('category_trends', {
        category,
        region: 'KR',
        limit: 20
      });

      return response.trending_keywords;
    } catch (error) {
      console.error(`Failed to get ${category} trends:`, error);
      return [];
    }
  }

  // Ìä∏Î†åÎìú Îç∞Ïù¥ÌÑ∞ Ï≤òÎ¶¨
  processTrendData(rawData) {
    try {
      return rawData.map(item => ({
        keyword: item.keyword,
        category: item.category,
        trendScore: item.trend_score || 0,
        searchVolume: item.search_volume || 0,
        source: item.source,
        detectedAt: new Date(),
        expiresAt: new Date(Date.now() + 4 * 60 * 60 * 1000) // 4ÏãúÍ∞Ñ ÌõÑ ÎßåÎ£å
      }));
    } catch (error) {
      console.error('Failed to process trend data:', error);
      return [];
    }
  }
}

module.exports = new BrightDataMcpService();
```

### Supabase MCP ÏÑúÎπÑÏä§
```javascript
// backend/services/supabaseMcpService.js
const MCPClient = require('./mcpClient');

class SupabaseMcpService extends MCPClient {
  constructor() {
    super('supabase', {
      url: process.env.SUPABASE_MCP_URL,
      projectUrl: process.env.SUPABASE_URL,
      apiKey: process.env.SUPABASE_SERVICE_ROLE_KEY
    });
  }

  // Ïä§ÎßàÌä∏ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå
  async smartQuery(naturalLanguageQuery) {
    try {
      const response = await this.callTool('natural_query', {
        query: naturalLanguageQuery,
        schema: 'public',
        context: 'youtube_shorts_curation'
      });

      return response.results;
    } catch (error) {
      console.error('Smart query failed:', error);
      throw error;
    }
  }

  // ÏÇ¨Ïö©Ïûê Ìå®ÌÑ¥ Î∂ÑÏÑù
  async analyzeUserPatterns(userId) {
    try {
      const response = await this.callTool('analyze_user', {
        user_id: userId,
        analysis_type: 'viewing_patterns',
        timeframe: '30d'
      });

      return response.patterns;
    } catch (error) {
      console.error('User pattern analysis failed:', error);
      return null;
    }
  }

  // Í∞úÏù∏Ìôî Ï∂îÏ≤ú ÏÉùÏÑ±
  async generatePersonalizedRecommendations(userId, context) {
    try {
      const response = await this.callTool('personalize', {
        user_id: userId,
        context,
        limit: 20
      });

      return response.recommendations;
    } catch (error) {
      console.error('Personalization failed:', error);
      return [];
    }
  }
}

module.exports = new SupabaseMcpService();
```

## üîÑ MCP ÌÜµÌï© ÏõåÌÅ¨ÌîåÎ°úÏö∞

### ÎåÄÌôîÌòï Í≤ÄÏÉâ ÌîåÎ°úÏö∞
```javascript
// backend/services/chatSearchService.js
class ChatSearchService {
  constructor() {
    this.claudeMcp = require('./claudeMcpService');
    this.brightDataMcp = require('./brightDataMcpService');
    this.supabaseMcp = require('./supabaseMcpService');
  }

  async processChatMessage(userId, message, conversationHistory) {
    try {
      // 1. Claude MCPÎ°ú Î©îÏãúÏßÄ Î∂ÑÏÑù
      const analysis = await this.claudeMcp.processChatSearch(
        message, 
        conversationHistory
      );

      // 2. Ìä∏Î†åÎìú Îç∞Ïù¥ÌÑ∞ ÌôïÏù∏ (Bright Data MCP)
      const trendContext = await this.brightDataMcp.analyzeKeywordTrend(
        analysis.keywords.primary[0]
      );

      // 3. ÏÇ¨Ïö©Ïûê Í∞úÏù∏Ìôî (Supabase MCP)
      const userContext = await this.supabaseMcp.analyzeUserPatterns(userId);

      // 4. ÌÜµÌï© Í≤ÄÏÉâ Ïã§Ìñâ
      const searchResults = await this.executeIntegratedSearch({
        keywords: analysis.keywords,
        trendContext,
        userContext,
        filters: analysis.filters
      });

      return {
        response: analysis.explanation,
        results: searchResults,
        suggestions: await this.generateSuggestions(analysis, trendContext)
      };

    } catch (error) {
      console.error('Chat search failed:', error);
      throw error;
    }
  }

  // ÌÜµÌï© Í≤ÄÏÉâ Ïã§Ìñâ
  async executeIntegratedSearch(context) {
    // YouTube API Í≤ÄÏÉâ Î°úÏßÅÍ≥º Ïó∞Îèô
    const youtubeService = require('./youtubeService');
    
    return await youtubeService.searchWithContext(context);
  }

  // Ï†úÏïà ÏÉùÏÑ±
  async generateSuggestions(analysis, trendContext) {
    const suggestions = [];

    // Ìä∏Î†åÎìú Í∏∞Î∞ò Ï†úÏïà
    if (trendContext?.relatedTerms) {
      suggestions.push(...trendContext.relatedTerms.slice(0, 3));
    }

    // Ïπ¥ÌÖåÍ≥†Î¶¨ Í∏∞Î∞ò Ï†úÏïà
    if (analysis.categories.length > 0) {
      suggestions.push(`${analysis.categories[0]} Í¥ÄÎ†® ÏòÅÏÉÅ`);
    }

    return suggestions;
  }
}

module.exports = new ChatSearchService();
```

## üö® MCP Î™®Î≤î ÏÇ¨Î°Ä

### 1. ÏóêÎü¨ Ï≤òÎ¶¨ Î∞è Ìè¥Î∞±
```javascript
// MCP Ìò∏Ï∂ú Ïãú Ìï≠ÏÉÅ Ìè¥Î∞± Ï§ÄÎπÑ
async function safelyCallMcp(mcpService, method, params) {
  try {
    return await mcpService[method](mdc:params);
  } catch (error) {
    console.error(`MCP ${method} failed:`, error);
    
    // Ìè¥Î∞± Î°úÏßÅ
    return getFallbackResponse(method, params);
  }
}

function getFallbackResponse(method, params) {
  switch (method) {
    case 'extractKeywords':
      return basicKeywordExtraction(params.message);
    case 'getTrendingKeywords':
      return getCachedTrends();
    default:
      return null;
  }
}
```

### 2. Ïó∞Í≤∞ Í¥ÄÎ¶¨
```javascript
// MCP Ïó∞Í≤∞ ÌíÄ Í¥ÄÎ¶¨
class MCPConnectionManager {
  constructor() {
    this.connections = new Map();
    this.reconnectAttempts = new Map();
  }

  async getConnection(serviceName) {
    if (!this.connections.has(serviceName)) {
      await this.createConnection(serviceName);
    }

    const connection = this.connections.get(serviceName);
    
    if (!connection.isConnected) {
      await this.reconnect(serviceName);
    }

    return connection;
  }

  async reconnect(serviceName) {
    const attempts = this.reconnectAttempts.get(serviceName) || 0;
    
    if (attempts >= 3) {
      throw new Error(`Max reconnection attempts reached for ${serviceName}`);
    }

    this.reconnectAttempts.set(serviceName, attempts + 1);
    
    setTimeout(async () => {
      await this.createConnection(serviceName);
      this.reconnectAttempts.delete(serviceName);
    }, 1000 * Math.pow(2, attempts)); // ÏßÄÏàò Î∞±Ïò§ÌîÑ
  }
}
```

### 3. ÏÑ±Îä• ÏµúÏ†ÅÌôî
```javascript
// MCP ÏùëÎãµ Ï∫êÏã±
class MCPCache {
  constructor() {
    this.cache = new Map();
    this.ttl = new Map();
  }

  set(key, value, ttlMs = 300000) { // 5Î∂Ñ Í∏∞Î≥∏ TTL
    this.cache.set(key, value);
    this.ttl.set(key, Date.now() + ttlMs);
  }

  get(key) {
    if (!this.cache.has(key)) return null;
    
    if (Date.now() > this.ttl.get(key)) {
      this.cache.delete(key);
      this.ttl.delete(key);
      return null;
    }

    return this.cache.get(key);
  }
}

const mcpCache = new MCPCache();

// Ï∫êÏãúÎêú MCP Ìò∏Ï∂ú
async function cachedMcpCall(key, mcpCall) {
  const cached = mcpCache.get(key);
  if (cached) return cached;

  const result = await mcpCall();
  mcpCache.set(key, result);
  return result;
}
```

## üìä MCP Î™®ÎãàÌÑ∞ÎßÅ

### ÏÑ±Îä• ÏßÄÌëú
- **ÏùëÎãµ ÏãúÍ∞Ñ**: < 2Ï¥à
- **ÏÑ±Í≥µÎ•†**: > 95%
- **Ï∫êÏãú Ï†ÅÏ§ëÎ•†**: > 80%
- **Ìè¥Î∞± ÏÇ¨Ïö©Î•†**: < 10%

### Î°úÍπÖ Î∞è Î™®ÎãàÌÑ∞ÎßÅ
```javascript
// MCP Ìò∏Ï∂ú Î°úÍπÖ
function logMcpCall(serviceName, method, params, result, error, duration) {
  const logData = {
    timestamp: new Date().toISOString(),
    service: serviceName,
    method,
    params: JSON.stringify(params),
    success: !error,
    error: error?.message,
    duration,
    resultSize: JSON.stringify(result).length
  };

  console.log('MCP Call:', logData);
  
  // Î©îÌä∏Î¶≠ ÏàòÏßë
  analytics.track('mcp_call', logData);
}
```
