---
description: 
globs: 
alwaysApply: true
---
# ğŸ¤– MCP í†µí•© ê°€ì´ë“œ (Model Context Protocol)

## ğŸ¯ MCP êµ¬í˜„ ì „ëµ

### í•µì‹¬ MCP ì„œë²„ë“¤
- **Claude API**: ìì—°ì–´ ì´í•´ ë° ëŒ€í™”í˜• ê²€ìƒ‰
- **Bright Data MCP**: ì‹¤ì‹œê°„ ì›¹ íŠ¸ë Œë“œ ìˆ˜ì§‘
- **Supabase MCP**: ë°ì´í„°ë² ì´ìŠ¤ ê´€ë¦¬ ë° ì¿¼ë¦¬
- **SerpAPI MCP**: ê²€ìƒ‰ ì—”ì§„ ë°ì´í„° (ë°±ì—…)

### MCP ì•„í‚¤í…ì²˜
```
Frontend (Vanilla JS)
    â†“ WebSocket/REST
Backend (Express.js)
    â†“ MCP Protocol
MCP Servers (Claude, Bright Data, Supabase)
    â†“ External APIs
External Services (YouTube, Google, etc.)
```

## ğŸ› ï¸ MCP í´ë¼ì´ì–¸íŠ¸ êµ¬í˜„

### ê¸°ë³¸ MCP í´ë¼ì´ì–¸íŠ¸ í´ë˜ìŠ¤
```javascript
// backend/services/mcpClient.js
class MCPClient {
  constructor(serverName, config) {
    this.serverName = serverName;
    this.config = config;
    this.isConnected = false;
    this.tools = new Map();
    this.prompts = new Map();
  }

  // MCP ì„œë²„ ì—°ê²°
  async connect() {
    try {
      this.transport = new SSEClientTransport(this.config.url);
      this.client = new Client(
        { name: "youtube-shorts-curator", version: "1.0.0" },
        { capabilities: {} }
      );

      await this.client.connect(this.transport);
      this.isConnected = true;

      // ì‚¬ìš© ê°€ëŠ¥í•œ ë„êµ¬ì™€ í”„ë¡¬í”„íŠ¸ ë¡œë“œ
      await this.loadCapabilities();

      console.log(`âœ… Connected to ${this.serverName} MCP`);
    } catch (error) {
      console.error(`âŒ Failed to connect to ${this.serverName}:`, error);
      throw error;
    }
  }

  // ë„êµ¬ ë° í”„ë¡¬í”„íŠ¸ ë¡œë“œ
  async loadCapabilities() {
    try {
      const tools = await this.client.request(
        { method: "tools/list" },
        ListToolsRequestSchema
      );

      const prompts = await this.client.request(
        { method: "prompts/list" },
        ListPromptsRequestSchema
      );

      tools.tools.forEach(tool => this.tools.set(tool.name, tool));
      prompts.prompts.forEach(prompt => this.prompts.set(prompt.name, prompt));
    } catch (error) {
      console.error(`Failed to load capabilities for ${this.serverName}:`, error);
    }
  }

  // ë„êµ¬ ì‹¤í–‰
  async callTool(name, arguments_obj) {
    if (!this.tools.has(name)) {
      throw new Error(`Tool ${name} not available on ${this.serverName}`);
    }

    try {
      const result = await this.client.request(
        {
          method: "tools/call",
          params: { name, arguments: arguments_obj }
        },
        CallToolRequestSchema
      );

      return result.content;
    } catch (error) {
      console.error(`Tool ${name} failed:`, error);
      throw error;
    }
  }

  // í”„ë¡¬í”„íŠ¸ ì‹¤í–‰
  async getPrompt(name, arguments_obj) {
    if (!this.prompts.has(name)) {
      throw new Error(`Prompt ${name} not available on ${this.serverName}`);
    }

    try {
      const result = await this.client.request(
        {
          method: "prompts/get",
          params: { name, arguments: arguments_obj }
        },
        GetPromptRequestSchema
      );

      return result.messages;
    } catch (error) {
      console.error(`Prompt ${name} failed:`, error);
      throw error;
    }
  }

  // ì—°ê²° í•´ì œ
  async disconnect() {
    if (this.isConnected && this.client) {
      await this.client.close();
      this.isConnected = false;
    }
  }
}

module.exports = MCPClient;
```

### Claude MCP ì„œë¹„ìŠ¤
```javascript
// backend/services/claudeMcpService.js
const MCPClient = require('./mcpClient');

class ClaudeMcpService extends MCPClient {
  constructor() {
    super('claude', {
      url: process.env.CLAUDE_MCP_URL,
      apiKey: process.env.ANTHROPIC_API_KEY
    });
  }

  // ìì—°ì–´ ì¿¼ë¦¬ë¥¼ í‚¤ì›Œë“œë¡œ ë³€í™˜
  async extractKeywords(userMessage) {
    try {
      const prompt = await this.getPrompt('extract_keywords', {
        user_message: userMessage,
        context: 'youtube_shorts_search',
        language: 'korean'
      });

      const response = await this.callTool('analyze_text', {
        text: userMessage,
        task: 'keyword_extraction',
        format: 'json'
      });

      return this.parseKeywordResponse(response);
    } catch (error) {
      console.error('Keyword extraction failed:', error);
      // í´ë°±: ê°„ë‹¨í•œ í‚¤ì›Œë“œ ì¶”ì¶œ
      return this.fallbackKeywordExtraction(userMessage);
    }
  }

  // ëŒ€í™”í˜• ê²€ìƒ‰ ì²˜ë¦¬
  async processChatSearch(userMessage, conversationHistory = []) {
    try {
      const context = {
        message: userMessage,
        history: conversationHistory,
        domain: 'youtube_shorts',
        preferences: await this.getUserPreferences()
      };

      const response = await this.callTool('chat_search', context);

      return {
        keywords: response.extracted_keywords,
        intent: response.search_intent,
        filters: response.suggested_filters,
        explanation: response.explanation
      };
    } catch (error) {
      console.error('Chat search failed:', error);
      throw error;
    }
  }

  // ê²€ìƒ‰ ê²°ê³¼ ê°œì„  ì œì•ˆ
  async improveSuggestions(searchResults, userFeedback) {
    try {
      const response = await this.callTool('improve_search', {
        results: searchResults,
        feedback: userFeedback,
        context: 'youtube_shorts'
      });

      return response.improved_suggestions;
    } catch (error) {
      console.error('Improve suggestions failed:', error);
      return [];
    }
  }

  // ì‘ë‹µ íŒŒì‹±
  parseKeywordResponse(response) {
    try {
      const parsed = JSON.parse(response[0]?.text || '{}');
      return {
        primary: parsed.primary_keywords || [],
        secondary: parsed.secondary_keywords || [],
        categories: parsed.categories || [],
        intent: parsed.search_intent || 'general'
      };
    } catch (error) {
      console.error('Failed to parse keyword response:', error);
      return { primary: [], secondary: [], categories: [], intent: 'general' };
    }
  }

  // í´ë°± í‚¤ì›Œë“œ ì¶”ì¶œ
  fallbackKeywordExtraction(message) {
    const keywords = message
      .replace(/[^\w\sê°€-í£]/g, '')
      .split(/\s+/)
      .filter(word => word.length > 1)
      .slice(0, 5);

    return {
      primary: keywords,
      secondary: [],
      categories: ['ì¼ë°˜'],
      intent: 'general'
    };
  }

  // ì‚¬ìš©ì ì„ í˜¸ë„ ì¡°íšŒ
  async getUserPreferences() {
    // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì¡°íšŒ
    return {
      categories: ['ë¸Œì´ë¡œê·¸', 'ë¨¹ë°©', 'ëŒ„ìŠ¤'],
      keywords: ['íë§', 'ì›ƒê¸´', 'ì‹ ë‚˜ëŠ”']
    };
  }
}

module.exports = new ClaudeMcpService();
```

### Bright Data MCP ì„œë¹„ìŠ¤
```javascript
// backend/services/brightDataMcpService.js
const MCPClient = require('./mcpClient');

class BrightDataMcpService extends MCPClient {
  constructor() {
    super('bright-data', {
      url: process.env.BRIGHT_DATA_MCP_URL,
      apiKey: process.env.BRIGHT_DATA_API_KEY
    });
  }

  // ì‹¤ì‹œê°„ íŠ¸ë Œë“œ ìˆ˜ì§‘
  async getTrendingKeywords() {
    try {
      const response = await this.callTool('scrape_trends', {
        sources: ['google_trends', 'youtube_trending', 'twitter_trends'],
        region: 'KR',
        language: 'ko',
        categories: ['entertainment', 'music', 'gaming', 'lifestyle']
      });

      return this.processTrendData(response);
    } catch (error) {
      console.error('Failed to get trending keywords:', error);
      return [];
    }
  }

  // í‚¤ì›Œë“œë³„ íŠ¸ë Œë“œ ë¶„ì„
  async analyzeKeywordTrend(keyword) {
    try {
      const response = await this.callTool('analyze_keyword', {
        keyword,
        timeframe: '24h',
        sources: ['google_trends', 'youtube'],
        metrics: ['search_volume', 'growth_rate', 'related_terms']
      });

      return {
        keyword,
        trendScore: response.trend_score,
        searchVolume: response.search_volume,
        growthRate: response.growth_rate,
        relatedTerms: response.related_terms,
        updatedAt: new Date()
      };
    } catch (error) {
      console.error(`Failed to analyze keyword ${keyword}:`, error);
      return null;
    }
  }

  // ì¹´í…Œê³ ë¦¬ë³„ íŠ¸ë Œë“œ
  async getCategoryTrends(category) {
    try {
      const response = await this.callTool('category_trends', {
        category,
        region: 'KR',
        limit: 20
      });

      return response.trending_keywords;
    } catch (error) {
      console.error(`Failed to get ${category} trends:`, error);
      return [];
    }
  }

  // íŠ¸ë Œë“œ ë°ì´í„° ì²˜ë¦¬
  processTrendData(rawData) {
    try {
      return rawData.map(item => ({
        keyword: item.keyword,
        category: item.category,
        trendScore: item.trend_score || 0,
        searchVolume: item.search_volume || 0,
        source: item.source,
        detectedAt: new Date(),
        expiresAt: new Date(Date.now() + 4 * 60 * 60 * 1000) // 4ì‹œê°„ í›„ ë§Œë£Œ
      }));
    } catch (error) {
      console.error('Failed to process trend data:', error);
      return [];
    }
  }
}

module.exports = new BrightDataMcpService();
```

### Supabase MCP ì„œë¹„ìŠ¤
```javascript
// backend/services/supabaseMcpService.js
const MCPClient = require('./mcpClient');

class SupabaseMcpService extends MCPClient {
  constructor() {
    super('supabase', {
      url: process.env.SUPABASE_MCP_URL,
      projectUrl: process.env.SUPABASE_URL,
      apiKey: process.env.SUPABASE_SERVICE_ROLE_KEY
    });
  }

  // ìŠ¤ë§ˆíŠ¸ ë°ì´í„° ì¡°íšŒ
  async smartQuery(naturalLanguageQuery) {
    try {
      const response = await this.callTool('natural_query', {
        query: naturalLanguageQuery,
        schema: 'public',
        context: 'youtube_shorts_curation'
      });

      return response.results;
    } catch (error) {
      console.error('Smart query failed:', error);
      throw error;
    }
  }

  // ì‚¬ìš©ì íŒ¨í„´ ë¶„ì„
  async analyzeUserPatterns(userId) {
    try {
      const response = await this.callTool('analyze_user', {
        user_id: userId,
        analysis_type: 'viewing_patterns',
        timeframe: '30d'
      });

      return response.patterns;
    } catch (error) {
      console.error('User pattern analysis failed:', error);
      return null;
    }
  }

  // ê°œì¸í™” ì¶”ì²œ ìƒì„±
  async generatePersonalizedRecommendations(userId, context) {
    try {
      const response = await this.callTool('personalize', {
        user_id: userId,
        context,
        limit: 20
      });

      return response.recommendations;
    } catch (error) {
      console.error('Personalization failed:', error);
      return [];
    }
  }
}

module.exports = new SupabaseMcpService();
```

## ğŸ”„ MCP í†µí•© ì›Œí¬í”Œë¡œìš°

### ëŒ€í™”í˜• ê²€ìƒ‰ í”Œë¡œìš°
```javascript
// backend/services/chatSearchService.js
class ChatSearchService {
  constructor() {
    this.claudeMcp = require('./claudeMcpService');
    this.brightDataMcp = require('./brightDataMcpService');
    this.supabaseMcp = require('./supabaseMcpService');
  }

  async processChatMessage(userId, message, conversationHistory) {
    try {
      // 1. Claude MCPë¡œ ë©”ì‹œì§€ ë¶„ì„
      const analysis = await this.claudeMcp.processChatSearch(
        message, 
        conversationHistory
      );

      // 2. íŠ¸ë Œë“œ ë°ì´í„° í™•ì¸ (Bright Data MCP)
      const trendContext = await this.brightDataMcp.analyzeKeywordTrend(
        analysis.keywords.primary[0]
      );

      // 3. ì‚¬ìš©ì ê°œì¸í™” (Supabase MCP)
      const userContext = await this.supabaseMcp.analyzeUserPatterns(userId);

      // 4. í†µí•© ê²€ìƒ‰ ì‹¤í–‰
      const searchResults = await this.executeIntegratedSearch({
        keywords: analysis.keywords,
        trendContext,
        userContext,
        filters: analysis.filters
      });

      return {
        response: analysis.explanation,
        results: searchResults,
        suggestions: await this.generateSuggestions(analysis, trendContext)
      };

    } catch (error) {
      console.error('Chat search failed:', error);
      throw error;
    }
  }

  // í†µí•© ê²€ìƒ‰ ì‹¤í–‰
  async executeIntegratedSearch(context) {
    // YouTube API ê²€ìƒ‰ ë¡œì§ê³¼ ì—°ë™
    const youtubeService = require('./youtubeService');
    
    return await youtubeService.searchWithContext(context);
  }

  // ì œì•ˆ ìƒì„±
  async generateSuggestions(analysis, trendContext) {
    const suggestions = [];

    // íŠ¸ë Œë“œ ê¸°ë°˜ ì œì•ˆ
    if (trendContext?.relatedTerms) {
      suggestions.push(...trendContext.relatedTerms.slice(0, 3));
    }

    // ì¹´í…Œê³ ë¦¬ ê¸°ë°˜ ì œì•ˆ
    if (analysis.categories.length > 0) {
      suggestions.push(`${analysis.categories[0]} ê´€ë ¨ ì˜ìƒ`);
    }

    return suggestions;
  }
}

module.exports = new ChatSearchService();
```

## ğŸš¨ MCP ëª¨ë²” ì‚¬ë¡€

### 1. ì—ëŸ¬ ì²˜ë¦¬ ë° í´ë°±
```javascript
// MCP í˜¸ì¶œ ì‹œ í•­ìƒ í´ë°± ì¤€ë¹„
async function safelyCallMcp(mcpService, method, params) {
  try {
    return await mcpService[method](mdc:params);
  } catch (error) {
    console.error(`MCP ${method} failed:`, error);
    
    // í´ë°± ë¡œì§
    return getFallbackResponse(method, params);
  }
}

function getFallbackResponse(method, params) {
  switch (method) {
    case 'extractKeywords':
      return basicKeywordExtraction(params.message);
    case 'getTrendingKeywords':
      return getCachedTrends();
    default:
      return null;
  }
}
```

### 2. ì—°ê²° ê´€ë¦¬
```javascript
// MCP ì—°ê²° í’€ ê´€ë¦¬
class MCPConnectionManager {
  constructor() {
    this.connections = new Map();
    this.reconnectAttempts = new Map();
  }

  async getConnection(serviceName) {
    if (!this.connections.has(serviceName)) {
      await this.createConnection(serviceName);
    }

    const connection = this.connections.get(serviceName);
    
    if (!connection.isConnected) {
      await this.reconnect(serviceName);
    }

    return connection;
  }

  async reconnect(serviceName) {
    const attempts = this.reconnectAttempts.get(serviceName) || 0;
    
    if (attempts >= 3) {
      throw new Error(`Max reconnection attempts reached for ${serviceName}`);
    }

    this.reconnectAttempts.set(serviceName, attempts + 1);
    
    setTimeout(async () => {
      await this.createConnection(serviceName);
      this.reconnectAttempts.delete(serviceName);
    }, 1000 * Math.pow(2, attempts)); // ì§€ìˆ˜ ë°±ì˜¤í”„
  }
}
```

### 3. ì„±ëŠ¥ ìµœì í™”
```javascript
// MCP ì‘ë‹µ ìºì‹±
class MCPCache {
  constructor() {
    this.cache = new Map();
    this.ttl = new Map();
  }

  set(key, value, ttlMs = 300000) { // 5ë¶„ ê¸°ë³¸ TTL
    this.cache.set(key, value);
    this.ttl.set(key, Date.now() + ttlMs);
  }

  get(key) {
    if (!this.cache.has(key)) return null;
    
    if (Date.now() > this.ttl.get(key)) {
      this.cache.delete(key);
      this.ttl.delete(key);
      return null;
    }

    return this.cache.get(key);
  }
}

const mcpCache = new MCPCache();

// ìºì‹œëœ MCP í˜¸ì¶œ
async function cachedMcpCall(key, mcpCall) {
  const cached = mcpCache.get(key);
  if (cached) return cached;

  const result = await mcpCall();
  mcpCache.set(key, result);
  return result;
}
```

## ğŸ“Š MCP ëª¨ë‹ˆí„°ë§

### ì„±ëŠ¥ ì§€í‘œ
- **ì‘ë‹µ ì‹œê°„**: < 2ì´ˆ
- **ì„±ê³µë¥ **: > 95%
- **ìºì‹œ ì ì¤‘ë¥ **: > 80%
- **í´ë°± ì‚¬ìš©ë¥ **: < 10%

### ë¡œê¹… ë° ëª¨ë‹ˆí„°ë§
```javascript
// MCP í˜¸ì¶œ ë¡œê¹…
function logMcpCall(serviceName, method, params, result, error, duration) {
  const logData = {
    timestamp: new Date().toISOString(),
    service: serviceName,
    method,
    params: JSON.stringify(params),
    success: !error,
    error: error?.message,
    duration,
    resultSize: JSON.stringify(result).length
  };

  console.log('MCP Call:', logData);
  
  // ë©”íŠ¸ë¦­ ìˆ˜ì§‘
  analytics.track('mcp_call', logData);
}
```
