#!/usr/bin/env node

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ErrorCode,
  ListToolsRequestSchema,
  McpError,
} from "@modelcontextprotocol/sdk/types.js";
import { createClient } from '@supabase/supabase-js';
import dotenv from 'dotenv';

dotenv.config();

/**
 * User Analytics MCP Server
 * ÏÇ¨Ïö©Ïûê Î∂ÑÏÑù, Í≤ÄÏÉâ Ìå®ÌÑ¥, Ïù∏Í∏∞ ÌÇ§ÏõåÎìú Ï∂îÏ∂úÏùÑ ÏúÑÌïú MCP ÏÑúÎ≤Ñ
 * Wave Team
 */
class UserAnalyticsMCP {
  constructor() {
    this.server = new Server(
      {
        name: "user-analytics",
        version: "1.0.0",
      },
      {
        capabilities: {
          tools: {},
        },
      }
    );

    // Supabase ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ Ï¥àÍ∏∞Ìôî
    this.supabase = createClient(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_SERVICE_ROLE_KEY
    );
    
    // Ï∫êÏãú ÏÑ§Ï†ï
    this.cache = new Map();
    this.cacheTimeout = 10 * 60 * 1000; // 10Î∂Ñ Ï∫êÏãú

    console.log('üìä User Analytics MCP Server Ï¥àÍ∏∞Ìôî ÏôÑÎ£å');
    
    this.setupToolHandlers();
  }

  setupToolHandlers() {
    // Tools Î¶¨Ïä§Ìä∏ Ï†ïÏùò
    this.server.setRequestHandler(ListToolsRequestSchema, async () => {
      return {
        tools: [
          {
            name: "get_popular_keywords",
            description: "Ïù∏Í∏∞ Í≤ÄÏÉâÏñ¥Î•º Ï∂îÏ∂úÌïòÍ≥† Ìä∏Î†åÎìú Ï†êÏàòÎ•º Í≥ÑÏÇ∞Ìï©ÎãàÎã§",
            inputSchema: {
              type: "object",
              properties: {
                timeRange: {
                  type: "string",
                  enum: ["1h", "6h", "24h", "7d", "30d"],
                  description: "Î∂ÑÏÑù ÏãúÍ∞Ñ Î≤îÏúÑ",
                  default: "24h"
                },
                limit: {
                  type: "number",
                  description: "Î∞òÌôòÌï† ÌÇ§ÏõåÎìú Ïàò",
                  default: 20
                },
                userTier: {
                  type: "string",
                  enum: ["all", "free", "premium"],
                  description: "ÏÇ¨Ïö©Ïûê Ìã∞Ïñ¥ ÌïÑÌÑ∞",
                  default: "all"
                },
                excludeCommon: {
                  type: "boolean",
                  description: "ÏùºÎ∞òÏ†ÅÏù∏ ÌÇ§ÏõåÎìú Ï†úÏô∏ Ïó¨Î∂Ä",
                  default: true
                },
                category: {
                  type: "string",
                  description: "ÌäπÏ†ï Ïπ¥ÌÖåÍ≥†Î¶¨Î°ú ÌïÑÌÑ∞ÎßÅ (ÏÑ†ÌÉùÏÇ¨Ìï≠)"
                }
              }
            }
          },
          {
            name: "analyze_user_patterns",
            description: "ÌäπÏ†ï ÏÇ¨Ïö©ÏûêÏùò Í≤ÄÏÉâ Ìå®ÌÑ¥ÏùÑ Î∂ÑÏÑùÌï©ÎãàÎã§",
            inputSchema: {
              type: "object",
              properties: {
                userId: {
                  type: "string",
                  description: "Î∂ÑÏÑùÌï† ÏÇ¨Ïö©Ïûê ID"
                },
                timeRange: {
                  type: "string",
                  enum: ["7d", "30d", "90d"],
                  description: "Î∂ÑÏÑù Í∏∞Í∞Ñ",
                  default: "30d"
                },
                includeRecommendations: {
                  type: "boolean",
                  description: "Í∞úÏù∏Ìôî Ï∂îÏ≤ú Ìè¨Ìï® Ïó¨Î∂Ä",
                  default: true
                }
              },
              required: ["userId"]
            }
          },
          {
            name: "get_realtime_trends",
            description: "Ïã§ÏãúÍ∞Ñ Í≤ÄÏÉâ Ìä∏Î†åÎìúÎ•º Î∂ÑÏÑùÌï©ÎãàÎã§ (ÏµúÍ∑º 1-6ÏãúÍ∞Ñ)",
            inputSchema: {
              type: "object",
              properties: {
                timeWindow: {
                  type: "number",
                  description: "Î∂ÑÏÑù ÏãúÍ∞Ñ ÏúàÎèÑÏö∞ (ÏãúÍ∞Ñ)",
                  default: 1
                },
                detectSurging: {
                  type: "boolean",
                  description: "Í∏âÏÉÅÏäπ ÌÇ§ÏõåÎìú ÌÉêÏßÄ Ïó¨Î∂Ä",
                  default: true
                },
                groupByTimeSlots: {
                  type: "boolean",
                  description: "ÏãúÍ∞ÑÎåÄÎ≥Ñ Í∑∏Î£πÌôî Ïó¨Î∂Ä",
                  default: true
                }
              }
            }
          },
          {
            name: "log_search_activity",
            description: "Í≤ÄÏÉâ ÌôúÎèôÏùÑ Í∏∞Î°ùÌï©ÎãàÎã§",
            inputSchema: {
              type: "object",
              properties: {
                userId: {
                  type: "string",
                  description: "ÏÇ¨Ïö©Ïûê ID (null Í∞ÄÎä•)"
                },
                searchQuery: {
                  type: "string",
                  description: "Í≤ÄÏÉâ ÏøºÎ¶¨"
                },
                metadata: {
                  type: "object",
                  properties: {
                    searchType: {
                      type: "string",
                      description: "Í≤ÄÏÉâ Ïú†Ìòï (basic, smart, ai Îì±)"
                    },
                    resultsCount: {
                      type: "number",
                      description: "Í≤∞Í≥º Ïàò"
                    },
                    responseTime: {
                      type: "number",
                      description: "ÏùëÎãµ ÏãúÍ∞Ñ (ms)"
                    },
                    userTier: {
                      type: "string",
                      description: "ÏÇ¨Ïö©Ïûê Ìã∞Ïñ¥"
                    },
                    ipAddress: {
                      type: "string",
                      description: "IP Ï£ºÏÜå"
                    },
                    userAgent: {
                      type: "string",
                      description: "User Agent"
                    }
                  }
                }
              },
              required: ["searchQuery"]
            }
          },
          {
            name: "get_category_trends",
            description: "Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Í≤ÄÏÉâ Ìä∏Î†åÎìúÎ•º Î∂ÑÏÑùÌï©ÎãàÎã§",
            inputSchema: {
              type: "object",
              properties: {
                categories: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  description: "Î∂ÑÏÑùÌï† Ïπ¥ÌÖåÍ≥†Î¶¨ Î™©Î°ù (Îπà Î∞∞Ïó¥Ïãú Ï†ÑÏ≤¥)"
                },
                timeRange: {
                  type: "string",
                  enum: ["6h", "24h", "7d", "30d"],
                  description: "Î∂ÑÏÑù ÏãúÍ∞Ñ Î≤îÏúÑ",
                  default: "24h"
                },
                includeGrowthRate: {
                  type: "boolean",
                  description: "ÏÑ±Ïû•Î•† Í≥ÑÏÇ∞ Ìè¨Ìï® Ïó¨Î∂Ä",
                  default: true
                }
              }
            }
          },
          {
            name: "predict_trending_keywords",
            description: "Ìñ•ÌõÑ Ìä∏Î†åÎî©Ìï† Í∞ÄÎä•ÏÑ±Ïù¥ ÎÜíÏùÄ ÌÇ§ÏõåÎìúÎ•º ÏòàÏ∏°Ìï©ÎãàÎã§",
            inputSchema: {
              type: "object",
              properties: {
                predictionWindow: {
                  type: "string",
                  enum: ["1h", "6h", "24h"],
                  description: "ÏòàÏ∏° ÏãúÍ∞Ñ ÏúàÎèÑÏö∞",
                  default: "6h"
                },
                limit: {
                  type: "number",
                  description: "ÏòàÏ∏° ÌÇ§ÏõåÎìú Ïàò",
                  default: 10
                },
                confidenceThreshold: {
                  type: "number",
                  description: "Ïã†Î¢∞ÎèÑ ÏûÑÍ≥ÑÍ∞í (0-1)",
                  default: 0.7
                },
                includeReasons: {
                  type: "boolean",
                  description: "ÏòàÏ∏° Í∑ºÍ±∞ Ìè¨Ìï® Ïó¨Î∂Ä",
                  default: true
                }
              }
            }
          }
        ]
      };
    });

    // Tool Ïã§Ìñâ Ìï∏Îì§Îü¨
    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      const { name, arguments: args } = request.params;

      try {
        switch (name) {
          case "get_popular_keywords":
            return await this.getPopularKeywords(args);
          
          case "analyze_user_patterns":
            return await this.analyzeUserPatterns(args);
          
          case "get_realtime_trends":
            return await this.getRealtimeTrends(args);
          
          case "log_search_activity":
            return await this.logSearchActivity(args);
          
          case "get_category_trends":
            return await this.getCategoryTrends(args);
          
          case "predict_trending_keywords":
            return await this.predictTrendingKeywords(args);
          
          default:
            throw new McpError(
              ErrorCode.MethodNotFound,
              `Unknown tool: ${name}`
            );
        }
      } catch (error) {
        console.error(`Tool ${name} Ïã§Ìñâ Ïò§Î•ò:`, error);
        throw new McpError(
          ErrorCode.InternalError,
          `Tool execution failed: ${error.message}`
        );
      }
    });
  }

  /**
   * Ïù∏Í∏∞ Í≤ÄÏÉâÏñ¥ Ï∂îÏ∂ú ÎèÑÍµ¨
   */
  async getPopularKeywords(args) {
    const {
      timeRange = '24h',
      limit = 20,
      userTier = 'all',
      excludeCommon = true,
      category
    } = args;

    const cacheKey = `popular_${timeRange}_${userTier}_${limit}_${category || 'all'}`;
    
    // Ï∫êÏãú ÌôïÏù∏
    if (this.cache.has(cacheKey)) {
      const cached = this.cache.get(cacheKey);
      if (Date.now() - cached.timestamp < this.cacheTimeout) {
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify({
                ...cached.data,
                fromCache: true
              }, null, 2)
            }
          ]
        };
      }
    }

    try {
      // ÏãúÍ∞Ñ ÌïÑÌÑ∞ ÏÑ§Ï†ï
      const timeFilter = this.getTimeFilter(timeRange);
      
      // Í∏∞Î≥∏ ÏøºÎ¶¨ Íµ¨ÏÑ±
      let query = this.supabase
        .from('search_logs')
        .select('search_query, user_tier, created_at')
        .gte('created_at', timeFilter)
        .not('search_query', 'is', null)
        .not('search_query', 'eq', '');

      // ÏÇ¨Ïö©Ïûê Ìã∞Ïñ¥ ÌïÑÌÑ∞ÎßÅ
      if (userTier !== 'all') {
        query = query.eq('user_tier', userTier);
      }

      const { data: searchLogs, error } = await query;

      if (error) {
        throw new Error(`Database query failed: ${error.message}`);
      }

      console.log(`üìä ${searchLogs.length}Í∞ú Í≤ÄÏÉâ Î°úÍ∑∏ Î∂ÑÏÑù Ï§ë...`);

      // ÌÇ§ÏõåÎìú ÎπàÎèÑ Î∞è Ìä∏Î†åÎìú Ï†êÏàò Í≥ÑÏÇ∞
      const keywordFrequency = this.calculateKeywordFrequency(searchLogs);
      const trendScores = this.calculateTrendScores(searchLogs, timeRange);
      
      // ÏµúÏ¢Ö Ï†êÏàò Í≥ÑÏÇ∞ Î∞è Ï†ïÎ†¨
      const rankedKeywords = this.rankKeywords(keywordFrequency, trendScores);
      
      // ÏùºÎ∞òÏ†ÅÏù∏ ÌÇ§ÏõåÎìú ÌïÑÌÑ∞ÎßÅ
      let filteredKeywords = excludeCommon ? 
        this.filterCommonKeywords(rankedKeywords) : rankedKeywords;
      
      // Ïπ¥ÌÖåÍ≥†Î¶¨ ÌïÑÌÑ∞ÎßÅ
      if (category) {
        filteredKeywords = filteredKeywords.filter(item => 
          this.categorizeKeyword(item.keyword) === category
        );
      }
      
      // ÏÉÅÏúÑ ÌÇ§ÏõåÎìú ÏÑ†ÌÉù Î∞è Î©îÌÉÄÎç∞Ïù¥ÌÑ∞ Ï∂îÍ∞Ä
      const topKeywords = filteredKeywords.slice(0, limit);
      const enrichedKeywords = this.enrichKeywordData(topKeywords, timeRange);

      const result = {
        timeRange,
        userTier,
        category: category || 'all',
        keywords: enrichedKeywords,
        totalAnalyzed: searchLogs.length,
        totalUniqueKeywords: Object.keys(keywordFrequency).length,
        filteringApplied: {
          excludeCommon,
          categoryFilter: !!category
        },
        timestamp: new Date().toISOString()
      };

      // Ï∫êÏãú Ï†ÄÏû•
      this.cache.set(cacheKey, {
        data: result,
        timestamp: Date.now()
      });

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result, null, 2)
          }
        ]
      };

    } catch (error) {
      console.error('Ïù∏Í∏∞ Í≤ÄÏÉâÏñ¥ Ï∂îÏ∂ú Ïã§Ìå®:', error);
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify({
              error: "Ïù∏Í∏∞ Í≤ÄÏÉâÏñ¥ Ï∂îÏ∂ú Ïã§Ìå®",
              message: error.message,
              fallback: this.getFallbackPopularKeywords()
            }, null, 2)
          }
        ]
      };
    }
  }

  /**
   * ÏÇ¨Ïö©Ïûê Ìå®ÌÑ¥ Î∂ÑÏÑù ÎèÑÍµ¨
   */
  async analyzeUserPatterns(args) {
    const { userId, timeRange = '30d', includeRecommendations = true } = args;

    try {
      // ÏãúÍ∞Ñ Î≤îÏúÑ ÏÑ§Ï†ï
      const daysAgo = this.getDaysFromTimeRange(timeRange);
      const timeFilter = new Date();
      timeFilter.setDate(timeFilter.getDate() - daysAgo);

      const { data: userLogs, error } = await this.supabase
        .from('search_logs')
        .select('search_query, search_type, results_count, created_at')
        .eq('user_id', userId)
        .gte('created_at', timeFilter.toISOString())
        .order('created_at', { ascending: false });

      if (error) {
        throw new Error(`User logs query failed: ${error.message}`);
      }

      const patterns = this.analyzePatterns(userLogs);
      
      // Ï∂îÏ≤ú ÏÉùÏÑ±
      let recommendations = [];
      if (includeRecommendations && userLogs.length > 0) {
        recommendations = await this.generatePersonalizedRecommendations(patterns);
      }

      const result = {
        userId,
        timeRange,
        analysisDate: new Date().toISOString(),
        patterns: {
          totalSearches: userLogs.length,
          avgSearchesPerDay: Math.round((userLogs.length / daysAgo) * 10) / 10,
          favoriteCategories: this.extractFavoriteCategories(userLogs),
          searchTimes: this.analyzeSearchTimes(userLogs),
          searchTypes: this.analyzeSearchTypes(userLogs),
          recentKeywords: userLogs.slice(0, 10).map(log => log.search_query),
          peakSearchHours: this.identifyPeakSearchHours(userLogs),
          categoryEvolution: this.analyzeCategoryEvolution(userLogs),
          searchComplexity: this.analyzeSearchComplexity(userLogs)
        },
        insights: {
          mostActiveDay: this.findMostActiveDay(userLogs),
          preferredSearchType: this.findPreferredSearchType(userLogs),
          diversityScore: this.calculateDiversityScore(userLogs),
          loyaltyScore: this.calculateLoyaltyScore(userLogs)
        },
        recommendations: recommendations
      };

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result, null, 2)
          }
        ]
      };

    } catch (error) {
      console.error('ÏÇ¨Ïö©Ïûê Ìå®ÌÑ¥ Î∂ÑÏÑù Ïã§Ìå®:', error);
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify({
              error: "ÏÇ¨Ïö©Ïûê Ìå®ÌÑ¥ Î∂ÑÏÑù Ïã§Ìå®",
              message: error.message,
              userId,
              fallback: this.getDefaultUserPattern()
            }, null, 2)
          }
        ]
      };
    }
  }

  /**
   * Ïã§ÏãúÍ∞Ñ Ìä∏Î†åÎìú Î∂ÑÏÑù ÎèÑÍµ¨
   */
  async getRealtimeTrends(args) {
    const { timeWindow = 1, detectSurging = true, groupByTimeSlots = true } = args;

    try {
      const hoursAgo = new Date();
      hoursAgo.setHours(hoursAgo.getHours() - timeWindow);

      const { data: recentLogs, error } = await this.supabase
        .from('search_logs')
        .select('search_query, created_at')
        .gte('created_at', hoursAgo.toISOString())
        .order('created_at', { ascending: false });

      if (error) {
        throw new Error(`Realtime trends query failed: ${error.message}`);
      }

      let timeSlots = [];
      let surgingKeywords = [];

      if (groupByTimeSlots) {
        // 10Î∂Ñ Îã®ÏúÑÎ°ú Í∑∏Î£πÌôî
        timeSlots = this.groupByTimeSlots(recentLogs, 10);
      }

      if (detectSurging) {
        // Í∏âÏÉÅÏäπ ÌÇ§ÏõåÎìú ÌÉêÏßÄ
        surgingKeywords = this.detectSurgingKeywords(recentLogs, timeWindow);
      }

      // ÏµúÍ∑º ÌÇ§ÏõåÎìú ÎπàÎèÑ Î∂ÑÏÑù
      const keywordFrequency = this.calculateKeywordFrequency(recentLogs);
      const topRecentKeywords = Object.entries(keywordFrequency)
        .sort(([,a], [,b]) => b - a)
        .slice(0, 10)
        .map(([keyword, count]) => ({ keyword, count }));

      const result = {
        timeWindow: `${timeWindow}h`,
        totalSearches: recentLogs.length,
        searchesPerHour: Math.round(recentLogs.length / timeWindow),
        topKeywords: topRecentKeywords,
        timeSlots: groupByTimeSlots ? timeSlots : null,
        surgingKeywords: detectSurging ? surgingKeywords : null,
        trendingCategories: this.identifyTrendingCategories(recentLogs),
        activityLevel: this.calculateActivityLevel(recentLogs.length, timeWindow),
        lastUpdate: new Date().toISOString()
      };

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result, null, 2)
          }
        ]
      };

    } catch (error) {
      console.error('Ïã§ÏãúÍ∞Ñ Ìä∏Î†åÎìú Î∂ÑÏÑù Ïã§Ìå®:', error);
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify({
              error: "Ïã§ÏãúÍ∞Ñ Ìä∏Î†åÎìú Î∂ÑÏÑù Ïã§Ìå®",
              message: error.message,
              fallback: {
                totalSearches: 0,
                timeSlots: [],
                surgingKeywords: []
              }
            }, null, 2)
          }
        ]
      };
    }
  }

  /**
   * Í≤ÄÏÉâ ÌôúÎèô Î°úÍπÖ ÎèÑÍµ¨
   */
  async logSearchActivity(args) {
    const { userId, searchQuery, metadata = {} } = args;

    try {
      const searchLog = {
        user_id: userId || null,
        search_query: searchQuery,
        search_type: metadata.searchType || 'basic',
        results_count: metadata.resultsCount || 0,
        response_time: metadata.responseTime || 0,
        user_tier: metadata.userTier || 'free',
        ip_address: metadata.ipAddress || '0.0.0.0',
        user_agent: metadata.userAgent || '',
        created_at: new Date().toISOString()
      };

      const { error } = await this.supabase
        .from('search_logs')
        .insert([searchLog]);

      if (error) {
        throw new Error(`Log insertion failed: ${error.message}`);
      }

      // Ï∫êÏãú Î¨¥Ìö®Ìôî
      this.invalidateRelatedCaches(searchQuery);

      const result = {
        success: true,
        message: 'Í≤ÄÏÉâ ÌôúÎèôÏù¥ Í∏∞Î°ùÎêòÏóàÏäµÎãàÎã§',
        logData: {
          searchQuery,
          userId: userId || 'anonymous',
          searchType: searchLog.search_type,
          timestamp: searchLog.created_at
        }
      };

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result, null, 2)
          }
        ]
      };

    } catch (error) {
      console.error('Í≤ÄÏÉâ ÌôúÎèô Î°úÍπÖ Ïã§Ìå®:', error);
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify({
              success: false,
              error: "Í≤ÄÏÉâ ÌôúÎèô Î°úÍπÖ Ïã§Ìå®",
              message: error.message,
              searchQuery
            }, null, 2)
          }
        ]
      };
    }
  }

  /**
   * Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Ìä∏Î†åÎìú Î∂ÑÏÑù ÎèÑÍµ¨
   */
  async getCategoryTrends(args) {
    const { categories = [], timeRange = '24h', includeGrowthRate = true } = args;

    try {
      const timeFilter = this.getTimeFilter(timeRange);
      
      const { data: searchLogs, error } = await this.supabase
        .from('search_logs')
        .select('search_query, created_at')
        .gte('created_at', timeFilter)
        .not('search_query', 'is', null);

      if (error) {
        throw new Error(`Category trends query failed: ${error.message}`);
      }

      // Í∞Å Í≤ÄÏÉâÏñ¥Î•º Ïπ¥ÌÖåÍ≥†Î¶¨Î≥ÑÎ°ú Î∂ÑÎ•ò
      const categoryData = this.categorizeLogs(searchLogs);
      
      // ÌäπÏ†ï Ïπ¥ÌÖåÍ≥†Î¶¨Îßå ÌïÑÌÑ∞ÎßÅ (ÏöîÏ≤≠Îêú Í≤ΩÏö∞)
      const targetCategories = categories.length > 0 ? categories : Object.keys(categoryData);
      
      const categoryTrends = {};
      
      for (const category of targetCategories) {
        if (categoryData[category]) {
          const categoryLogs = categoryData[category];
          
          categoryTrends[category] = {
            totalSearches: categoryLogs.length,
            uniqueKeywords: new Set(categoryLogs.map(log => log.search_query)).size,
            topKeywords: this.getTopKeywordsInCategory(categoryLogs),
            searchVolume: this.calculateSearchVolume(categoryLogs, timeRange),
            growthRate: includeGrowthRate ? await this.calculateCategoryGrowthRate(category, timeRange) : null,
            peakHours: this.identifyPeakHours(categoryLogs),
            averageSearchLength: this.calculateAverageSearchLength(categoryLogs)
          };
        }
      }

      // Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ ÏÉÅÎåÄÏ†Å Ïù∏Í∏∞ÎèÑ Í≥ÑÏÇ∞
      const totalSearches = Object.values(categoryTrends).reduce((sum, data) => sum + data.totalSearches, 0);
      
      Object.keys(categoryTrends).forEach(category => {
        categoryTrends[category].marketShare = totalSearches > 0 ? 
          Math.round((categoryTrends[category].totalSearches / totalSearches) * 100) : 0;
      });

      const result = {
        timeRange,
        categoriesAnalyzed: targetCategories,
        totalSearches,
        categoryTrends,
        topCategories: Object.entries(categoryTrends)
          .sort(([,a], [,b]) => b.totalSearches - a.totalSearches)
          .slice(0, 5)
          .map(([category, data]) => ({ category, searches: data.totalSearches })),
        timestamp: new Date().toISOString()
      };

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result, null, 2)
          }
        ]
      };

    } catch (error) {
      console.error('Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Ìä∏Î†åÎìú Î∂ÑÏÑù Ïã§Ìå®:', error);
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify({
              error: "Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Ìä∏Î†åÎìú Î∂ÑÏÑù Ïã§Ìå®",
              message: error.message,
              fallback: { categoryTrends: {} }
            }, null, 2)
          }
        ]
      };
    }
  }

  /**
   * Ìä∏Î†åÎî© ÌÇ§ÏõåÎìú ÏòàÏ∏° ÎèÑÍµ¨
   */
  async predictTrendingKeywords(args) {
    const { 
      predictionWindow = '6h', 
      limit = 10, 
      confidenceThreshold = 0.7,
      includeReasons = true 
    } = args;

    try {
      // ÏòàÏ∏°ÏùÑ ÏúÑÌïú Îã§ÏñëÌïú ÏãúÍ∞Ñ Î≤îÏúÑ Îç∞Ïù¥ÌÑ∞ ÏàòÏßë
      const currentHour = this.getTimeFilter('1h');
      const lastSixHours = this.getTimeFilter('6h');
      const lastDay = this.getTimeFilter('24h');

      const [currentData, sixHourData, dayData] = await Promise.all([
        this.getSearchData(currentHour),
        this.getSearchData(lastSixHours),
        this.getSearchData(lastDay)
      ]);

      // ÌÇ§ÏõåÎìúÎ≥Ñ ÏÑ±Ïû•Î•† Í≥ÑÏÇ∞
      const keywordGrowthRates = this.calculateKeywordGrowthRates(currentData, sixHourData, dayData);
      
      // ÏòàÏ∏° ÏïåÍ≥†Î¶¨Ï¶ò Ï†ÅÏö©
      const predictions = this.generatePredictions(keywordGrowthRates, predictionWindow);
      
      // Ïã†Î¢∞ÎèÑ ÌïÑÌÑ∞ÎßÅ
      const filteredPredictions = predictions.filter(p => p.confidence >= confidenceThreshold);
      
      // ÏÉÅÏúÑ ÏòàÏ∏° ÌÇ§ÏõåÎìú ÏÑ†ÌÉù
      const topPredictions = filteredPredictions
        .sort((a, b) => b.trendingScore - a.trendingScore)
        .slice(0, limit);

      const result = {
        predictionWindow,
        confidenceThreshold,
        totalPredictions: predictions.length,
        qualifiedPredictions: filteredPredictions.length,
        predictions: topPredictions.map(p => ({
          keyword: p.keyword,
          trendingScore: Math.round(p.trendingScore * 100) / 100,
          confidence: Math.round(p.confidence * 100) / 100,
          category: this.categorizeKeyword(p.keyword),
          growthRate: p.growthRate,
          currentSearchVolume: p.currentVolume,
          predictedSearchVolume: p.predictedVolume,
          reasons: includeReasons ? p.reasons : undefined
        })),
        algorithm: {
          name: "Momentum Trend Prediction v1.0",
          factors: ["growth_rate", "search_volume", "category_momentum", "time_patterns"],
          dataPoints: currentData.length + sixHourData.length + dayData.length
        },
        timestamp: new Date().toISOString()
      };

      return {
        content: [
          {
            type: "text",
            text: JSON.stringify(result, null, 2)
          }
        ]
      };

    } catch (error) {
      console.error('Ìä∏Î†åÎî© ÌÇ§ÏõåÎìú ÏòàÏ∏° Ïã§Ìå®:', error);
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify({
              error: "Ìä∏Î†åÎî© ÌÇ§ÏõåÎìú ÏòàÏ∏° Ïã§Ìå®",
              message: error.message,
              fallback: {
                predictions: [],
                algorithm: "fallback"
              }
            }, null, 2)
          }
        ]
      };
    }
  }

  // ==================== Ìó¨Ìçº Î©îÏÑúÎìúÎì§ ====================

  getTimeFilter(timeRange) {
    const now = new Date();
    
    switch (timeRange) {
      case '1h':
        return new Date(now.getTime() - 60 * 60 * 1000).toISOString();
      case '6h':
        return new Date(now.getTime() - 6 * 60 * 60 * 1000).toISOString();
      case '24h':
        return new Date(now.getTime() - 24 * 60 * 60 * 1000).toISOString();
      case '7d':
        return new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000).toISOString();
      case '30d':
        return new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000).toISOString();
      default:
        return new Date(now.getTime() - 24 * 60 * 60 * 1000).toISOString();
    }
  }

  getDaysFromTimeRange(timeRange) {
    switch (timeRange) {
      case '7d': return 7;
      case '30d': return 30;
      case '90d': return 90;
      default: return 30;
    }
  }

  calculateKeywordFrequency(searchLogs) {
    const frequency = new Map();
    
    searchLogs.forEach(log => {
      const keyword = log.search_query.toLowerCase().trim();
      if (keyword.length > 0) {
        frequency.set(keyword, (frequency.get(keyword) || 0) + 1);
      }
    });
    
    return Object.fromEntries(frequency);
  }

  calculateTrendScores(searchLogs, timeRange) {
    const scores = new Map();
    const now = Date.now();
    const timeWindow = this.getTimeWindowMs(timeRange);
    
    searchLogs.forEach(log => {
      const keyword = log.search_query.toLowerCase().trim();
      const logTime = new Date(log.created_at).getTime();
      const timeElapsed = now - logTime;
      
      // ÏµúÍ∑ºÏùºÏàòÎ°ù ÎÜíÏùÄ Í∞ÄÏ§ëÏπò
      const timeWeight = Math.exp(-timeElapsed / (timeWindow * 0.3));
      
      scores.set(keyword, (scores.get(keyword) || 0) + timeWeight);
    });
    
    return Object.fromEntries(scores);
  }

  getTimeWindowMs(timeRange) {
    switch (timeRange) {
      case '1h': return 60 * 60 * 1000;
      case '6h': return 6 * 60 * 60 * 1000;
      case '24h': return 24 * 60 * 60 * 1000;
      case '7d': return 7 * 24 * 60 * 60 * 1000;
      case '30d': return 30 * 24 * 60 * 60 * 1000;
      default: return 24 * 60 * 60 * 1000;
    }
  }

  rankKeywords(frequency, trendScores) {
    const keywords = new Set([...Object.keys(frequency), ...Object.keys(trendScores)]);
    
    return Array.from(keywords)
      .map(keyword => ({
        keyword,
        frequency: frequency[keyword] || 0,
        trendScore: trendScores[keyword] || 0,
        totalScore: (frequency[keyword] || 0) * 0.7 + (trendScores[keyword] || 0) * 0.3
      }))
      .sort((a, b) => b.totalScore - a.totalScore);
  }

  filterCommonKeywords(rankedKeywords) {
    const commonKeywords = new Set([
      'ÏòÅÏÉÅ', 'ÎπÑÎîîÏò§', 'ÏáºÏ∏†', 'shorts', 'Ïú†ÌäúÎ∏å', 'youtube',
      'Í≤ÄÏÉâ', 'Ï∞æÍ∏∞', 'Î≥¥Í∏∞', 'Ïû¨ÏÉù', 'Ï∂îÏ≤ú', 'Ïù∏Í∏∞'
    ]);
    
    return rankedKeywords.filter(item => 
      !commonKeywords.has(item.keyword) && 
      item.keyword.length > 1 &&
      !/^[0-9]+$/.test(item.keyword)
    );
  }

  categorizeKeyword(keyword) {
    const categories = {
      gaming: ['Í≤åÏûÑ', 'Î°§', 'Î∞∞Í∑∏', 'ÌîºÌåå', 'Ìè¨Ìä∏ÎÇòÏù¥Ìä∏', 'ÎßàÏù∏ÌÅ¨ÎûòÌîÑÌä∏'],
      food: ['Î®πÎ∞©', 'ÏöîÎ¶¨', 'ÎßõÏßë', 'ÏùåÏãù', 'Î†àÏãúÌîº', 'Ïπ¥Ìéò'],
      music: ['ÏùåÏïÖ', 'ÎÖ∏Îûò', 'kpop', 'ÎåÑÏä§', 'mv', 'ÎÆ§ÏßÅ'],
      lifestyle: ['Î∏åÏù¥Î°úÍ∑∏', 'ÏùºÏÉÅ', 'Î£®Ìã¥', 'Îç∞Ïù¥Ìä∏', 'Ïó¨Ìñâ'],
      sports: ['Ï∂ïÍµ¨', 'ÏïºÍµ¨', 'ÎÜçÍµ¨', 'Ïö¥Îèô', 'Ìó¨Ïä§', 'Îã§Ïù¥Ïñ¥Ìä∏'],
      entertainment: ['ÏòàÎä•', 'ÎìúÎùºÎßà', 'ÏòÅÌôî', 'ÏõÉÍ∏¥', 'Ïû¨ÎØ∏']
    };

    for (const [category, keywords] of Object.entries(categories)) {
      if (keywords.some(cat => keyword.includes(cat))) {
        return category;
      }
    }
    
    return 'general';
  }

  enrichKeywordData(topKeywords, timeRange) {
    return topKeywords.map((item, index) => ({
      rank: index + 1,
      keyword: item.keyword,
      searchCount: item.frequency,
      trendScore: Math.round(item.trendScore * 100) / 100,
      totalScore: Math.round(item.totalScore * 100) / 100,
      category: this.categorizeKeyword(item.keyword),
      estimatedPopularity: this.estimatePopularity(item.frequency, timeRange)
    }));
  }

  estimatePopularity(frequency, timeRange) {
    // ÏãúÍ∞Ñ Î≤îÏúÑÎ≥Ñ Í∏∞Ï§Ä Í∞í
    const thresholds = {
      '1h': { high: 10, medium: 3 },
      '6h': { high: 30, medium: 10 },
      '24h': { high: 100, medium: 30 },
      '7d': { high: 500, medium: 150 },
      '30d': { high: 2000, medium: 600 }
    };

    const threshold = thresholds[timeRange] || thresholds['24h'];
    
    if (frequency >= threshold.high) return 'high';
    if (frequency >= threshold.medium) return 'medium';
    return 'low';
  }

  analyzePatterns(userLogs) {
    return {
      totalSearches: userLogs.length,
      favoriteCategories: this.extractFavoriteCategories(userLogs),
      searchTimes: this.analyzeSearchTimes(userLogs),
      searchTypes: this.analyzeSearchTypes(userLogs)
    };
  }

  extractFavoriteCategories(userLogs) {
    const categoryCount = {};
    
    userLogs.forEach(log => {
      const category = this.categorizeKeyword(log.search_query);
      categoryCount[category] = (categoryCount[category] || 0) + 1;
    });
    
    return Object.entries(categoryCount)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 3)
      .map(([category, count]) => ({ category, count }));
  }

  analyzeSearchTimes(userLogs) {
    const hourCounts = {};
    
    userLogs.forEach(log => {
      const hour = new Date(log.created_at).getHours();
      hourCounts[hour] = (hourCounts[hour] || 0) + 1;
    });
    
    return hourCounts;
  }

  analyzeSearchTypes(userLogs) {
    const typeCounts = {};
    
    userLogs.forEach(log => {
      const type = log.search_type || 'basic';
      typeCounts[type] = (typeCounts[type] || 0) + 1;
    });
    
    return typeCounts;
  }

  async generatePersonalizedRecommendations(patterns) {
    // Í∞ÑÎã®Ìïú Ï∂îÏ≤ú Î°úÏßÅ
    const recommendations = [];
    
    // ÏÑ†Ìò∏ Ïπ¥ÌÖåÍ≥†Î¶¨ Í∏∞Î∞ò Ï∂îÏ≤ú
    if (patterns.favoriteCategories.length > 0) {
      const topCategory = patterns.favoriteCategories[0].category;
      recommendations.push({
        type: 'category_based',
        suggestion: `${topCategory} Ïπ¥ÌÖåÍ≥†Î¶¨Ïùò ÏÉàÎ°úÏö¥ Ìä∏Î†åÎìú ÌÉêÏÉâ`,
        reason: `Í∞ÄÏû• ÎßéÏù¥ Í≤ÄÏÉâÌïú Ïπ¥ÌÖåÍ≥†Î¶¨ÏûÖÎãàÎã§`
      });
    }
    
    return recommendations;
  }

  getFallbackPopularKeywords() {
    return [
      { rank: 1, keyword: 'Î®πÎ∞©', category: 'food', estimatedPopularity: 'high' },
      { rank: 2, keyword: 'Î∏åÏù¥Î°úÍ∑∏', category: 'lifestyle', estimatedPopularity: 'high' },
      { rank: 3, keyword: 'Í≤åÏûÑ', category: 'gaming', estimatedPopularity: 'medium' }
    ];
  }

  getDefaultUserPattern() {
    return {
      totalSearches: 0,
      favoriteCategories: [],
      searchTimes: {},
      searchTypes: {}
    };
  }

  invalidateRelatedCaches(searchQuery) {
    const keysToDelete = [];
    for (const key of this.cache.keys()) {
      if (key.includes('popular') || key.includes('trends')) {
        keysToDelete.push(key);
      }
    }
    keysToDelete.forEach(key => this.cache.delete(key));
  }

  // Ï∂îÍ∞Ä Î∂ÑÏÑù Î©îÏÑúÎìúÎì§...
  groupByTimeSlots(logs, minuteWindow) {
    // ÏãúÍ∞ÑÎåÄÎ≥Ñ Í∑∏Î£πÌôî Î°úÏßÅ
    return [];
  }

  detectSurgingKeywords(logs, timeWindow) {
    // Í∏âÏÉÅÏäπ ÌÇ§ÏõåÎìú ÌÉêÏßÄ Î°úÏßÅ
    return [];
  }

  identifyTrendingCategories(logs) {
    // Ìä∏Î†åÎî© Ïπ¥ÌÖåÍ≥†Î¶¨ ÏãùÎ≥Ñ Î°úÏßÅ
    return {};
  }

  calculateActivityLevel(searchCount, timeWindow) {
    // ÌôúÎèô ÏàòÏ§Ä Í≥ÑÏÇ∞
    const searchesPerHour = searchCount / timeWindow;
    if (searchesPerHour > 100) return 'very_high';
    if (searchesPerHour > 50) return 'high';
    if (searchesPerHour > 20) return 'medium';
    if (searchesPerHour > 5) return 'low';
    return 'very_low';
  }

  async getSearchData(timeFilter) {
    const { data, error } = await this.supabase
      .from('search_logs')
      .select('search_query, created_at')
      .gte('created_at', timeFilter);
    
    return error ? [] : data;
  }

  calculateKeywordGrowthRates(current, sixHour, day) {
    // ÏÑ±Ïû•Î•† Í≥ÑÏÇ∞ Î°úÏßÅ
    return {};
  }

  generatePredictions(growthRates, window) {
    // ÏòàÏ∏° ÏÉùÏÑ± Î°úÏßÅ
    return [];
  }

  // Îçî ÎßéÏùÄ Î∂ÑÏÑù Î©îÏÑúÎìúÎì§...
  identifyPeakSearchHours(logs) { return []; }
  analyzeCategoryEvolution(logs) { return {}; }
  analyzeSearchComplexity(logs) { return 0; }
  findMostActiveDay(logs) { return null; }
  findPreferredSearchType(logs) { return null; }
  calculateDiversityScore(logs) { return 0; }
  calculateLoyaltyScore(logs) { return 0; }
  categorizeLogs(logs) { return {}; }
  getTopKeywordsInCategory(logs) { return []; }
  calculateSearchVolume(logs, range) { return 0; }
  async calculateCategoryGrowthRate(category, range) { return 0; }
  identifyPeakHours(logs) { return []; }
  calculateAverageSearchLength(logs) { return 0; }

  async start() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.log('üöÄ User Analytics MCP ÏÑúÎ≤Ñ ÏãúÏûëÎê®');
  }
}

// ÏÑúÎ≤Ñ ÏãúÏûë
const server = new UserAnalyticsMCP();
server.start().catch(error => {
  console.error('ÏÑúÎ≤Ñ ÏãúÏûë Ïã§Ìå®:', error);
  process.exit(1);
}); 