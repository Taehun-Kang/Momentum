# 8. íŠ¸ë Œë“œ ë¶„ì„ ì‹œìŠ¤í…œ ìš”ì•½

> ìƒì„¸ ë¬¸ì„œ: [docs/basic/8.íŠ¸ë Œë“œ ë¶„ì„ ì‹œìŠ¤í…œ.md](../basic/8.íŠ¸ë Œë“œ%20ë¶„ì„%20ì‹œìŠ¤í…œ.md)

## ğŸ¯ í•µì‹¬ ì„±ê³¼ ì§€í‘œ

### íŠ¸ë Œë“œ ì˜ˆì¸¡ ì •í™•ë„

- **ì‹¤ì‹œê°„ íŠ¸ë Œë“œ**: 85% ì •í™•ë„ (5ë¶„ ê°„ê²©)
- **ì¼ì¼ íŠ¸ë Œë“œ**: 90% ì •í™•ë„ (1ì‹œê°„ ê°„ê²©)
- **ì¹´í…Œê³ ë¦¬ë³„ íŠ¸ë Œë“œ**: 80% ì •í™•ë„ (2ì‹œê°„ ê°„ê²©)
- **ì§€ì—­ë³„ ë¶„ì„**: 75% ì •í™•ë„ (ì£¼ìš” 7ê°œ ë„ì‹œ)

### ë°ì´í„° ì»¤ë²„ë¦¬ì§€

- **íŠ¸ë Œë“œ ì†ŒìŠ¤**: 3ê°œ ì£¼ìš” MCP (Bright Data, SerpAPI, ë‚´ë¶€)
- **ìˆ˜ì§‘ í‚¤ì›Œë“œ**: ì¼ì¼ 500-1000ê°œ
- **ì¹´í…Œê³ ë¦¬**: 10ê°œ ì£¼ìš” ë¶„ì•¼
- **ì§€ì—­**: 7ê°œ ì£¼ìš” ë„ì‹œ

## ğŸ§  Bright Data MCP í•µì‹¬ ì „ëµ

### MCP í´ë¼ì´ì–¸íŠ¸ êµ¬ì„±

```javascript
// services/brightdata-trend-collector.js
export class BrightDataTrendCollector {
  constructor(supabaseMCP) {
    this.brightData = new MCPClient({
      name: "bright-data-trends",
      version: "1.0.0",
      transport: {
        command: "npx",
        args: ["-y", "@brightdata/mcp-server"],
      },
    });

    this.config = {
      region: "KR",
      language: "ko",
      updateIntervals: {
        realtime: 5 * 60 * 1000, // 5ë¶„
        daily: 60 * 60 * 1000, // 1ì‹œê°„
        weekly: 24 * 60 * 60 * 1000, // 24ì‹œê°„
      },
    };
  }

  // ì‹¤ì‹œê°„ íŠ¸ë Œë“œ ìˆ˜ì§‘ì˜ í•µì‹¬
  async collectRealtimeTrends() {
    const results = {
      daily_trends: await this._getDailyTrends(),
      realtime_trends: await this._getRealtimeTrends(),
      categories: await this._getCategoryTrends(),
      regional: await this._getRegionalTrends(),
    };

    // Supabase MCPë¡œ ì €ì¥
    await this._saveTrendsToDatabase(results);
    return results;
  }
}
```

### ì¼ì¼ íŠ¸ë Œë“œ ìˆ˜ì§‘ ì›Œí¬í”Œë¡œìš°

```javascript
async _getDailyTrends() {
  // 1. Bright Data MCP í˜¸ì¶œ
  const result = await this.brightData.callTool('web_search', {
  query: 'trending youtube shorts korea today',
  country: 'KR',
  language: 'ko',
  filter: {
    time_range: 'past_day',
      source_type: ['google_trends', 'youtube_trending', 'naver_datalab']
    }
  });

  // 2. AI í‚¤ì›Œë“œ ì¶”ì¶œ
  const searchResults = JSON.parse(result.content[0].text);
  const trends = [];

  for (const item of searchResults.results) {
    const keywords = await this.brightData.callTool('extract_keywords', {
      text: item.snippet,
      context: 'youtube_shorts_daily_trends',
      language: 'ko'
    });

    const extracted = JSON.parse(keywords.content[0].text);
    trends.push({
      keyword: extracted.primary_keyword,
      rank: trends.length + 1,
      type: 'daily',
      score: extracted.relevance_score,
      related_keywords: extracted.related_keywords,
      source: item.source
    });
  }

  return trends.slice(0, 20); // ìƒìœ„ 20ê°œ
}
```

### ì‹¤ì‹œê°„ ê¸‰ìƒìŠ¹ íŠ¸ë Œë“œ ê°ì§€

```javascript
async _getRealtimeTrends() {
  // ê¸‰ìƒìŠ¹ ì¿¼ë¦¬ ë¶„ì„
  const result = await this.brightData.callTool('analyze_trend', {
    keyword: 'youtube shorts',
    metrics: ['real_time_interest', 'breakout_topics', 'rising_queries'],
    timeframe: 'past_hour',
    region: 'KR'
  });

  const analysis = JSON.parse(result.content[0].text);
  const trends = [];

  for (const query of analysis.rising_queries || []) {
    trends.push({
      title: query.term,
      traffic: query.growth_rate,
      trend_score: query.interest_score,
      type: 'realtime',
      articles: await this._getRelatedArticles(query.term)
    });
  }

  return trends;
}
```

## ğŸ” SerpAPI Google Trends í†µí•© (ë°±ì—… ì „ëµ)

### SerpAPI í´ë¼ì´ì–¸íŠ¸ êµ¬ì„±

```javascript
// services/serpapi-trend-collector.js
import { GoogleTrends } from "google-search-results-nodejs";

export class SerpApiTrendCollector {
  constructor() {
    this.serpApi = new GoogleTrends(process.env.SERPAPI_KEY);
    this.config = {
      region: "KR",
      language: "ko",
      timeout: 10000,
      retries: 3,
    };
  }

  // Google Trends ë°ì´í„° ìˆ˜ì§‘ (Bright Data ë°±ì—…)
  async collectGoogleTrends(keyword) {
    try {
      // 1. Google Trends Interest Over Time
      const interestOverTime = await this.serpApi.search({
        engine: "google_trends",
        q: keyword,
        geo: this.config.region,
        date: "today 1-m", // ìµœê·¼ 1ê°œì›”
        data_type: "TIMESERIES",
      });

      // 2. Related Queries (ì—°ê´€ ê²€ìƒ‰ì–´)
      const relatedQueries = await this.serpApi.search({
        engine: "google_trends",
        q: keyword,
        geo: this.config.region,
        data_type: "RELATED_QUERIES",
      });

      // 3. Rising Searches (ê¸‰ìƒìŠ¹ ê²€ìƒ‰ì–´)
      const risingSearches = await this.serpApi.search({
        engine: "google_trends",
        q: keyword,
        geo: this.config.region,
        data_type: "RELATED_QUERIES",
        cat: 0, // ëª¨ë“  ì¹´í…Œê³ ë¦¬
      });

      return this._processTrendsData({
        interestOverTime:
          interestOverTime.interest_over_time?.timeline_data || [],
        relatedQueries: relatedQueries.related_queries?.top || [],
        risingSearches: risingSearches.related_queries?.rising || [],
      });
    } catch (error) {
      console.error("SerpAPI Google Trends ìˆ˜ì§‘ ì‹¤íŒ¨:", error);
      throw error;
    }
  }

  // ì‹¤ì‹œê°„ ê¸‰ìƒìŠ¹ ê²€ìƒ‰ì–´ ê°ì§€
  async detectRisingTrends() {
    try {
      const risingTrends = await this.serpApi.search({
        engine: "google_trends_trending_now",
        geo: this.config.region,
        hl: this.config.language,
      });

      return (
        risingTrends.trending_searches?.map((trend) => ({
          keyword: trend.query,
          traffic: trend.traffic,
          articles: trend.articles?.slice(0, 3) || [],
          formattedTraffic: trend.formattedTraffic,
          relatedQueries: trend.relatedQueries || [],
          type: "rising",
          source: "serpapi_trends",
          timestamp: new Date().toISOString(),
        })) || []
      );
    } catch (error) {
      console.error("ê¸‰ìƒìŠ¹ íŠ¸ë Œë“œ ê°ì§€ ì‹¤íŒ¨:", error);
      return [];
    }
  }

  // ì¹´í…Œê³ ë¦¬ë³„ Google Trends
  async getCategoryTrends(category) {
    const categoryMap = {
      ìŒì•…: 0, // All categories
      ë‰´ìŠ¤: 16, // News
      ìŠ¤í¬ì¸ : 20, // Sports
      ê²Œì„: 8, // Games
      ì—”í„°í…Œì¸ë¨¼íŠ¸: 3, // Entertainment
      ê¸°ìˆ : 5, // Computers & Electronics
      ì‡¼í•‘: 18, // Shopping
      ì—¬í–‰: 67, // Travel
      ë·°í‹°: 44, // Beauty & Fitness
      ìš”ë¦¬: 71, // Food & Drink
    };

    try {
      const trendsData = await this.serpApi.search({
        engine: "google_trends",
        q: "", // ë¹ˆ ì¿¼ë¦¬ë¡œ ì¹´í…Œê³ ë¦¬ ì „ì²´ íŠ¸ë Œë“œ
        geo: this.config.region,
        cat: categoryMap[category] || 0,
        date: "today 7-d", // ìµœê·¼ 7ì¼
        data_type: "RELATED_QUERIES",
      });

      return (
        trendsData.related_queries?.top?.slice(0, 10).map((item) => ({
          keyword: item.query,
          value: item.value,
          formattedValue: item.formattedValue,
          category,
          source: "serpapi_category",
          timestamp: new Date().toISOString(),
        })) || []
      );
    } catch (error) {
      console.error(`ì¹´í…Œê³ ë¦¬ ${category} íŠ¸ë Œë“œ ìˆ˜ì§‘ ì‹¤íŒ¨:`, error);
      return [];
    }
  }

  // ì§€ì—­ë³„ Google Trends ë¹„êµ
  async compareRegionalTrends(keyword, regions = ["KR-11", "KR-26", "KR-27"]) {
    try {
      const regionalData = {};

      for (const region of regions) {
        const data = await this.serpApi.search({
          engine: "google_trends",
          q: keyword,
          geo: region,
          date: "today 1-m",
          data_type: "TIMESERIES",
        });

        const regionName = this._getRegionName(region);
        regionalData[regionName] = {
          timeline: data.interest_over_time?.timeline_data || [],
          averageInterest: this._calculateAverageInterest(
            data.interest_over_time?.timeline_data || []
          ),
          region: region,
        };

        // API ì œí•œ ê³ ë ¤
        await new Promise((resolve) => setTimeout(resolve, 1000));
      }

      return regionalData;
    } catch (error) {
      console.error("ì§€ì—­ë³„ íŠ¸ë Œë“œ ë¹„êµ ì‹¤íŒ¨:", error);
      return {};
    }
  }

  _processTrendsData(data) {
    return {
      trend_score: this._calculateTrendScore(data.interestOverTime),
      growth_rate: this._calculateGrowthRate(data.interestOverTime),
      related_keywords: data.relatedQueries.slice(0, 5).map((q) => q.query),
      rising_keywords: data.risingSearches.slice(0, 5).map((q) => q.query),
      peak_interest: this._findPeakInterest(data.interestOverTime),
      consistency: this._calculateConsistency(data.interestOverTime),
    };
  }

  _calculateTrendScore(timelineData) {
    if (!timelineData || timelineData.length === 0) return 0;

    const values = timelineData.map((item) => item.values?.[0]?.value || 0);
    const recent = values.slice(-7); // ìµœê·¼ 7ì¼
    const earlier = values.slice(-14, -7); // ì´ì „ 7ì¼

    const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length;
    const earlierAvg = earlier.reduce((a, b) => a + b, 0) / earlier.length;

    return earlierAvg > 0 ? ((recentAvg - earlierAvg) / earlierAvg) * 100 : 0;
  }

  _getRegionName(regionCode) {
    const regions = {
      "KR-11": "ì„œìš¸",
      "KR-26": "ë¶€ì‚°",
      "KR-27": "ëŒ€êµ¬",
      "KR-28": "ì¸ì²œ",
      "KR-29": "ê´‘ì£¼",
      "KR-30": "ëŒ€ì „",
      "KR-43": "ì¶©ë¶",
      "KR-44": "ì¶©ë‚¨",
      "KR-45": "ì „ë¶",
      "KR-46": "ì „ë‚¨",
      "KR-47": "ê²½ë¶",
      "KR-48": "ê²½ë‚¨",
      "KR-49": "ì œì£¼",
    };
    return regions[regionCode] || regionCode;
  }
}
```

### ë‹¤ì¤‘ ì†ŒìŠ¤ íŠ¸ë Œë“œ í†µí•© ì „ëµ

```javascript
// services/multi-source-trend-aggregator.js
export class MultiSourceTrendAggregator {
  constructor() {
    this.brightData = new BrightDataTrendCollector();
    this.serpApi = new SerpApiTrendCollector();
    this.sources = {
      primary: "bright_data",
      secondary: "serpapi",
      tertiary: "internal",
    };
  }

  // ë‹¤ì¤‘ ì†ŒìŠ¤ì—ì„œ íŠ¸ë Œë“œ ìˆ˜ì§‘ ë° í†µí•©
  async aggregateTrends(keyword) {
    const results = {
      keyword,
      sources: {},
      aggregated: {},
      confidence: 0,
      timestamp: new Date().toISOString(),
    };

    try {
      // 1. Bright Data MCP (ì£¼ìš” ì†ŒìŠ¤)
      try {
        const brightDataResult = await this.brightData.collectKeywordTrend(
          keyword
        );
        results.sources.bright_data = {
          data: brightDataResult,
          success: true,
          weight: 0.5,
        };
      } catch (error) {
        console.warn("Bright Data ìˆ˜ì§‘ ì‹¤íŒ¨:", error.message);
        results.sources.bright_data = { success: false, error: error.message };
      }

      // 2. SerpAPI Google Trends (ë°±ì—… ì†ŒìŠ¤)
      try {
        const serpApiResult = await this.serpApi.collectGoogleTrends(keyword);
        results.sources.serpapi = {
          data: serpApiResult,
          success: true,
          weight: 0.3,
        };
      } catch (error) {
        console.warn("SerpAPI ìˆ˜ì§‘ ì‹¤íŒ¨:", error.message);
        results.sources.serpapi = { success: false, error: error.message };
      }

      // 3. ë‚´ë¶€ ë°ì´í„° (ì‚¬ìš©ì ê²€ìƒ‰ íŒ¨í„´)
      try {
        const internalResult = await this._getInternalTrendData(keyword);
        results.sources.internal = {
          data: internalResult,
          success: true,
          weight: 0.2,
        };
      } catch (error) {
        results.sources.internal = { success: false, error: error.message };
      }

      // 4. ë°ì´í„° í†µí•© ë° ì‹ ë¢°ë„ ê³„ì‚°
      results.aggregated = this._aggregateSourceData(results.sources);
      results.confidence = this._calculateConfidence(results.sources);

      return results;
    } catch (error) {
      console.error("íŠ¸ë Œë“œ í†µí•© ì‹¤íŒ¨:", error);
      throw error;
    }
  }

  // í´ë°± ì „ëµ: ì£¼ìš” ì†ŒìŠ¤ ì‹¤íŒ¨ ì‹œ ë°±ì—… ì†ŒìŠ¤ ì‚¬ìš©
  async getAvailableTrends(keyword) {
    // ìš°ì„ ìˆœìœ„: Bright Data â†’ SerpAPI â†’ Internal
    const strategies = [
      () => this.brightData.collectKeywordTrend(keyword),
      () => this.serpApi.collectGoogleTrends(keyword),
      () => this._getInternalTrendData(keyword),
    ];

    for (const [index, strategy] of strategies.entries()) {
      try {
        const result = await strategy();
        return {
          data: result,
          source: Object.values(this.sources)[index],
          fallback_level: index,
        };
      } catch (error) {
        console.warn(`íŠ¸ë Œë“œ ì†ŒìŠ¤ ${index + 1} ì‹¤íŒ¨:`, error.message);
        continue;
      }
    }

    throw new Error("ëª¨ë“  íŠ¸ë Œë“œ ì†ŒìŠ¤ì—ì„œ ë°ì´í„° ìˆ˜ì§‘ ì‹¤íŒ¨");
  }

  _aggregateSourceData(sources) {
    const successfulSources = Object.entries(sources)
      .filter(([_, source]) => source.success)
      .map(([name, source]) => ({ name, ...source }));

    if (successfulSources.length === 0) {
      return { trend_score: 0, confidence: "low" };
    }

    // ê°€ì¤‘ í‰ê· ìœ¼ë¡œ íŠ¸ë Œë“œ ì ìˆ˜ ê³„ì‚°
    let weightedScore = 0;
    let totalWeight = 0;

    successfulSources.forEach((source) => {
      const score = source.data?.trend_score || 0;
      const weight = source.weight || 0.1;

      weightedScore += score * weight;
      totalWeight += weight;
    });

    const finalScore = totalWeight > 0 ? weightedScore / totalWeight : 0;

    return {
      trend_score: Math.round(finalScore * 100) / 100,
      source_count: successfulSources.length,
      successful_sources: successfulSources.map((s) => s.name),
      related_keywords: this._mergeRelatedKeywords(successfulSources),
      regional_data: this._mergeRegionalData(successfulSources),
    };
  }

  _calculateConfidence(sources) {
    const totalSources = Object.keys(sources).length;
    const successfulSources = Object.values(sources).filter(
      (source) => source.success
    ).length;

    const baseConfidence = successfulSources / totalSources;

    // ì£¼ìš” ì†ŒìŠ¤(Bright Data) ì„±ê³µ ì‹œ ì‹ ë¢°ë„ ë³´ë„ˆìŠ¤
    if (sources.bright_data?.success) {
      return Math.min(baseConfidence + 0.2, 1.0);
    }

    return baseConfidence;
  }
}
```

### API ì‚¬ìš©ëŸ‰ ìµœì í™” ì „ëµ

```javascript
// SerpAPI í• ë‹¹ëŸ‰ ê´€ë¦¬
const serpApiQuota = {
  monthly_limit: 10000, // ì›” 10,000 ê²€ìƒ‰
  daily_target: 300, // ì¼ì¼ 300íšŒ ëª©í‘œ
  priority_allocation: {
    realtime_trends: 0.4, // 40% - ì‹¤ì‹œê°„ íŠ¸ë Œë“œ
    category_analysis: 0.3, // 30% - ì¹´í…Œê³ ë¦¬ ë¶„ì„
    regional_comparison: 0.2, // 20% - ì§€ì—­ ë¹„êµ
    backup_requests: 0.1, // 10% - Bright Data ë°±ì—…
  },
};

// ë¹„ìš© íš¨ìœ¨ì  ì‚¬ìš© íŒ¨í„´
const optimizedUsage = {
  peak_hours: "09:00-18:00", // í”¼í¬ ì‹œê°„ëŒ€ ì§‘ì¤‘ ì‚¬ìš©
  batch_requests: true, // ë°°ì¹˜ ìš”ì²­ìœ¼ë¡œ íš¨ìœ¨ì„± ì¦ëŒ€
  cache_duration: "2 hours", // 2ì‹œê°„ ìºì‹±ìœ¼ë¡œ ì¤‘ë³µ ìš”ì²­ ë°©ì§€
  error_retry: 3, // ìµœëŒ€ 3íšŒ ì¬ì‹œë„
  fallback_enabled: true, // Bright Data ì‹¤íŒ¨ì‹œë§Œ ì‚¬ìš©
};
```

## ğŸ—ºï¸ ì§€ì—­ë³„ íŠ¸ë Œë“œ ë¶„ì„ ì‹œìŠ¤í…œ

### ì£¼ìš” 7ê°œ ë„ì‹œ ë¶„ì„

```javascript
// services/regional-trend-analyzer.js
export class RegionalTrendAnalyzer {
  static REGIONS = {
    ì„œìš¸: { code: "KR-SEO", lat: 37.5665, lng: 126.978 },
    ë¶€ì‚°: { code: "KR-PUS", lat: 35.1796, lng: 129.0756 },
    ëŒ€êµ¬: { code: "KR-TAE", lat: 35.8714, lng: 128.6014 },
    ì¸ì²œ: { code: "KR-INC", lat: 37.4563, lng: 126.7052 },
    ê´‘ì£¼: { code: "KR-KWA", lat: 35.1595, lng: 126.8526 },
    ëŒ€ì „: { code: "KR-TAE", lat: 36.3504, lng: 127.3845 },
    ì œì£¼: { code: "KR-CHE", lat: 33.4996, lng: 126.5312 },
  };

  async analyzeRegionalTrends() {
    const regionalData = {};
    const nationalTrends = await this._getNationalTrends();

    for (const [regionName, regionInfo] of Object.entries(this.REGIONS)) {
      // ì§€ì—­ë³„ íŠ¸ë Œë“œ ìˆ˜ì§‘
      const regionalTrends = await this._collectRegionalTrends(
        regionName,
        regionInfo
      );

      // ì „êµ­ ëŒ€ë¹„ ë¶„ì„
      const analysis = this._analyzeRegionalCharacteristics(
        regionalTrends,
        nationalTrends
      );

      regionalData[regionName] = {
        top_keywords: regionalTrends.slice(0, 10),
        rising_keywords: await this._getRisingKeywords(regionName),
        unique_trends: analysis.unique,
        similarity_score: analysis.similarity,
        geo_insights: await this._getGeoInsights(regionInfo),
      };
    }

    return regionalData;
  }

  // ì§€ì—­ íŠ¹ì„± ë¶„ì„
  _analyzeRegionalCharacteristics(regionalTrends, nationalTrends) {
    // ì§€ì—­ ê³ ìœ  íŠ¸ë Œë“œ ì¶”ì¶œ
    const uniqueTrends = regionalTrends.filter(
      (trend) => !nationalTrends.includes(trend)
    );

    // ìœ ì‚¬ë„ ê³„ì‚° (Jaccard ìœ ì‚¬ë„)
    const intersection = new Set(
      regionalTrends.filter((t) => nationalTrends.includes(t))
    );
    const union = new Set([...regionalTrends, ...nationalTrends]);
    const similarity = union.size > 0 ? intersection.size / union.size : 0;

    return {
      unique: uniqueTrends.slice(0, 5),
      similarity: Math.round(similarity * 100) / 100,
    };
  }
}
```

### ì§€ì—­ë³„ íŠ¹ì„± ì˜ˆì‹œ

```javascript
const regionalCharacteristics = {
  ì„œìš¸: {
    trends: ["ê°•ë‚¨ìŠ¤íƒ€ì¼", "K-POP", "í•œê°•", "í™ëŒ€"],
    characteristics: ["ë„ì‹œì ", "íŠ¸ë Œë””", "êµ­ì œì "],
    peak_hours: ["09:00-11:00", "18:00-22:00"],
  },
  ë¶€ì‚°: {
    trends: ["í•´ìš´ëŒ€", "ê°ì²œë¬¸í™”ë§ˆì„", "ë¶€ì‚°êµ­ì œì˜í™”ì œ"],
    characteristics: ["ê´€ê´‘", "ë°”ë‹¤", "ë¬¸í™”"],
    peak_hours: ["10:00-12:00", "19:00-21:00"],
  },
  ì œì£¼: {
    trends: ["ì œì£¼ì—¬í–‰", "ì˜¬ë ˆê¸¸", "ì„±ì‚°ì¼ì¶œë´‰", "í‘ë¼ì§€"],
    characteristics: ["ì—¬í–‰", "ìì—°", "íë§"],
    peak_hours: ["08:00-10:00", "20:00-22:00"],
  },
};
```

## ğŸ“Š ì¹´í…Œê³ ë¦¬ë³„ íŠ¸ë Œë“œ ë¶„ì„

### 10ê°œ ì£¼ìš” ì¹´í…Œê³ ë¦¬

```javascript
const categories = {
  'ìŒì•…': 'music',
  'ì—”í„°í…Œì¸ë¨¼íŠ¸': 'entertainment',
  'ìŠ¤í¬ì¸ ': 'sports',
  'ê²Œì„': 'gaming',
  'ìš”ë¦¬': 'food',
  'ë·°í‹°': 'beauty',
  'êµìœ¡': 'education',
  'ì½”ë¯¸ë””': 'comedy',
  'ì• ì™„ë™ë¬¼': 'pets',
  'ì—¬í–‰': 'travel'
};

async _getCategoryTrends() {
  const categoryTrends = {};

  for (const [categoryName, categoryKey] of Object.entries(categories)) {
    const result = await this.brightData.callTool('search_web_trends', {
      query: `youtube shorts ${categoryName} trending korea`,
      country: 'KR',
      language: 'ko',
      sources: ['youtube_trending', 'google_trends'],
      category: categoryKey
    });

    const trends = JSON.parse(result.content[0].text);
    categoryTrends[categoryName] = trends.keywords?.slice(0, 10) || [];

    // API ì œí•œ ê³ ë ¤ (500ms ë”œë ˆì´)
    await new Promise(resolve => setTimeout(resolve, 500));
  }

  return categoryTrends;
}
```

### ì¹´í…Œê³ ë¦¬ë³„ ì„±ê³¼ ì§€í‘œ

```javascript
const categoryMetrics = {
  ìŒì•…: { coverage: "95%", accuracy: "92%", update_frequency: "30min" },
  ê²Œì„: { coverage: "90%", accuracy: "88%", update_frequency: "1hour" },
  ìš”ë¦¬: { coverage: "85%", accuracy: "90%", update_frequency: "2hour" },
  ë·°í‹°: { coverage: "88%", accuracy: "85%", update_frequency: "1hour" },
  ì—¬í–‰: { coverage: "80%", accuracy: "83%", update_frequency: "4hour" },
};
```

## ğŸ—„ï¸ íŠ¸ë Œë“œ ë°ì´í„° êµ¬ì¡°

### ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ

```sql
-- trending_keywords: ê°œë³„ í‚¤ì›Œë“œ íŠ¸ë Œë“œ
CREATE TABLE trending_keywords (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  keyword varchar(255) NOT NULL,
  trend_score float NOT NULL,
  trend_type varchar(50), -- 'daily', 'realtime', 'rising'
  rank_position integer,
  category varchar(100),
  region varchar(100),
  source varchar(100),
  metadata jsonb,
  valid_until timestamptz,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);

-- trend_snapshots: ì‹œê°„ëŒ€ë³„ íŠ¸ë Œë“œ ìŠ¤ëƒ…ìƒ·
CREATE TABLE trend_snapshots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  snapshot_id varchar(255) UNIQUE NOT NULL,
  trends_data jsonb NOT NULL,
  collected_at timestamptz NOT NULL,
  region varchar(100),
  source varchar(100),
  created_at timestamptz DEFAULT now()
);

-- regional_trend_analysis: ì§€ì—­ë³„ ë¶„ì„ ê²°ê³¼
CREATE TABLE regional_trend_analysis (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  analysis_date date NOT NULL,
  region varchar(100) NOT NULL,
  data jsonb NOT NULL, -- ì§€ì—­ë³„ ìƒì„¸ ë¶„ì„ ë°ì´í„°
  created_at timestamptz DEFAULT now()
);
```

### íŠ¸ë Œë“œ ì ìˆ˜ ê³„ì‚° ì•Œê³ ë¦¬ì¦˜

```javascript
class TrendScoreCalculator {
  static calculateScore(trendData) {
    const factors = {
      searchVolume: trendData.search_volume || 0,
      growthRate: trendData.growth_rate || 0,
      socialMentions: trendData.social_mentions || 0,
      newsArticles: trendData.news_count || 0,
      timeDecay: this._getTimeDecayFactor(trendData.timestamp),
    };

    // ê°€ì¤‘ í‰ê·  ê³„ì‚°
    const weights = {
      searchVolume: 0.3,
      growthRate: 0.25,
      socialMentions: 0.2,
      newsArticles: 0.15,
      timeDecay: 0.1,
    };

    let score = 0;
    for (const [factor, value] of Object.entries(factors)) {
      score += value * weights[factor];
    }

    return Math.min(Math.max(score, 0), 100); // 0-100 ë²”ìœ„
  }

  static _getTimeDecayFactor(timestamp) {
    const hoursSince = (Date.now() - new Date(timestamp)) / (1000 * 60 * 60);
    return Math.max(1 - hoursSince / 24, 0.1); // 24ì‹œê°„ í›„ 10%ë¡œ ê°ì†Œ
  }
}
```

## âš¡ ìºì‹± ë° ì„±ëŠ¥ ìµœì í™”

### 3-ë ˆë²¨ íŠ¸ë Œë“œ ìºì‹±

```javascript
class TrendCacheManager {
  constructor() {
    this.cache = {
      L1: new Map(), // ë©”ëª¨ë¦¬ ìºì‹œ (5ë¶„)
      L2: new Map(), // Redis ìºì‹œ (1ì‹œê°„)
      L3: new Map(), // ë°ì´í„°ë² ì´ìŠ¤ ìºì‹œ (4ì‹œê°„)
    };

    this.ttl = {
      realtime: 5 * 60 * 1000, // 5ë¶„
      daily: 60 * 60 * 1000, // 1ì‹œê°„
      weekly: 4 * 60 * 60 * 1000, // 4ì‹œê°„
    };
  }

  async get(key, type = "daily") {
    // L1: ë©”ëª¨ë¦¬ ìºì‹œ
    const l1Data = this.cache.L1.get(key);
    if (l1Data && l1Data.expiry > Date.now()) {
      return { data: l1Data.value, source: "L1", cost: 0 };
    }

    // L2: Redis ìºì‹œ
    const l2Data = await this.redis.get(`trends:${key}`);
    if (l2Data) {
      this.cache.L1.set(key, {
        value: JSON.parse(l2Data),
        expiry: Date.now() + this.ttl.realtime,
      });
      return { data: JSON.parse(l2Data), source: "L2", cost: 0 };
    }

    // L3: ë°ì´í„°ë² ì´ìŠ¤ ìºì‹œ
    const l3Data = await this.getTrendsFromDB(key);
    if (l3Data) {
      return { data: l3Data, source: "L3", cost: 0 };
    }

    // ìºì‹œ ë¯¸ìŠ¤ - API í˜¸ì¶œ í•„ìš”
    return { data: null, source: "API", cost: 1 };
  }

  async set(key, data, type = "daily") {
    const ttl = this.ttl[type];

    // L1 ì €ì¥
    this.cache.L1.set(key, {
      value: data,
      expiry: Date.now() + ttl,
    });

    // L2 ì €ì¥ (Redis)
    await this.redis.setex(`trends:${key}`, ttl / 1000, JSON.stringify(data));

    // L3 ì €ì¥ (Database)
    await this.saveTrendsToDatabase(key, data, ttl);
  }
}
```

### ì„±ëŠ¥ ìµœì í™” ì§€í‘œ

- **ìºì‹œ ì ì¤‘ë¥ **: 80% ëª©í‘œ
- **L1 ë©”ëª¨ë¦¬**: 90% ì ì¤‘ë¥  (ì¦‰ì‹œ ì‘ë‹µ)
- **L2 Redis**: 85% ì ì¤‘ë¥  (< 10ms)
- **L3 Database**: 75% ì ì¤‘ë¥  (< 100ms)
- **í‰ê·  ì‘ë‹µ ì‹œê°„**: 50ms

## ğŸ¤– ìë™í™” ì›Œí¬í”Œë¡œìš° (n8n ì¤€ë¹„)

### ì›¹í›… ì—”ë“œí¬ì¸íŠ¸ ì„¤ì •

```javascript
// routes/trend-webhooks.js
export class TrendWebhookHandler {
  static endpoints = {
    collect: "/webhooks/trends/collect",
    analyze: "/webhooks/trends/analyze",
    report: "/webhooks/trends/report",
  };

  // íŠ¸ë Œë“œ ìˆ˜ì§‘ ì›¹í›…
  static async handleCollectWebhook(req, res) {
    const { source, region, category } = req.body;

    try {
      const collector = new BrightDataTrendCollector();
      const trends = await collector.collectRealtimeTrends();

      // n8nìœ¼ë¡œ ê²°ê³¼ ì „ì†¡
      await fetch(process.env.N8N_TREND_WORKFLOW_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          workflow_id: process.env.N8N_TREND_WORKFLOW_ID,
          data: trends,
          timestamp: new Date().toISOString(),
        }),
      });

      res.json({ success: true, trends_count: trends.length });
    } catch (error) {
      res.status(500).json({ error: error.message });
    }
  }

  // íŠ¸ë Œë“œ ë¶„ì„ ì›¹í›…
  static async handleAnalyzeWebhook(req, res) {
    const analyzer = new RegionalTrendAnalyzer();
    const analysis = await analyzer.analyzeRegionalTrends();

    res.json({ success: true, analysis });
  }
}
```

### n8n ì›Œí¬í”Œë¡œìš° ì˜ˆì‹œ

```json
{
  "workflows": [
    {
      "name": "daily_trend_collection",
      "schedule": "0 */4 * * *",
      "steps": [
        {
          "node": "HTTP Request",
          "url": "{{$env.API_BASE_URL}}/webhooks/trends/collect",
          "method": "POST"
        },
        {
          "node": "Function",
          "code": "// íŠ¸ë Œë“œ ë°ì´í„° ê°€ê³µ"
        },
        {
          "node": "Supabase",
          "operation": "insert",
          "table": "trend_snapshots"
        }
      ]
    },
    {
      "name": "regional_analysis",
      "schedule": "0 2 * * *",
      "steps": [
        {
          "node": "HTTP Request",
          "url": "{{$env.API_BASE_URL}}/webhooks/trends/analyze"
        },
        {
          "node": "Email",
          "to": "admin@shortscurator.com",
          "subject": "ì¼ì¼ ì§€ì—­ë³„ íŠ¸ë Œë“œ ë¶„ì„ ë¦¬í¬íŠ¸"
        }
      ]
    }
  ]
}
```

## ğŸ“ˆ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§

### íŠ¸ë Œë“œ í’ˆì§ˆ ì§€í‘œ

```javascript
class TrendQualityMonitor {
  static metrics = {
    freshness: {
      realtime: "< 5min",
      daily: "< 1hour",
      threshold: 0.9,
    },
    accuracy: {
      prediction: "> 85%",
      regional: "> 75%",
      category: "> 80%",
    },
    coverage: {
      keywords: "> 500/day",
      categories: "10/10",
      regions: "7/7",
    },
  };

  static async checkQuality() {
    const report = {
      timestamp: new Date().toISOString(),
      metrics: {},
      alerts: [],
    };

    // ì‹ ì„ ë„ ì²´í¬
    const freshnessScore = await this._checkFreshness();
    if (freshnessScore < 0.9) {
      report.alerts.push({
        level: "warning",
        message: `íŠ¸ë Œë“œ ì‹ ì„ ë„ ì €í•˜: ${freshnessScore * 100}%`,
      });
    }

    // ì •í™•ë„ ì²´í¬
    const accuracyScore = await this._checkAccuracy();
    if (accuracyScore < 0.85) {
      report.alerts.push({
        level: "critical",
        message: `íŠ¸ë Œë“œ ì •í™•ë„ ì €í•˜: ${accuracyScore * 100}%`,
      });
    }

    return report;
  }
}
```

## ğŸ¯ í•µì‹¬ ì²´í¬ë¦¬ìŠ¤íŠ¸

### í•„ìˆ˜ êµ¬í˜„ ì‚¬í•­

- [ ] **Bright Data MCP ì—°ë™**: ì‹¤ì‹œê°„ ì›¹ íŠ¸ë Œë“œ ìˆ˜ì§‘
- [ ] **ì§€ì—­ë³„ ë¶„ì„**: 7ê°œ ì£¼ìš” ë„ì‹œ íŠ¸ë Œë“œ ë¶„ì„
- [ ] **ì¹´í…Œê³ ë¦¬ë³„ ìˆ˜ì§‘**: 10ê°œ ë¶„ì•¼ íŠ¸ë Œë“œ ì¶”ì 
- [ ] **3-ë ˆë²¨ ìºì‹±**: ë©”ëª¨ë¦¬â†’Redisâ†’Database ìºì‹±
- [ ] **ìë™í™” ì›Œí¬í”Œë¡œìš°**: n8n ì›¹í›… ì—°ë™

### ë°ì´í„° í’ˆì§ˆ ê´€ë¦¬

- [ ] **íŠ¸ë Œë“œ ìŠ¤ì½”ì–´ë§**: 5ê°€ì§€ ìš”ì¸ ê°€ì¤‘ í‰ê· 
- [ ] **ì¤‘ë³µ ì œê±°**: í‚¤ì›Œë“œ ì •ê·œí™” ë° ì¤‘ë³µ ì œê±°
- [ ] **ì‹œê°„ ê°ì‡ **: 24ì‹œê°„ ê¸°ì¤€ ì ìˆ˜ ê°ì†Œ
- [ ] **ì§€ì—­ íŠ¹ì„±**: ì „êµ­ ëŒ€ë¹„ ì§€ì—­ ê³ ìœ ì„± ë¶„ì„

### ì„±ëŠ¥ ì§€í‘œ

- [ ] **ìˆ˜ì§‘ ì†ë„**: ì‹¤ì‹œê°„ 5ë¶„, ì¼ì¼ 1ì‹œê°„ ì—…ë°ì´íŠ¸
- [ ] **ìºì‹œ ì ì¤‘ë¥ **: > 80%
- [ ] **ì •í™•ë„**: > 85% (ì˜ˆì¸¡ ì •í™•ë„)
- [ ] **API íš¨ìœ¨ì„±**: ìµœì†Œ í˜¸ì¶œë¡œ ìµœëŒ€ ë°ì´í„° ìˆ˜ì§‘
- [ ] **ì‹œìŠ¤í…œ ì•ˆì •ì„±**: 99.5% ì—…íƒ€ì„ ëª©í‘œ

### ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ

- [ ] **ì‹¤ì‹œê°„ íŠ¸ë Œë“œ**: ê¸‰ìƒìŠ¹ í‚¤ì›Œë“œ ëª¨ë‹ˆí„°ë§
- [ ] **ì§€ì—­ë³„ í˜„í™©**: 7ê°œ ë„ì‹œë³„ íŠ¸ë Œë“œ í˜„í™©
- [ ] **ì¹´í…Œê³ ë¦¬ ë¶„ì„**: ë¶„ì•¼ë³„ íŠ¸ë Œë“œ ê°•ë„
- [ ] **ì˜ˆì¸¡ ì •í™•ë„**: ì‹¤ì œ vs ì˜ˆì¸¡ ë¹„êµ
- [ ] **ì‹œìŠ¤í…œ í—¬ìŠ¤**: API ìƒíƒœ, ìºì‹œ ì„±ëŠ¥
