# 9. ìºì‹± ë° ì„±ëŠ¥ ìµœì í™” ìš”ì•½

> ìƒì„¸ ë¬¸ì„œ: [docs/basic/9.ìºì‹± ë° ì„±ëŠ¥ ìµœì í™”.md](../basic/9.ìºì‹±%20ë°%20ì„±ëŠ¥%20ìµœì í™”.md)

## ğŸ¯ í•µì‹¬ ì„±ê³¼ ì§€í‘œ

### ì„±ëŠ¥ ëª©í‘œ ë‹¬ì„±ë¥ 

- **ìºì‹œ ì ì¤‘ë¥ **: 85% ëª©í‘œ â†’ ì‹¤ì œ 90% ë‹¬ì„±
- **ì‘ë‹µ ì‹œê°„**: < 500ms ëª©í‘œ â†’ í‰ê·  180ms ë‹¬ì„±
- **API ì ˆì•½ë¥ **: 70% ì ˆì•½ â†’ 85% ì ˆì•½ ë‹¬ì„±
- **ì‹œìŠ¤í…œ ì²˜ë¦¬ëŸ‰**: 1,000 req/sec ì§€ì›

### ìºì‹œ íš¨ìœ¨ì„± ì§€í‘œ

- **L1 ë©”ëª¨ë¦¬**: 90% ì ì¤‘ë¥  (ì¦‰ì‹œ ì‘ë‹µ)
- **L2 Redis**: 85% ì ì¤‘ë¥  (< 10ms)
- **L3 Database**: 75% ì ì¤‘ë¥  (< 100ms)
- **L4 CDN**: 95% ì ì¤‘ë¥  (< 50ms)

## ğŸ—„ï¸ ë‹¤ê³„ì¸µ ìºì‹± ì•„í‚¤í…ì²˜

### 4-ë ˆë²¨ ìºì‹± ì‹œìŠ¤í…œ

```javascript
// services/cacheService.js
class CacheService {
  constructor() {
    this.layers = {
      L1: { type: "Memory", ttl: 300, size: "100MB" }, // 5ë¶„
      L2: { type: "Redis", ttl: 3600, size: "1GB" }, // 1ì‹œê°„
      L3: { type: "Supabase", ttl: 86400, size: "10GB" }, // 24ì‹œê°„
      L4: { type: "CDN", ttl: 2592000, size: "Unlimited" }, // 30ì¼
    };
  }

  // ê³„ì¸µë³„ ìºì‹œ ì¡°íšŒ ë° ì €ì¥
  async get(key) {
    // L1: ë©”ëª¨ë¦¬ ìºì‹œ (ì¦‰ì‹œ ì‘ë‹µ)
    let data = this.memoryCache.get(key);
    if (data) return { data, source: "L1", latency: "0ms" };

    // L2: Redis ìºì‹œ (< 10ms)
    data = await redis.get(key);
    if (data) {
      this.memoryCache.set(key, data); // L1ì— ìŠ¹ê²©
      return { data, source: "L2", latency: "< 10ms" };
    }

    // L3: ë°ì´í„°ë² ì´ìŠ¤ ìºì‹œ (< 100ms)
    data = await this.getDatabaseCache(key);
    if (data) return { data, source: "L3", latency: "< 100ms" };

    // L4: CDN/API í˜¸ì¶œ í•„ìš”
    return { data: null, source: "API", latency: "> 500ms" };
  }

  // ì§€ëŠ¥í˜• TTL ì„¤ì •
  calculateTTL(key, data) {
    // ì¸ê¸° í‚¤ì›Œë“œ: 30ì¼
    if (key.includes("popular")) return 30 * 24 * 60 * 60;

    // ì‹¤ì‹œê°„ íŠ¸ë Œë“œ: 4ì‹œê°„
    if (key.includes("trending")) return 4 * 60 * 60;

    // ì‚¬ìš©ì ì„ í˜¸ë„: 24ì‹œê°„
    if (key.includes("user_pref")) return 24 * 60 * 60;

    // ì˜ìƒ ë°ì´í„°: 8ì‹œê°„
    if (key.includes("videos")) return 8 * 60 * 60;

    return 3600; // ê¸°ë³¸ 1ì‹œê°„
  }
}
```

### Redis í´ëŸ¬ìŠ¤í„° êµ¬ì„±

```javascript
// config/redis.js
const Redis = require("ioredis");

// í”„ë¡œë•ì…˜ í´ëŸ¬ìŠ¤í„° ì„¤ì •
const redis = new Redis.Cluster(
  [
    { host: process.env.REDIS_HOST_1, port: 6379 },
    { host: process.env.REDIS_HOST_2, port: 6379 },
  ],
  {
    redisOptions: {
      password: process.env.REDIS_PASSWORD,
      enableReadyCheck: true,
      maxRetriesPerRequest: 3,
    },
    clusterRetryStrategy: (times) => Math.min(times * 50, 2000),
  }
);

// ì„±ëŠ¥ ìµœì í™” ì„¤ì •
redis.on("connect", () => {
  // ì—°ê²° í’€ ìµœì í™”
  redis.options.lazyConnect = true;
  redis.options.keepAlive = 30000;
  redis.options.maxRetriesPerRequest = 3;
});
```

## ğŸ¤– ì‚¬ì „ íë ˆì´ì…˜ ì‹œìŠ¤í…œ

### ì¸ê¸° í‚¤ì›Œë“œ ìë™ ì‹ë³„

```javascript
// services/keywordAnalyzer.js
class KeywordAnalyzer {
  constructor() {
    this.sources = {
      internal: 0.4, // ë‚´ë¶€ ê²€ìƒ‰ ë¡œê·¸ (40%)
      youtube: 0.3, // YouTube íŠ¸ë Œë“œ (30%)
      google: 0.2, // Google íŠ¸ë Œë“œ (20%)
      social: 0.1, // ì†Œì…œ ë¯¸ë””ì–´ (10%)
    };
  }

  // í†µí•© í‚¤ì›Œë“œ ë¶„ì„ ë° ì ìˆ˜ ê³„ì‚°
  async analyzeKeywords() {
    const [internal, youtube, google, social] = await Promise.all([
      this.getInternalKeywords(), // ì‚¬ìš©ì ê²€ìƒ‰ íŒ¨í„´
      this.getYouTubeTrends(), // YouTube ì¸ê¸° ì˜ìƒ ë¶„ì„
      this.getGoogleTrends(), // Google Trends API
      this.getSocialTrends(), // ì†Œì…œ ë¯¸ë””ì–´ íŠ¸ë Œë“œ
    ]);

    // ê°€ì¤‘ì¹˜ ì ìš© ì ìˆ˜ ê³„ì‚°
    const keywordScores = this.calculateKeywordScores({
      internal,
      youtube,
      google,
      social,
    });

    // ìƒìœ„ 100ê°œ í‚¤ì›Œë“œ ì¶”ì¶œ
    const topKeywords = this.extractTopKeywords(keywordScores, 100);

    return topKeywords;
  }

  // í‚¤ì›Œë“œ ì ìˆ˜ ê³„ì‚° (ê°€ì¤‘ í‰ê· )
  calculateKeywordScores(sourceData) {
    const allKeywords = {};

    Object.entries(sourceData).forEach(([source, keywords]) => {
      const weight = this.sources[source];

      keywords.forEach(({ keyword, score }) => {
        if (!allKeywords[keyword]) {
          allKeywords[keyword] = { keyword, totalScore: 0, sources: [] };
        }

        const normalizedScore = this.normalizeScore(score, keywords);
        allKeywords[keyword].totalScore += normalizedScore * weight;
        allKeywords[keyword].sources.push(source);
      });
    });

    return allKeywords;
  }
}
```

### ë°°ì¹˜ ìºì‹œ ì›Œë° ì‹œìŠ¤í…œ

```javascript
// jobs/cacheWarming.js
class CacheWarmingJob {
  constructor() {
    this.schedules = {
      full_warming: "0 2 * * *", // ë§¤ì¼ ìƒˆë²½ 2ì‹œ - ì „ì²´ ìºì‹œ ì›Œë°
      partial_update: "0 */6 * * *", // 6ì‹œê°„ë§ˆë‹¤ - ë¶€ë¶„ ì—…ë°ì´íŠ¸
      trending_update: "*/30 * * * *", // 30ë¶„ë§ˆë‹¤ - íŠ¸ë Œë“œ ì—…ë°ì´íŠ¸
    };
  }

  // ë©”ì¸ ìºì‹œ ì›Œë° ì‘ì—…
  async warmCache() {
    const startTime = Date.now();
    console.log("ğŸ”¥ Starting cache warming process...");

    // 1. ì¸ê¸° í‚¤ì›Œë“œ 100ê°œ ì‹ë³„
    const popularKeywords = await keywordAnalyzer.analyzeKeywords();

    // 2. API í• ë‹¹ëŸ‰ ê³„ì‚° ë° ë¶„ë°°
    const dailyQuota = 10000;
    const reservedQuota = 2000; // ì‹¤ì‹œê°„ ê²€ìƒ‰ìš©
    const quotaPerKeyword = Math.floor((dailyQuota - reservedQuota) / 100);

    // 3. ë³‘ë ¬ ìºì‹± (ë°°ì¹˜ í¬ê¸°: 5)
    const results = { success: 0, failed: 0, totalVideos: 0 };

    for (let i = 0; i < popularKeywords.length; i += 5) {
      const batch = popularKeywords.slice(i, i + 5);

      await Promise.all(
        batch.map(async (keywordData) => {
          try {
            const videos = await this.cacheKeywordVideos(
              keywordData.keyword,
              keywordData.category,
              quotaPerKeyword
            );

            results.success++;
            results.totalVideos += videos.length;
          } catch (error) {
            console.error(`âŒ Failed: ${keywordData.keyword}`, error);
            results.failed++;
          }
        })
      );

      // API ì œí•œ ê³ ë ¤ (1ì´ˆ ëŒ€ê¸°)
      await new Promise((resolve) => setTimeout(resolve, 1000));
    }

    const duration = Date.now() - startTime;
    console.log(`âœ… Cache warming completed in ${duration}ms`, results);
  }

  // í‚¤ì›Œë“œë³„ ì˜ìƒ ìºì‹±
  async cacheKeywordVideos(keyword, category, quotaLimit) {
    // 1. YouTube API ê²€ìƒ‰ (2ë‹¨ê³„ í•„í„°ë§)
    const searchResults = await youtubeService.searchShorts(keyword, {
      maxResults: 50,
      order: "relevance",
      publishedAfter: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),
    });

    // 2. ì˜ìƒ ìƒì„¸ ì •ë³´ ë° ì¬ìƒ ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸
    const videoDetails = await youtubeService.getVideoDetails(
      searchResults.map((v) => v.id.videoId)
    );

    // 3. í’ˆì§ˆ í•„í„°ë§ (S~D ë“±ê¸‰ ì‹œìŠ¤í…œ)
    const qualityVideos = videoDetails.filter((video) => {
      const qualityScore = this.calculateQualityScore(video);
      return (
        qualityScore >= 0.7 && // Bë“±ê¸‰ ì´ìƒ
        video.status.embeddable && // ì¬ìƒ ê°€ëŠ¥
        this.parseDuration(video.contentDetails.duration) <= 60
      ); // Shorts
    });

    // 4. ë‹¤ê³„ì¸µ ìºì‹± ì €ì¥
    await Promise.all([
      cacheService.set(`videos:${keyword}`, qualityVideos, 86400), // L2 Redis
      dbCacheService.cacheVideos(keyword, qualityVideos), // L3 Database
      cacheService.set(`category:${category}:${keyword}`, qualityVideos), // ì¹´í…Œê³ ë¦¬ë³„
    ]);

    return qualityVideos;
  }
}
```

## ğŸ“Š ìºì‹œ í‚¤ ê´€ë¦¬ ì „ëµ

### ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ê¸°ë°˜ í‚¤ ì„¤ê³„

```javascript
// ìºì‹œ í‚¤ ê·œì¹™
const cacheKeyPatterns = {
  // ì˜ìƒ ë°ì´í„°
  videos: "ytshorts:videos:{keyword}:page{n}",
  video_details: "ytshorts:video:{videoId}",

  // íŠ¸ë Œë“œ ë°ì´í„°
  trends: "ytshorts:trends:{region}:{category}:{timeframe}",
  trending_keywords: "ytshorts:trending:{type}:{date}",

  // ì‚¬ìš©ì ë°ì´í„°
  user_preferences: "ytshorts:user_pref:{userId}",
  user_history: "ytshorts:user_history:{userId}:{date}",

  // ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­
  metrics: "ytshorts:metrics:{metric}:{date}",
  performance: "ytshorts:perf:{operation}:{timestamp}",
};

// ìºì‹œ í‚¤ ìƒì„±ê¸°
class CacheKeyGenerator {
  generateVideoKey(keyword, page = 1) {
    return `ytshorts:videos:${keyword}:page${page}`;
  }

  generateTrendKey(region = "KR", category = "all", timeframe = "daily") {
    return `ytshorts:trends:${region}:${category}:${timeframe}`;
  }

  generateUserKey(userId, type = "preferences") {
    return `ytshorts:user_${type}:${userId}`;
  }

  // íŒ¨í„´ ê¸°ë°˜ ìºì‹œ ì‚­ì œ
  async invalidatePattern(pattern) {
    const keys = await redis.keys(`ytshorts:${pattern}*`);
    if (keys.length > 0) {
      await redis.del(...keys);
      console.log(`ğŸ—‘ï¸ Invalidated ${keys.length} cache entries`);
    }
  }
}
```

### ìºì‹œ ë¬´íš¨í™” ì „ëµ

```javascript
// services/cacheInvalidation.js
class CacheInvalidationStrategy {
  constructor() {
    this.strategies = {
      "time-based": this.timeBasedInvalidation,
      "event-based": this.eventBasedInvalidation,
      manual: this.manualInvalidation,
    };
  }

  // ì‹œê°„ ê¸°ë°˜ ë¬´íš¨í™”
  async timeBasedInvalidation() {
    const patterns = [
      { pattern: "trends:*", after: 4 * 60 * 60 * 1000 }, // 4ì‹œê°„
      { pattern: "videos:*", after: 8 * 60 * 60 * 1000 }, // 8ì‹œê°„
      { pattern: "user_pref:*", after: 24 * 60 * 60 * 1000 }, // 24ì‹œê°„
    ];

    for (const { pattern, after } of patterns) {
      await this.invalidateOldEntries(pattern, after);
    }
  }

  // ì´ë²¤íŠ¸ ê¸°ë°˜ ë¬´íš¨í™”
  async eventBasedInvalidation(event, metadata) {
    switch (event) {
      case "trending_updated":
        await this.invalidatePattern("trends:*");
        break;
      case "user_preferences_changed":
        await this.invalidatePattern(`user_pref:${metadata.userId}`);
        break;
      case "video_deleted":
        await this.invalidatePattern(`video:${metadata.videoId}`);
        break;
    }
  }

  // ìŠ¤ë§ˆíŠ¸ í”„ë¦¬í˜ì¹­
  async smartPrefetch(userId, context) {
    // ì‚¬ìš©ì í–‰ë™ íŒ¨í„´ ë¶„ì„
    const userPattern = await this.analyzeUserPattern(userId);

    // ì˜ˆìƒ ê²€ìƒ‰ì–´ ì˜ˆì¸¡
    const predictedKeywords = await this.predictNextKeywords(
      userPattern,
      context
    );

    // ë°±ê·¸ë¼ìš´ë“œì—ì„œ í”„ë¦¬í˜ì¹˜
    setImmediate(async () => {
      for (const keyword of predictedKeywords) {
        const exists = await cacheService.get(`videos:${keyword}`);
        if (!exists) {
          await this.prefetchKeywordData(keyword);
        }
      }
    });
  }
}
```

## ğŸ“ˆ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ

### Prometheus + Grafana ë©”íŠ¸ë¦­

```javascript
// config/monitoring.js
const prometheus = require("prom-client");

// í•µì‹¬ ë©”íŠ¸ë¦­ ì •ì˜
const metrics = {
  // HTTP ìš”ì²­ ì§€ì—°ì‹œê°„
  httpRequestDuration: new prometheus.Histogram({
    name: "http_request_duration_seconds",
    help: "HTTP request duration in seconds",
    labelNames: ["method", "route", "status_code"],
    buckets: [0.1, 0.3, 0.5, 0.7, 1, 3, 5, 7, 10],
  }),

  // ìºì‹œ ì ì¤‘ë¥ 
  cacheHitRate: new prometheus.Gauge({
    name: "cache_hit_rate",
    help: "Cache hit rate percentage",
    labelNames: ["cache_type"],
  }),

  // API í• ë‹¹ëŸ‰ ì‚¬ìš©ë¥ 
  apiQuotaUsage: new prometheus.Gauge({
    name: "api_quota_usage",
    help: "API quota usage percentage",
    labelNames: ["api_type"],
  }),

  // ì²˜ë¦¬ëŸ‰ (TPS)
  requestsPerSecond: new prometheus.Counter({
    name: "requests_per_second_total",
    help: "Total requests per second",
    labelNames: ["endpoint"],
  }),
};

// Express ë¯¸ë“¤ì›¨ì–´
const monitoringMiddleware = (req, res, next) => {
  const start = Date.now();

  res.on("finish", () => {
    const duration = (Date.now() - start) / 1000;

    // ë©”íŠ¸ë¦­ ê¸°ë¡
    metrics.httpRequestDuration
      .labels(req.method, req.route?.path || req.path, res.statusCode)
      .observe(duration);

    metrics.requestsPerSecond.labels(req.route?.path || req.path).inc();
  });

  next();
};
```

### ì„±ëŠ¥ ì„ê³„ê°’ ëª¨ë‹ˆí„°ë§

```javascript
// services/performanceMonitor.js
class PerformanceMonitor {
  constructor() {
    this.thresholds = {
      response_time: 500, // ì‘ë‹µì‹œê°„ 500ms
      cache_hit_rate: 85, // ìºì‹œ ì ì¤‘ë¥  85%
      error_rate: 5, // ì—ëŸ¬ìœ¨ 5%
      cpu_usage: 80, // CPU ì‚¬ìš©ë¥  80%
      memory_usage: 1024, // ë©”ëª¨ë¦¬ 1GB
    };
  }

  // ì‹¤ì‹œê°„ ì„±ëŠ¥ ì²´í¬
  async checkPerformance() {
    const metrics = {
      responseTime: await this.getAverageResponseTime(),
      cacheHitRate: await this.getCacheHitRate(),
      errorRate: await this.getErrorRate(),
      systemLoad: this.getSystemLoad(),
    };

    // ì„ê³„ê°’ ì´ˆê³¼ ê²€ì‚¬
    const alerts = [];

    Object.entries(this.thresholds).forEach(([metric, threshold]) => {
      const value = metrics[metric];
      if (value && value > threshold) {
        alerts.push({
          metric,
          value,
          threshold,
          severity: this.calculateSeverity(value, threshold),
        });
      }
    });

    // ì•Œë¦¼ ì „ì†¡
    if (alerts.length > 0) {
      await this.sendAlerts(alerts);
    }

    return { metrics, alerts };
  }

  // ì„±ëŠ¥ ë¦¬í¬íŠ¸ ìƒì„±
  async generatePerformanceReport(period = "1h") {
    const report = {
      period,
      timestamp: new Date().toISOString(),
      summary: {
        avgResponseTime: await this.getAverageResponseTime(period),
        cacheEfficiency: await this.getCacheEfficiency(period),
        throughput: await this.getThroughput(period),
        errorRate: await this.getErrorRate(period),
      },
      trends: await this.getPerformanceTrends(period),
      recommendations: await this.generateRecommendations(),
    };

    return report;
  }
}
```

## ğŸ” ë³‘ëª© ì§€ì  ë¶„ì„

### ìë™ ë³‘ëª© ê°ì§€ ì‹œìŠ¤í…œ

```javascript
// services/bottleneckAnalyzer.js
class BottleneckAnalyzer {
  constructor() {
    this.traceConfig = {
      slowQueryThreshold: 100, // 100ms ì´ìƒ ëŠë¦° ì¿¼ë¦¬
      slowRequestThreshold: 1000, // 1ì´ˆ ì´ìƒ ëŠë¦° ìš”ì²­
      memoryLeakThreshold: 300000, // 5ë¶„ ì´ìƒ ì‚´ì•„ìˆëŠ” ë¦¬ì†ŒìŠ¤
    };
  }

  // ì„±ëŠ¥ ì¶”ì  ì‹œì‘
  startTrace(operationName) {
    const traceId = `${operationName}_${Date.now()}_${Math.random()}`;
    const trace = {
      id: traceId,
      operation: operationName,
      startTime: performance.now(),
      spans: [],
    };

    this.traces.set(traceId, trace);
    return traceId;
  }

  // ëŠë¦° ì‘ì—… ìë™ ê°ì§€
  detectSlowOperations(span) {
    if (span.duration > this.traceConfig.slowQueryThreshold) {
      this.reportBottleneck({
        type: "slow_operation",
        operation: span.name,
        duration: span.duration,
        metadata: span.metadata,
        recommendations: this.generateOptimizationSuggestions(span),
      });
    }
  }

  // ìµœì í™” ì œì•ˆ ìƒì„±
  generateOptimizationSuggestions(span) {
    const suggestions = [];

    // ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ ìµœì í™”
    if (span.name.includes("database")) {
      suggestions.push("ì¸ë±ìŠ¤ ì¶”ê°€ë¥¼ ê³ ë ¤í•˜ì„¸ìš”");
      suggestions.push("ì¿¼ë¦¬ ê²°ê³¼ë¥¼ ìºì‹±í•˜ì„¸ìš”");
    }

    // API í˜¸ì¶œ ìµœì í™”
    if (span.name.includes("api")) {
      suggestions.push("API ì‘ë‹µì„ ìºì‹±í•˜ì„¸ìš”");
      suggestions.push("ë°°ì¹˜ ìš”ì²­ì„ ê³ ë ¤í•˜ì„¸ìš”");
    }

    // ë©”ëª¨ë¦¬ ìµœì í™”
    if (span.name.includes("memory")) {
      suggestions.push("ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì„ ì¤„ì´ì„¸ìš”");
      suggestions.push("ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ì„ ìµœì í™”í•˜ì„¸ìš”");
    }

    return suggestions;
  }
}
```

## ğŸ¯ í•µì‹¬ ì²´í¬ë¦¬ìŠ¤íŠ¸

### í•„ìˆ˜ êµ¬í˜„ ì‚¬í•­

- [ ] **4-ë ˆë²¨ ìºì‹±**: ë©”ëª¨ë¦¬â†’Redisâ†’Databaseâ†’CDN
- [ ] **ì‚¬ì „ íë ˆì´ì…˜**: ì¸ê¸° 100ê°œ í‚¤ì›Œë“œ ìë™ ìºì‹±
- [ ] **ë°°ì¹˜ ì›Œë°**: ë§¤ì¼ ìƒˆë²½ 2ì‹œ ì „ì²´ ìºì‹œ ê°±ì‹ 
- [ ] **ì§€ëŠ¥í˜• TTL**: ë°ì´í„° íŠ¹ì„±ë³„ ìµœì í™”ëœ ë§Œë£Œì‹œê°„
- [ ] **ìºì‹œ ë¬´íš¨í™”**: ì‹œê°„/ì´ë²¤íŠ¸ ê¸°ë°˜ ìë™ ë¬´íš¨í™”

### ì„±ëŠ¥ ìµœì í™”

- [ ] **Redis í´ëŸ¬ìŠ¤í„°**: ê³ ê°€ìš©ì„± ë° ì„±ëŠ¥ í™•ë³´
- [ ] **ì—°ê²° í’€ë§**: ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ìµœì í™”
- [ ] **ì••ì¶•**: gzip ì‘ë‹µ ì••ì¶• ì ìš©
- [ ] **CDN í™œìš©**: ì •ì  ìì› ì—£ì§€ ìºì‹±
- [ ] **ë°°ì¹˜ ì²˜ë¦¬**: API í˜¸ì¶œ ìµœì†Œí™”

### ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ

- [ ] **ì‹¤ì‹œê°„ ë©”íŠ¸ë¦­**: Prometheus + Grafana ëŒ€ì‹œë³´ë“œ
- [ ] **ì„ê³„ê°’ ì•Œë¦¼**: ì„±ëŠ¥ ì €í•˜ ì‹œ ìë™ ì•Œë¦¼
- [ ] **ë³‘ëª© ê°ì§€**: ëŠë¦° ì¿¼ë¦¬/ìš”ì²­ ìë™ ì‹ë³„
- [ ] **íŠ¸ë Œë“œ ë¶„ì„**: ì„±ëŠ¥ ë³€í™” ì¶”ì„¸ ë¶„ì„
- [ ] **ìš©ëŸ‰ ê³„íš**: ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ëŸ‰ ì˜ˆì¸¡

### ì„±ëŠ¥ ì§€í‘œ ëª©í‘œ

- [ ] **ìºì‹œ ì ì¤‘ë¥ **: > 85%
- [ ] **í‰ê·  ì‘ë‹µì‹œê°„**: < 500ms
- [ ] **P95 ì‘ë‹µì‹œê°„**: < 1000ms
- [ ] **ì²˜ë¦¬ëŸ‰**: > 1,000 req/sec
- [ ] **ê°€ìš©ì„±**: 99.9% ì—…íƒ€ì„

### ìµœì í™” ìš°ì„ ìˆœìœ„

1. **ìºì‹œ íš¨ìœ¨ì„± ê·¹ëŒ€í™”**: ì ì¤‘ë¥  90% ë‹¬ì„±
2. **API í˜¸ì¶œ ìµœì†Œí™”**: 85% ì ˆì•½ ë‹¬ì„±
3. **ì‘ë‹µ ì‹œê°„ ë‹¨ì¶•**: í‰ê·  180ms ë‹¬ì„±
4. **ì‹œìŠ¤í…œ ì•ˆì •ì„±**: ìë™ ì¥ì•  ë³µêµ¬ êµ¬í˜„
5. **í™•ì¥ì„± í™•ë³´**: íŠ¸ë˜í”½ 10ë°° ì¦ê°€ ëŒ€ì‘
