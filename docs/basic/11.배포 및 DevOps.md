# 배포 및 DevOps (Deployment & DevOps)

## 11.1 Railway 배포 설정

### 11.1.1 프로젝트 설정

### Railway 프로젝트 초기화

```bash
# Railway CLI 설치
npm install -g @railway/cli

# Railway 로그인
railway login

# 새 프로젝트 생성
railway init youtube-shorts-curator

# 환경 설정
railway link

```

### Railway 설정 파일 (railway.json)

```json
{
  "$schema": "https://railway.app/railway.schema.json",
  "build": {
    "builder": "NIXPACKS",
    "buildCommand": "npm ci && npm run build",
    "watchPatterns": [
      "backend/**",
      "frontend/**"
    ]
  },
  "deploy": {
    "numReplicas": 2,
    "startCommand": "npm run start:prod",
    "healthcheckPath": "/health",
    "healthcheckTimeout": 30,
    "restartPolicyType": "ON_FAILURE",
    "restartPolicyMaxRetries": 3
  },
  "environments": {
    "production": {
      "build": {
        "NODE_ENV": "production"
      }
    },
    "staging": {
      "build": {
        "NODE_ENV": "staging"
      }
    }
  }
}

```

### 멀티 서비스 구성

```yaml
# railway.yml - 서비스 정의
version: 1

services:
  # 백엔드 API 서버
  backend:
    source:
      repo: .
      branch: main
      dir: backend
    build:
      builder: NIXPACKS
      buildCommand: npm ci && npm run build
    deploy:
      startCommand: npm run start
      numReplicas: 2
      region: us-west1
      healthcheckPath: /api/health
      env:
        - NODE_ENV=production
        - PORT=${{RAILWAY_PORT}}

  # 프론트엔드 정적 파일 서버
  frontend:
    source:
      repo: .
      branch: main
      dir: frontend
    build:
      builder: NIXPACKS
      buildCommand: npm ci && npm run build
    deploy:
      startCommand: npx serve -s dist -l $PORT
      numReplicas: 1
      region: us-west1

  # Redis 캐시
  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data
    deploy:
      numReplicas: 1
      command: redis-server --appendonly yes --requirepass $REDIS_PASSWORD

  # 백그라운드 작업 워커
  worker:
    source:
      repo: .
      branch: main
      dir: backend
    build:
      builder: NIXPACKS
      buildCommand: npm ci
    deploy:
      startCommand: npm run worker
      numReplicas: 1
      env:
        - NODE_ENV=production

volumes:
  redis_data:

```

### 11.1.2 환경변수 관리

### Railway 환경변수 설정 스크립트

```jsx
// scripts/setup-railway-env.js
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

class RailwayEnvManager {
  constructor() {
    this.envFile = path.join(__dirname, '../.env.production');
    this.secrets = this.loadSecrets();
  }

  // .env 파일 로드
  loadSecrets() {
    if (!fs.existsSync(this.envFile)) {
      console.error('.env.production file not found');
      process.exit(1);
    }

    const envContent = fs.readFileSync(this.envFile, 'utf8');
    const secrets = {};

    envContent.split('\n').forEach(line => {
      const [key, value] = line.split('=');
      if (key && value) {
        secrets[key.trim()] = value.trim();
      }
    });

    return secrets;
  }

  // Railway에 환경변수 설정
  setEnvironmentVariables() {
    const requiredVars = [
      'NODE_ENV',
      'SUPABASE_URL',
      'SUPABASE_ANON_KEY',
      'SUPABASE_SERVICE_ROLE_KEY',
      'YOUTUBE_API_KEY',
      'CLAUDE_API_KEY',
      'JWT_SECRET',
      'ENCRYPTION_KEY',
      'REDIS_URL',
      'REDIS_PASSWORD',
      'SESSION_SECRET',
      'ALLOWED_ORIGINS',
      'SENTRY_DSN',
      'SLACK_WEBHOOK_URL'
    ];

    console.log('Setting Railway environment variables...');

    requiredVars.forEach(varName => {
      if (!this.secrets[varName]) {
        console.warn(`Warning: ${varName} not found in .env file`);
        return;
      }

      try {
        execSync(`railway variables set ${varName}="${this.secrets[varName]}"`, {
          stdio: 'inherit'
        });
        console.log(`✓ Set ${varName}`);
      } catch (error) {
        console.error(`✗ Failed to set ${varName}:`, error.message);
      }
    });

    console.log('\nEnvironment variables setup complete!');
  }

  // 환경변수 검증
  validateEnvironment() {
    console.log('\nValidating Railway environment...');

    try {
      const output = execSync('railway variables', { encoding: 'utf8' });
      const deployedVars = output.split('\n').map(line => line.split('=')[0].trim());

      const missing = [];
      Object.keys(this.secrets).forEach(key => {
        if (!deployedVars.includes(key)) {
          missing.push(key);
        }
      });

      if (missing.length > 0) {
        console.warn('\nMissing variables:', missing.join(', '));
      } else {
        console.log('\n✓ All environment variables are set correctly');
      }
    } catch (error) {
      console.error('Failed to validate environment:', error.message);
    }
  }

  // 환경별 설정
  setupEnvironmentSpecific(environment) {
    const envSpecific = {
      production: {
        NODE_ENV: 'production',
        LOG_LEVEL: 'error',
        ENABLE_MONITORING: 'true'
      },
      staging: {
        NODE_ENV: 'staging',
        LOG_LEVEL: 'debug',
        ENABLE_MONITORING: 'true'
      },
      development: {
        NODE_ENV: 'development',
        LOG_LEVEL: 'debug',
        ENABLE_MONITORING: 'false'
      }
    };

    const config = envSpecific[environment];
    if (!config) {
      console.error(`Unknown environment: ${environment}`);
      return;
    }

    console.log(`\nSetting up ${environment} environment...`);

    Object.entries(config).forEach(([key, value]) => {
      execSync(`railway variables set ${key}="${value}"`, { stdio: 'inherit' });
    });
  }
}

// 실행
const manager = new RailwayEnvManager();
const environment = process.argv[2] || 'production';

manager.setEnvironmentVariables();
manager.setupEnvironmentSpecific(environment);
manager.validateEnvironment();

```

### 보안 환경변수 관리

```jsx
// config/secrets.js
const crypto = require('crypto');

class SecretsManager {
  constructor() {
    this.algorithm = 'aes-256-gcm';
    this.masterKey = process.env.MASTER_KEY || this.generateMasterKey();
  }

  // 마스터 키 생성
  generateMasterKey() {
    return crypto.randomBytes(32).toString('hex');
  }

  // 시크릿 암호화
  encryptSecret(secret) {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv(
      this.algorithm,
      Buffer.from(this.masterKey, 'hex'),
      iv
    );

    let encrypted = cipher.update(secret, 'utf8', 'hex');
    encrypted += cipher.final('hex');

    const authTag = cipher.getAuthTag();

    return {
      encrypted,
      iv: iv.toString('hex'),
      authTag: authTag.toString('hex')
    };
  }

  // 시크릿 복호화
  decryptSecret(encryptedData) {
    const decipher = crypto.createDecipheriv(
      this.algorithm,
      Buffer.from(this.masterKey, 'hex'),
      Buffer.from(encryptedData.iv, 'hex')
    );

    decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));

    let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  }

  // Railway Secrets 설정
  async setupRailwaySecrets() {
    const secrets = {
      DATABASE_URL: process.env.DATABASE_URL,
      API_KEYS: {
        youtube: process.env.YOUTUBE_API_KEY,
        claude: process.env.CLAUDE_API_KEY
      }
    };

    // 민감한 데이터 암호화
    const encryptedSecrets = {};

    Object.entries(secrets).forEach(([key, value]) => {
      if (typeof value === 'object') {
        encryptedSecrets[key] = {};
        Object.entries(value).forEach(([subKey, subValue]) => {
          encryptedSecrets[key][subKey] = this.encryptSecret(subValue);
        });
      } else {
        encryptedSecrets[key] = this.encryptSecret(value);
      }
    });

    // Railway에 저장
    const secretsJson = JSON.stringify(encryptedSecrets);
    require('child_process').execSync(
      `railway variables set ENCRYPTED_SECRETS='${secretsJson}'`,
      { stdio: 'inherit' }
    );
  }

  // 런타임에서 시크릿 로드
  loadSecrets() {
    const encryptedSecrets = JSON.parse(process.env.ENCRYPTED_SECRETS || '{}');
    const decryptedSecrets = {};

    Object.entries(encryptedSecrets).forEach(([key, value]) => {
      if (value.encrypted) {
        decryptedSecrets[key] = this.decryptSecret(value);
      } else if (typeof value === 'object') {
        decryptedSecrets[key] = {};
        Object.entries(value).forEach(([subKey, subValue]) => {
          decryptedSecrets[key][subKey] = this.decryptSecret(subValue);
        });
      }
    });

    return decryptedSecrets;
  }
}

module.exports = new SecretsManager();

```

### 11.1.3 자동 배포 파이프라인

### GitHub Actions 통합

```yaml
# .github/workflows/deploy.yml
name: Deploy to Railway

on:
  push:
    branches: [main, staging]
  pull_request:
    types: [opened, synchronize]

env:
  RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test

      - name: Run security audit
        run: npm audit --production

      - name: Lint code
        run: npm run lint

  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Build application
        run: npm run build

      - name: Upload build artifacts
        uses: actions/upload-artifact@v3
        with:
          name: build-artifacts
          path: |
            backend/dist
            frontend/dist

  deploy-staging:
    needs: build
    if: github.ref == 'refs/heads/staging'
    runs-on: ubuntu-latest
    environment: staging
    steps:
      - uses: actions/checkout@v3

      - name: Install Railway CLI
        run: npm install -g @railway/cli

      - name: Deploy to Railway Staging
        run: |
          railway link ${{ secrets.RAILWAY_PROJECT_ID }}
          railway environment staging
          railway up --detach

      - name: Run smoke tests
        run: npm run test:smoke:staging

      - name: Notify Slack
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: 'Staging deployment completed'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}

  deploy-production:
    needs: build
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    environment: production
    steps:
      - uses: actions/checkout@v3

      - name: Install Railway CLI
        run: npm install -g @railway/cli

      - name: Deploy to Railway Production
        run: |
          railway link ${{ secrets.RAILWAY_PROJECT_ID }}
          railway environment production
          railway up --detach

      - name: Wait for deployment
        run: sleep 60

      - name: Health check
        run: |
          response=$(curl -s -o /dev/null -w "%{http_code}" https://api.ytshorts-curator.com/health)
          if [ $response -ne 200 ]; then
            echo "Health check failed"
            exit 1
          fi

      - name: Create release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ github.run_number }}
          release_name: Release ${{ github.run_number }}
          body: |
            Automated production deployment
            Commit: ${{ github.sha }}

      - name: Notify team
        uses: 8398a7/action-slack@v3
        with:
          status: ${{ job.status }}
          text: 'Production deployment completed'
          webhook_url: ${{ secrets.SLACK_WEBHOOK }}
          fields: repo,message,commit,author,action,eventName,ref,workflow

```

### 배포 스크립트

```jsx
// scripts/deploy.js
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

class DeploymentManager {
  constructor() {
    this.environment = process.env.DEPLOY_ENV || 'production';
    this.projectId = process.env.RAILWAY_PROJECT_ID;
  }

  // 사전 배포 체크
  async preDeploymentChecks() {
    console.log('Running pre-deployment checks...\n');

    const checks = [
      this.checkGitStatus,
      this.checkTests,
      this.checkBuild,
      this.checkEnvironmentVariables,
      this.checkDatabaseMigrations,
      this.checkDependencies
    ];

    for (const check of checks) {
      try {
        await check.call(this);
        console.log(`✓ ${check.name} passed`);
      } catch (error) {
        console.error(`✗ ${check.name} failed:`, error.message);
        process.exit(1);
      }
    }

    console.log('\nAll pre-deployment checks passed!');
  }

  // Git 상태 확인
  checkGitStatus() {
    const status = execSync('git status --porcelain', { encoding: 'utf8' });
    if (status) {
      throw new Error('Uncommitted changes detected');
    }

    const branch = execSync('git branch --show-current', { encoding: 'utf8' }).trim();
    if (this.environment === 'production' && branch !== 'main') {
      throw new Error('Production deployments must be from main branch');
    }
  }

  // 테스트 실행
  checkTests() {
    execSync('npm test', { stdio: 'inherit' });
  }

  // 빌드 확인
  checkBuild() {
    execSync('npm run build', { stdio: 'inherit' });
  }

  // 환경변수 확인
  checkEnvironmentVariables() {
    const required = [
      'RAILWAY_TOKEN',
      'RAILWAY_PROJECT_ID',
      'NODE_ENV'
    ];

    const missing = required.filter(v => !process.env[v]);
    if (missing.length > 0) {
      throw new Error(`Missing environment variables: ${missing.join(', ')}`);
    }
  }

  // 데이터베이스 마이그레이션 확인
  async checkDatabaseMigrations() {
    const pending = execSync('npm run db:migrate:status', { encoding: 'utf8' });
    if (pending.includes('pending')) {
      throw new Error('Pending database migrations detected');
    }
  }

  // 의존성 확인
  checkDependencies() {
    const auditResult = execSync('npm audit --production --json', { encoding: 'utf8' });
    const audit = JSON.parse(auditResult);

    if (audit.metadata.vulnerabilities.high > 0 || audit.metadata.vulnerabilities.critical > 0) {
      throw new Error('High or critical vulnerabilities found in dependencies');
    }
  }

  // 배포 실행
  async deploy() {
    console.log(`\nDeploying to ${this.environment}...`);

    try {
      // Railway 환경 설정
      execSync(`railway link ${this.projectId}`, { stdio: 'inherit' });
      execSync(`railway environment ${this.environment}`, { stdio: 'inherit' });

      // 배포
      const deployOutput = execSync('railway up --json', { encoding: 'utf8' });
      const deployInfo = JSON.parse(deployOutput);

      console.log('\nDeployment initiated:', deployInfo.url);

      // 배포 완료 대기
      await this.waitForDeployment(deployInfo.deploymentId);

      // 배포 후 검증
      await this.postDeploymentVerification(deployInfo.url);

      console.log('\n✅ Deployment successful!');
      return deployInfo;

    } catch (error) {
      console.error('\n❌ Deployment failed:', error.message);
      await this.rollback();
      process.exit(1);
    }
  }

  // 배포 완료 대기
  async waitForDeployment(deploymentId, maxAttempts = 60) {
    console.log('\nWaiting for deployment to complete...');

    for (let i = 0; i < maxAttempts; i++) {
      const status = execSync(
        `railway status --json`,
        { encoding: 'utf8' }
      );

      const deploymentStatus = JSON.parse(status);

      if (deploymentStatus.status === 'SUCCESS') {
        console.log('Deployment completed successfully');
        return;
      } else if (deploymentStatus.status === 'FAILED') {
        throw new Error('Deployment failed');
      }

      process.stdout.write('.');
      await new Promise(resolve => setTimeout(resolve, 5000));
    }

    throw new Error('Deployment timeout');
  }

  // 배포 후 검증
  async postDeploymentVerification(deploymentUrl) {
    console.log('\nRunning post-deployment verification...');

    const checks = [
      () => this.checkHealth(deploymentUrl),
      () => this.checkApiEndpoints(deploymentUrl),
      () => this.runSmokeTests(deploymentUrl)
    ];

    for (const check of checks) {
      await check();
    }
  }

  // 헬스체크
  async checkHealth(baseUrl) {
    const response = await fetch(`${baseUrl}/health`);
    if (!response.ok) {
      throw new Error(`Health check failed: ${response.status}`);
    }

    const health = await response.json();
    console.log('✓ Health check passed:', health);
  }

  // API 엔드포인트 확인
  async checkApiEndpoints(baseUrl) {
    const endpoints = [
      '/api/videos/trending',
      '/api/auth/status',
      '/metrics'
    ];

    for (const endpoint of endpoints) {
      const response = await fetch(`${baseUrl}${endpoint}`);
      if (!response.ok && response.status !== 401) {
        throw new Error(`Endpoint ${endpoint} returned ${response.status}`);
      }
    }

    console.log('✓ API endpoints verified');
  }

  // 스모크 테스트
  async runSmokeTests(deploymentUrl) {
    process.env.API_URL = deploymentUrl;
    execSync('npm run test:smoke', { stdio: 'inherit' });
    console.log('✓ Smoke tests passed');
  }

  // 롤백
  async rollback() {
    console.log('\nInitiating rollback...');

    try {
      execSync('railway rollback', { stdio: 'inherit' });
      console.log('Rollback completed');
    } catch (error) {
      console.error('Rollback failed:', error.message);
    }
  }

  // 배포 알림
  async notifyDeployment(deployInfo) {
    const webhook = process.env.SLACK_WEBHOOK_URL;
    if (!webhook) return;

    const message = {
      text: `Deployment to ${this.environment} completed`,
      attachments: [{
        color: 'good',
        fields: [
          {
            title: 'Environment',
            value: this.environment,
            short: true
          },
          {
            title: 'URL',
            value: deployInfo.url,
            short: true
          },
          {
            title: 'Version',
            value: deployInfo.version,
            short: true
          },
          {
            title: 'Deployed by',
            value: process.env.USER || 'CI/CD',
            short: true
          }
        ],
        timestamp: new Date().toISOString()
      }]
    };

    await fetch(webhook, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(message)
    });
  }
}

// 실행
async function main() {
  const deployer = new DeploymentManager();

  await deployer.preDeploymentChecks();
  const deployInfo = await deployer.deploy();
  await deployer.notifyDeployment(deployInfo);
}

main().catch(console.error);

```

## 11.2 모니터링 및 로깅

### 11.2.1 로그 수집 시스템

### 통합 로깅 설정

```jsx
// config/logging.js
const winston = require('winston');
const { ElasticsearchTransport } = require('winston-elasticsearch');
const DailyRotateFile = require('winston-daily-rotate-file');
const Sentry = require('@sentry/node');

class LoggingService {
  constructor() {
    this.environment = process.env.NODE_ENV || 'development';
    this.serviceName = 'youtube-shorts-curator';

    // Sentry 초기화
    this.initializeSentry();

    // Winston 로거 생성
    this.logger = this.createLogger();
  }

  // Sentry 초기화
  initializeSentry() {
    if (process.env.SENTRY_DSN) {
      Sentry.init({
        dsn: process.env.SENTRY_DSN,
        environment: this.environment,
        tracesSampleRate: this.environment === 'production' ? 0.1 : 1.0,
        integrations: [
          new Sentry.Integrations.Http({ tracing: true }),
          new Sentry.Integrations.Express({ app: require('express')() })
        ]
      });
    }
  }

  // Winston 로거 생성
  createLogger() {
    const logFormat = winston.format.combine(
      winston.format.timestamp(),
      winston.format.errors({ stack: true }),
      winston.format.json(),
      winston.format.printf(info => {
        const log = {
          timestamp: info.timestamp,
          level: info.level,
          service: this.serviceName,
          environment: this.environment,
          message: info.message,
          ...this.sanitizeMetadata(info)
        };

        return JSON.stringify(log);
      })
    );

    const transports = [
      // 콘솔 출력
      new winston.transports.Console({
        format: winston.format.combine(
          winston.format.colorize(),
          winston.format.simple()
        )
      })
    ];

    // 파일 로테이션
    if (this.environment !== 'development') {
      transports.push(
        new DailyRotateFile({
          filename: 'logs/application-%DATE%.log',
          datePattern: 'YYYY-MM-DD',
          zippedArchive: true,
          maxSize: '20m',
          maxFiles: '14d'
        }),
        new DailyRotateFile({
          filename: 'logs/error-%DATE%.log',
          datePattern: 'YYYY-MM-DD',
          zippedArchive: true,
          maxSize: '20m',
          maxFiles: '30d',
          level: 'error'
        })
      );
    }

    // Elasticsearch 전송 (프로덕션)
    if (process.env.ELASTICSEARCH_URL) {
      transports.push(
        new ElasticsearchTransport({
          level: 'info',
          clientOpts: {
            node: process.env.ELASTICSEARCH_URL,
            auth: {
              username: process.env.ELASTICSEARCH_USER,
              password: process.env.ELASTICSEARCH_PASSWORD
            }
          },
          index: `logs-${this.serviceName}`,
          transformer: this.elasticsearchTransformer.bind(this)
        })
      );
    }

    return winston.createLogger({
      level: process.env.LOG_LEVEL || 'info',
      format: logFormat,
      transports,
      exceptionHandlers: [
        new winston.transports.File({ filename: 'logs/exceptions.log' })
      ],
      rejectionHandlers: [
        new winston.transports.File({ filename: 'logs/rejections.log' })
      ]
    });
  }

  // 민감한 정보 제거
  sanitizeMetadata(info) {
    const sensitive = ['password', 'token', 'api_key', 'secret'];
    const metadata = { ...info };

    delete metadata.timestamp;
    delete metadata.level;
    delete metadata.message;

    const sanitize = (obj) => {
      if (typeof obj !== 'object' || obj === null) return obj;

      const sanitized = Array.isArray(obj) ? [] : {};

      for (const key in obj) {
        if (sensitive.some(s => key.toLowerCase().includes(s))) {
          sanitized[key] = '[REDACTED]';
        } else if (typeof obj[key] === 'object') {
          sanitized[key] = sanitize(obj[key]);
        } else {
          sanitized[key] = obj[key];
        }
      }

      return sanitized;
    };

    return sanitize(metadata);
  }

  // Elasticsearch 변환
  elasticsearchTransformer(logData) {
    return {
      '@timestamp': logData.timestamp,
      level: logData.level,
      message: logData.message,
      service: this.serviceName,
      environment: this.environment,
      fields: logData.meta
    };
  }

  // 구조화된 로깅 메서드
  log(level, message, metadata = {}) {
    this.logger.log(level, message, {
      ...metadata,
      correlationId: metadata.correlationId || this.generateCorrelationId()
    });
  }

  info(message, metadata) {
    this.log('info', message, metadata);
  }

  warn(message, metadata) {
    this.log('warn', message, metadata);
  }

  error(message, error, metadata = {}) {
    const errorMetadata = {
      ...metadata,
      error: {
        message: error.message,
        stack: error.stack,
        code: error.code,
        name: error.name
      }
    };

    this.log('error', message, errorMetadata);

    // Sentry에도 전송
    if (process.env.SENTRY_DSN) {
      Sentry.captureException(error, {
        tags: metadata,
        level: 'error'
      });
    }
  }

  // API 요청 로깅
  logApiRequest(req, res, responseTime) {
    const logData = {
      method: req.method,
      path: req.path,
      query: req.query,
      statusCode: res.statusCode,
      responseTime,
      userAgent: req.headers['user-agent'],
      ip: req.ip,
      userId: req.userId,
      correlationId: req.correlationId
    };

    if (res.statusCode >= 400) {
      this.warn('API request failed', logData);
    } else {
      this.info('API request', logData);
    }
  }

  // 데이터베이스 쿼리 로깅
  logDatabaseQuery(query, duration, error = null) {
    const logData = {
      query: this.sanitizeQuery(query),
      duration,
      success: !error
    };

    if (error) {
      this.error('Database query failed', error, logData);
    } else if (duration > 1000) {
      this.warn('Slow database query', logData);
    } else {
      this.info('Database query', logData);
    }
  }

  // 쿼리 민감정보 제거
  sanitizeQuery(query) {
    // 비밀번호 등 민감한 정보 마스킹
    return query.replace(/password\s*=\s*'[^']*'/gi, "password='[REDACTED]'");
  }

  // 상관관계 ID 생성
  generateCorrelationId() {
    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  }

  // Express 미들웨어
  expressMiddleware() {
    return (req, res, next) => {
      req.correlationId = req.headers['x-correlation-id'] || this.generateCorrelationId();
      req.startTime = Date.now();

      // 응답 로깅
      res.on('finish', () => {
        const responseTime = Date.now() - req.startTime;
        this.logApiRequest(req, res, responseTime);
      });

      next();
    };
  }

  // 비정상 종료 핸들링
  setupExceptionHandlers() {
    process.on('uncaughtException', (error) => {
      this.error('Uncaught exception', error);
      process.exit(1);
    });

    process.on('unhandledRejection', (reason, promise) => {
      this.error('Unhandled rejection', new Error(reason), {
        promise: promise.toString()
      });
    });

    process.on('SIGTERM', () => {
      this.info('SIGTERM received, shutting down gracefully');
      process.exit(0);
    });
  }
}

module.exports = new LoggingService();

```

### 분산 추적 (Distributed Tracing)

```jsx
// config/tracing.js
const { NodeTracerProvider } = require('@opentelemetry/sdk-trace-node');
const { Resource } = require('@opentelemetry/resources');
const { SemanticResourceAttributes } = require('@opentelemetry/semantic-conventions');
const { JaegerExporter } = require('@opentelemetry/exporter-jaeger');
const { BatchSpanProcessor } = require('@opentelemetry/sdk-trace-base');
const { registerInstrumentations } = require('@opentelemetry/instrumentation');
const { HttpInstrumentation } = require('@opentelemetry/instrumentation-http');
const { ExpressInstrumentation } = require('@opentelemetry/instrumentation-express');

class TracingService {
  constructor() {
    this.serviceName = 'youtube-shorts-curator';
    this.provider = null;
  }

  // 추적 초기화
  initialize() {
    // 리소스 정의
    const resource = Resource.default().merge(
      new Resource({
        [SemanticResourceAttributes.SERVICE_NAME]: this.serviceName,
        [SemanticResourceAttributes.SERVICE_VERSION]: process.env.APP_VERSION || '1.0.0',
        [SemanticResourceAttributes.DEPLOYMENT_ENVIRONMENT]: process.env.NODE_ENV
      })
    );

    // Provider 생성
    this.provider = new NodeTracerProvider({
      resource
    });

    // Jaeger Exporter 설정
    const jaegerExporter = new JaegerExporter({
      endpoint: process.env.JAEGER_ENDPOINT || 'http://localhost:14268/api/traces',
      serviceName: this.serviceName
    });

    // Span Processor 추가
    this.provider.addSpanProcessor(
      new BatchSpanProcessor(jaegerExporter, {
        maxQueueSize: 100,
        maxExportBatchSize: 10,
        scheduledDelayMillis: 500,
        exportTimeoutMillis: 30000
      })
    );

    // Provider 등록
    this.provider.register();

    // 자동 계측 설정
    registerInstrumentations({
      instrumentations: [
        new HttpInstrumentation({
          requestHook: (span, request) => {
            span.setAttribute('http.request.body', JSON.stringify(request.body));
          },
          responseHook: (span, response) => {
            span.setAttribute('http.response.size', response.headers['content-length']);
          }
        }),
        new ExpressInstrumentation({
          requestHook: (span, req) => {
            span.setAttribute('user.id', req.userId);
            span.setAttribute('correlation.id', req.correlationId);
          }
        })
      ]
    });

    console.log('Tracing initialized');
  }

  // 커스텀 스팬 생성
  createSpan(name, options = {}) {
    const tracer = this.provider.getTracer(this.serviceName);
    return tracer.startSpan(name, options);
  }

  // 비동기 작업 추적
  async traceAsync(name, fn, attributes = {}) {
    const span = this.createSpan(name);

    // 속성 추가
    Object.entries(attributes).forEach(([key, value]) => {
      span.setAttribute(key, value);
    });

    try {
      const result = await fn();
      span.setStatus({ code: 1 }); // OK
      return result;
    } catch (error) {
      span.setStatus({
        code: 2, // ERROR
        message: error.message
      });
      span.recordException(error);
      throw error;
    } finally {
      span.end();
    }
  }

  // Express 미들웨어
  expressMiddleware() {
    return async (req, res, next) => {
      const span = this.createSpan(`${req.method} ${req.path}`);

      // 요청 정보 추가
      span.setAttributes({
        'http.method': req.method,
        'http.url': req.url,
        'http.target': req.path,
        'http.host': req.hostname,
        'http.scheme': req.protocol,
        'http.user_agent': req.headers['user-agent'],
        'user.id': req.userId,
        'correlation.id': req.correlationId
      });

      // 컨텍스트에 스팬 추가
      req.span = span;

      // 응답 처리
      const originalSend = res.send;
      res.send = function(data) {
        span.setAttributes({
          'http.status_code': res.statusCode,
          'http.response.size': Buffer.byteLength(data)
        });

        if (res.statusCode >= 400) {
          span.setStatus({
            code: 2,
            message: `HTTP ${res.statusCode}`
          });
        }

        span.end();
        return originalSend.call(this, data);
      };

      next();
    };
  }

  // 데이터베이스 추적
  traceDatabaseQuery(queryName, query) {
    return this.traceAsync(`db.${queryName}`, async () => {
      // 실제 쿼리 실행
      return await executeQuery(query);
    }, {
      'db.system': 'postgresql',
      'db.statement': query.substring(0, 100) // 쿼리 일부만
    });
  }

  // 외부 API 호출 추적
  traceExternalApi(apiName, url, method) {
    return this.traceAsync(`external.${apiName}`, async () => {
      // 실제 API 호출
      return await fetch(url, { method });
    }, {
      'http.url': url,
      'http.method': method,
      'peer.service': apiName
    });
  }

  // 종료 처리
  shutdown() {
    return this.provider.shutdown();
  }
}

module.exports = new TracingService();

```

### 11.2.2 에러 추적

### 에러 추적 시스템

```jsx
// monitoring/errorTracking.js
const Sentry = require('@sentry/node');
const { ProfilingIntegration } = require('@sentry/profiling-node');

class ErrorTrackingService {
  constructor() {
    this.initialized = false;
    this.errorQueue = [];
    this.errorPatterns = new Map();
  }

  // 초기화
  initialize(app) {
    if (this.initialized) return;

    Sentry.init({
      dsn: process.env.SENTRY_DSN,
      environment: process.env.NODE_ENV,
      integrations: [
        new Sentry.Integrations.Http({ tracing: true }),
        new Sentry.Integrations.Express({ app }),
        new ProfilingIntegration()
      ],
      tracesSampleRate: this.getTraceSampleRate(),
      profilesSampleRate: 1.0,
      beforeSend: this.beforeSend.bind(this),
      beforeSendTransaction: this.beforeSendTransaction.bind(this)
    });

    this.initialized = true;
    this.startErrorAnalysis();
  }

  // 샘플링 비율 결정
  getTraceSampleRate() {
    switch (process.env.NODE_ENV) {
      case 'production':
        return 0.1;
      case 'staging':
        return 0.5;
      default:
        return 1.0;
    }
  }

  // 에러 전송 전 처리
  beforeSend(event, hint) {
    // 민감한 정보 제거
    if (event.request) {
      event.request = this.sanitizeRequest(event.request);
    }

    // 에러 그룹화
    const errorKey = this.getErrorKey(hint.originalException);
    this.trackErrorPattern(errorKey);

    // 반복적인 에러 필터링
    if (this.isRepetitiveError(errorKey)) {
      return null; // 전송하지 않음
    }

    // 컨텍스트 추가
    event.contexts = {
      ...event.contexts,
      app: {
        memory_usage: process.memoryUsage(),
        uptime: process.uptime(),
        node_version: process.version
      }
    };

    return event;
  }

  // 트랜잭션 전송 전 처리
  beforeSendTransaction(event) {
    // 느린 트랜잭션만 전송
    if (event.transaction && event.timestamp - event.start_timestamp < 1) {
      return null;
    }
    return event;
  }

  // 요청 정보 정제
  sanitizeRequest(request) {
    const sanitized = { ...request };

    // 헤더 정제
    if (sanitized.headers) {
      delete sanitized.headers.authorization;
      delete sanitized.headers.cookie;
      delete sanitized.headers['x-api-key'];
    }

    // 쿼리 파라미터 정제
    if (sanitized.query_string) {
      sanitized.query_string = sanitized.query_string.replace(
        /api_key=[^&]*/g,
        'api_key=[REDACTED]'
      );
    }

    // Body 정제
    if (sanitized.data) {
      const sensitive = ['password', 'token', 'secret'];
      sensitive.forEach(field => {
        if (sanitized.data[field]) {
          sanitized.data[field] = '[REDACTED]';
        }
      });
    }

    return sanitized;
  }

  // 에러 키 생성
  getErrorKey(error) {
    if (!error) return 'unknown';

    return `${error.name}-${error.message}-${error.stack?.split('\n')[1]?.trim()}`;
  }

  // 에러 패턴 추적
  trackErrorPattern(errorKey) {
    const pattern = this.errorPatterns.get(errorKey) || {
      count: 0,
      firstSeen: Date.now(),
      lastSeen: Date.now()
    };

    pattern.count++;
    pattern.lastSeen = Date.now();

    this.errorPatterns.set(errorKey, pattern);
  }

  // 반복적인 에러 확인
  isRepetitiveError(errorKey) {
    const pattern = this.errorPatterns.get(errorKey);
    if (!pattern) return false;

    // 5분 내에 10번 이상 발생한 에러는 필터링
    const fiveMinutes = 5 * 60 * 1000;
    const timeDiff = Date.now() - pattern.firstSeen;

    return timeDiff < fiveMinutes && pattern.count > 10;
  }

  // 에러 분석 시작
  startErrorAnalysis() {
    // 주기적으로 에러 패턴 분석
    setInterval(() => {
      this.analyzeErrorPatterns();
      this.cleanupOldPatterns();
    }, 60000); // 1분마다
  }

  // 에러 패턴 분석
  analyzeErrorPatterns() {
    const criticalPatterns = [];

    for (const [key, pattern] of this.errorPatterns) {
      // 급증하는 에러 감지
      if (pattern.count > 50) {
        criticalPatterns.push({
          key,
          ...pattern
        });
      }
    }

    if (criticalPatterns.length > 0) {
      this.alertCriticalErrors(criticalPatterns);
    }
  }

  // 오래된 패턴 정리
  cleanupOldPatterns() {
    const oneHour = 60 * 60 * 1000;
    const now = Date.now();

    for (const [key, pattern] of this.errorPatterns) {
      if (now - pattern.lastSeen > oneHour) {
        this.errorPatterns.delete(key);
      }
    }
  }

  // 중요 에러 알림
  async alertCriticalErrors(patterns) {
    const webhook = process.env.SLACK_WEBHOOK_URL;
    if (!webhook) return;

    const message = {
      text: '🚨 Critical Error Patterns Detected',
      attachments: patterns.map(pattern => ({
        color: 'danger',
        title: pattern.key,
        fields: [
          {
            title: 'Occurrences',
            value: pattern.count,
            short: true
          },
          {
            title: 'Time Range',
            value: `${Math.round((Date.now() - pattern.firstSeen) / 60000)} minutes`,
            short: true
          }
        ]
      }))
    };

    await fetch(webhook, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(message)
    });
  }

  // 커스텀 에러 캡처
  captureError(error, context = {}) {
    if (!this.initialized) {
      this.errorQueue.push({ error, context });
      return;
    }

    Sentry.captureException(error, {
      tags: {
        component: context.component,
        action: context.action
      },
      extra: context
    });
  }

  // 사용자 컨텍스트 설정
  setUser(user) {
    Sentry.setUser({
      id: user.id,
      email: user.email,
      username: user.name,
      tier: user.tier
    });
  }

  // 브레드크럼 추가
  addBreadcrumb(breadcrumb) {
    Sentry.addBreadcrumb({
      timestamp: Date.now() / 1000,
      ...breadcrumb
    });
  }

  // Express 에러 핸들러
  errorHandler() {
    return Sentry.Handlers.errorHandler({
      shouldHandleError(error) {
        // 404 에러는 제외
        if (error.status === 404) {
          return false;
        }
        return true;
      }
    });
  }

  // 요청 핸들러
  requestHandler() {
    return Sentry.Handlers.requestHandler({
      user: ['id', 'email'],
      ip: true,
      request: ['method', 'url', 'query_string', 'data'],
      transaction: 'methodPath'
    });
  }
}

module.exports = new ErrorTrackingService();

```

### 11.2.3 알림 설정

### 통합 알림 시스템

```jsx
// monitoring/alerting.js
const nodemailer = require('nodemailer');
const twilio = require('twilio');

class AlertingService {
  constructor() {
    this.channels = this.initializeChannels();
    this.alertRules = this.loadAlertRules();
    this.alertHistory = new Map();
  }

  // 알림 채널 초기화
  initializeChannels() {
    const channels = {};

    // Slack
    if (process.env.SLACK_WEBHOOK_URL) {
      channels.slack = {
        send: this.sendSlackAlert.bind(this),
        priority: ['critical', 'high', 'medium', 'low']
      };
    }

    // Email
    if (process.env.SMTP_HOST) {
      channels.email = {
        send: this.sendEmailAlert.bind(this),
        priority: ['critical', 'high']
      };

      this.emailTransporter = nodemailer.createTransport({
        host: process.env.SMTP_HOST,
        port: process.env.SMTP_PORT,
        secure: true,
        auth: {
          user: process.env.SMTP_USER,
          pass: process.env.SMTP_PASS
        }
      });
    }

    // SMS (Twilio)
    if (process.env.TWILIO_ACCOUNT_SID) {
      channels.sms = {
        send: this.sendSmsAlert.bind(this),
        priority: ['critical']
      };

      this.twilioClient = twilio(
        process.env.TWILIO_ACCOUNT_SID,
        process.env.TWILIO_AUTH_TOKEN
      );
    }

    // PagerDuty
    if (process.env.PAGERDUTY_ROUTING_KEY) {
      channels.pagerduty = {
        send: this.sendPagerDutyAlert.bind(this),
        priority: ['critical']
      };
    }

    return channels;
  }

  // 알림 규칙 로드
  loadAlertRules() {
    return {
      // 시스템 알림
      system: {
        high_cpu: {
          threshold: 80,
          duration: 300, // 5분
          priority: 'high',
          message: 'CPU usage above {value}% for {duration} minutes'
        },
        high_memory: {
          threshold: 90,
          duration: 300,
          priority: 'high',
          message: 'Memory usage above {value}% for {duration} minutes'
        },
        disk_space: {
          threshold: 85,
          priority: 'medium',
          message: 'Disk space usage above {value}%'
        }
      },

      // API 알림
      api: {
        high_error_rate: {
          threshold: 5, // 5%
          duration: 300,
          priority: 'high',
          message: 'API error rate above {value}% for {duration} minutes'
        },
        slow_response: {
          threshold: 2000, // 2초
          duration: 600,
          priority: 'medium',
          message: 'Average response time above {value}ms for {duration} minutes'
        },
        rate_limit_exceeded: {
          threshold: 1000,
          duration: 60,
          priority: 'medium',
          message: 'Rate limit exceeded {value} times in {duration} minutes'
        }
      },

      // 비즈니스 알림
      business: {
        youtube_quota_usage: {
          threshold: 80, // 80%
          priority: 'high',
          message: 'YouTube API quota usage at {value}%'
        },
        low_cache_hit_rate: {
          threshold: 60, // 60%
          duration: 1800, // 30분
          priority: 'medium',
          message: 'Cache hit rate below {value}% for {duration} minutes'
        },
        payment_failure: {
          threshold: 5,
          duration: 3600,
          priority: 'critical',
          message: '{value} payment failures in the last hour'
        }
      }
    };
  }

  // 알림 전송
  async sendAlert(alert) {
    // 중복 알림 방지
    if (this.isDuplicateAlert(alert)) {
      return;
    }

    // 알림 이력 저장
    this.recordAlert(alert);

    // 우선순위별 채널 선택
    const channels = this.selectChannels(alert.priority);

    // 모든 채널에 알림 전송
    const results = await Promise.allSettled(
      channels.map(channel => channel.send(alert))
    );

    // 전송 결과 로깅
    results.forEach((result, index) => {
      if (result.status === 'rejected') {
        console.error(`Alert sending failed for channel ${index}:`, result.reason);
      }
    });
  }

  // Slack 알림
  async sendSlackAlert(alert) {
    const color = {
      critical: 'danger',
      high: 'warning',
      medium: 'warning',
      low: 'good'
    }[alert.priority];

    const message = {
      text: `${this.getPriorityEmoji(alert.priority)} ${alert.title}`,
      attachments: [{
        color,
        fields: [
          {
            title: 'Priority',
            value: alert.priority.toUpperCase(),
            short: true
          },
          {
            title: 'Component',
            value: alert.component,
            short: true
          },
          {
            title: 'Details',
            value: alert.message,
            short: false
          },
          {
            title: 'Time',
            value: new Date().toISOString(),
            short: true
          }
        ],
        actions: alert.actions || []
      }]
    };

    await fetch(process.env.SLACK_WEBHOOK_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(message)
    });
  }

  // Email 알림
  async sendEmailAlert(alert) {
    const subject = `[${alert.priority.toUpperCase()}] ${alert.title}`;

    const html = `
      <h2>${alert.title}</h2>
      <p><strong>Priority:</strong> ${alert.priority}</p>
      <p><strong>Component:</strong> ${alert.component}</p>
      <p><strong>Message:</strong> ${alert.message}</p>
      <p><strong>Time:</strong> ${new Date().toISOString()}</p>
      ${alert.details ? `<pre>${JSON.stringify(alert.details, null, 2)}</pre>` : ''}
    `;

    await this.emailTransporter.sendMail({
      from: process.env.ALERT_FROM_EMAIL,
      to: process.env.ALERT_TO_EMAILS,
      subject,
      html
    });
  }

  // SMS 알림
  async sendSmsAlert(alert) {
    const message = `[${alert.priority.toUpperCase()}] ${alert.title}\n${alert.message}`;

    await this.twilioClient.messages.create({
      body: message.substring(0, 160), // SMS 길이 제한
      from: process.env.TWILIO_PHONE_NUMBER,
      to: process.env.ALERT_PHONE_NUMBERS.split(',')
    });
  }

  // PagerDuty 알림
  async sendPagerDutyAlert(alert) {
    const event = {
      routing_key: process.env.PAGERDUTY_ROUTING_KEY,
      event_action: 'trigger',
      payload: {
        summary: alert.title,
        severity: this.mapPriority(alert.priority),
        source: alert.component,
        custom_details: alert.details
      }
    };

    await fetch('https://events.pagerduty.com/v2/enqueue', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(event)
    });
  }

  // 채널 선택
  selectChannels(priority) {
    return Object.entries(this.channels)
      .filter(([name, channel]) => channel.priority.includes(priority))
      .map(([name, channel]) => channel);
  }

  // 중복 알림 확인
  isDuplicateAlert(alert) {
    const key = `${alert.component}-${alert.rule}`;
    const lastAlert = this.alertHistory.get(key);

    if (!lastAlert) return false;

    const timeDiff = Date.now() - lastAlert.timestamp;
    const cooldown = this.getCooldownPeriod(alert.priority);

    return timeDiff < cooldown;
  }

  // 알림 이력 기록
  recordAlert(alert) {
    const key = `${alert.component}-${alert.rule}`;
    this.alertHistory.set(key, {
      ...alert,
      timestamp: Date.now()
    });

    // 오래된 이력 정리
    this.cleanupAlertHistory();
  }

  // 쿨다운 기간 결정
  getCooldownPeriod(priority) {
    const cooldowns = {
      critical: 5 * 60 * 1000,    // 5분
      high: 15 * 60 * 1000,       // 15분
      medium: 30 * 60 * 1000,     // 30분
      low: 60 * 60 * 1000         // 1시간
    };

    return cooldowns[priority] || 30 * 60 * 1000;
  }

  // 우선순위 이모지
  getPriorityEmoji(priority) {
    const emojis = {
      critical: '🚨',
      high: '⚠️',
      medium: '📢',
      low: 'ℹ️'
    };

    return emojis[priority] || '📌';
  }

  // 우선순위 매핑 (PagerDuty)
  mapPriority(priority) {
    const mapping = {
      critical: 'critical',
      high: 'error',
      medium: 'warning',
      low: 'info'
    };

    return mapping[priority] || 'info';
  }

  // 알림 이력 정리
  cleanupAlertHistory() {
    const oneDay = 24 * 60 * 60 * 1000;
    const now = Date.now();

    for (const [key, alert] of this.alertHistory) {
      if (now - alert.timestamp > oneDay) {
        this.alertHistory.delete(key);
      }
    }
  }

  // 메트릭 기반 알림 체크
  async checkMetricAlerts(metrics) {
    for (const [category, rules] of Object.entries(this.alertRules)) {
      for (const [ruleName, rule] of Object.entries(rules)) {
        const value = this.getMetricValue(metrics, category, ruleName);

        if (value !== null && this.shouldTriggerAlert(value, rule)) {
          await this.sendAlert({
            title: `${category}.${ruleName} Alert`,
            component: category,
            rule: ruleName,
            priority: rule.priority,
            message: rule.message
              .replace('{value}', value)
              .replace('{duration}', (rule.duration / 60) || 0),
            details: { value, threshold: rule.threshold }
          });
        }
      }
    }
  }

  // 메트릭 값 추출
  getMetricValue(metrics, category, rule) {
    // 실제 메트릭 데이터에서 값 추출
    return metrics?.[category]?.[rule] || null;
  }

  // 알림 트리거 여부 확인
  shouldTriggerAlert(value, rule) {
    if (rule.threshold === undefined) return false;

    // 임계값 비교 (상한/하한에 따라)
    if (rule.type === 'lower_bound') {
      return value < rule.threshold;
    }

    return value > rule.threshold;
  }
}

module.exports = new AlertingService();

```

## 11.3 백업 및 복구

### 11.3.1 데이터베이스 백업

### 자동 백업 시스템

```jsx
// backup/databaseBackup.js
const { createClient } = require('@supabase/supabase-js');
const AWS = require('aws-sdk');
const fs = require('fs').promises;
const path = require('path');
const { exec } = require('child_process').promises;

class DatabaseBackupService {
  constructor() {
    this.supabase = createClient(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_SERVICE_ROLE_KEY
    );

    this.s3 = new AWS.S3({
      accessKeyId: process.env.AWS_ACCESS_KEY_ID,
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
      region: process.env.AWS_REGION
    });

    this.backupBucket = process.env.BACKUP_BUCKET || 'ytshorts-backups';
  }

  // 백업 실행
  async performBackup(type = 'scheduled') {
    const backupId = this.generateBackupId();
    const startTime = Date.now();

    console.log(`Starting ${type} backup: ${backupId}`);

    try {
      // 1. 데이터베이스 덤프
      const dumpFile = await this.dumpDatabase(backupId);

      // 2. 파일 압축 및 암호화
      const encryptedFile = await this.compressAndEncrypt(dumpFile);

      // 3. S3 업로드
      const s3Location = await this.uploadToS3(encryptedFile, backupId);

      // 4. 백업 메타데이터 저장
      await this.saveBackupMetadata({
        id: backupId,
        type,
        size: await this.getFileSize(encryptedFile),
        duration: Date.now() - startTime,
        location: s3Location,
        status: 'completed'
      });

      // 5. 로컬 파일 정리
      await this.cleanupLocalFiles([dumpFile, encryptedFile]);

      // 6. 오래된 백업 정리
      await this.cleanupOldBackups();

      console.log(`Backup completed: ${backupId}`);

      return {
        success: true,
        backupId,
        location: s3Location
      };

    } catch (error) {
      console.error(`Backup failed: ${backupId}`, error);

      await this.saveBackupMetadata({
        id: backupId,
        type,
        status: 'failed',
        error: error.message
      });

      throw error;
    }
  }

  // 데이터베이스 덤프
  async dumpDatabase(backupId) {
    const dumpFile = path.join('/tmp', `backup-${backupId}.sql`);

    // pg_dump 명령 실행
    const command = `pg_dump ${process.env.DATABASE_URL} \
      --no-owner \
      --no-privileges \
      --exclude-table-data='*.logs' \
      --exclude-table-data='*.sessions' \
      > ${dumpFile}`;

    await exec(command);

    return outputFile;
  }

  // S3 업로드
  async uploadToS3(file, backupId) {
    const key = `database/${new Date().getFullYear()}/${backupId}.gz.enc`;

    const fileStream = await fs.readFile(file);

    const params = {
      Bucket: this.backupBucket,
      Key: key,
      Body: fileStream,
      ServerSideEncryption: 'AES256',
      StorageClass: 'STANDARD_IA',
      Metadata: {
        'backup-id': backupId,
        'backup-date': new Date().toISOString(),
        'service': 'youtube-shorts-curator'
      }
    };

    await this.s3.upload(params).promise();

    return `s3://${this.backupBucket}/${key}`;
  }

  // 백업 메타데이터 저장
  async saveBackupMetadata(metadata) {
    const { error } = await this.supabase
      .from('backup_history')
      .insert({
        ...metadata,
        created_at: new Date().toISOString()
      });

    if (error) {
      console.error('Failed to save backup metadata:', error);
    }
  }

  // 백업 ID 생성
  generateBackupId() {
    const timestamp = new Date().toISOString().replace(/[:-]/g, '').replace(/\..+/, '');
    const random = Math.random().toString(36).substring(2, 8);
    return `backup-${timestamp}-${random}`;
  }

  // 파일 크기 확인
  async getFileSize(file) {
    const stats = await fs.stat(file);
    return stats.size;
  }

  // 로컬 파일 정리
  async cleanupLocalFiles(files) {
    for (const file of files) {
      try {
        await fs.unlink(file);
      } catch (error) {
        console.error(`Failed to delete ${file}:`, error);
      }
    }
  }

  // 오래된 백업 정리
  async cleanupOldBackups() {
    const retentionDays = {
      daily: 7,
      weekly: 30,
      monthly: 365
    };

    // S3에서 오래된 백업 삭제
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - retentionDays.daily);

    const listParams = {
      Bucket: this.backupBucket,
      Prefix: 'database/'
    };

    const objects = await this.s3.listObjectsV2(listParams).promise();

    const toDelete = objects.Contents
      .filter(obj => new Date(obj.LastModified) < cutoffDate)
      .map(obj => ({ Key: obj.Key }));

    if (toDelete.length > 0) {
      await this.s3.deleteObjects({
        Bucket: this.backupBucket,
        Delete: { Objects: toDelete }
      }).promise();

      console.log(`Deleted ${toDelete.length} old backups`);
    }
  }

  // 백업 복원
  async restoreBackup(backupId) {
    console.log(`Starting restore for backup: ${backupId}`);

    try {
      // 1. 백업 메타데이터 조회
      const { data: backup } = await this.supabase
        .from('backup_history')
        .select('*')
        .eq('id', backupId)
        .single();

      if (!backup) {
        throw new Error('Backup not found');
      }

      // 2. S3에서 백업 다운로드
      const localFile = await this.downloadFromS3(backup.location);

      // 3. 복호화 및 압축 해제
      const sqlFile = await this.decryptAndDecompress(localFile);

      // 4. 데이터베이스 복원
      await this.restoreDatabase(sqlFile);

      // 5. 복원 후 검증
      await this.verifyRestore();

      // 6. 정리
      await this.cleanupLocalFiles([localFile, sqlFile]);

      console.log(`Restore completed for backup: ${backupId}`);

      return { success: true };

    } catch (error) {
      console.error(`Restore failed for backup: ${backupId}`, error);
      throw error;
    }
  }

  // S3에서 다운로드
  async downloadFromS3(s3Location) {
    const match = s3Location.match(/s3:\/\/([^\/]+)\/(.+)/);
    if (!match) {
      throw new Error('Invalid S3 location');
    }

    const [, bucket, key] = match;
    const localFile = path.join('/tmp', path.basename(key));

    const params = {
      Bucket: bucket,
      Key: key
    };

    const data = await this.s3.getObject(params).promise();
    await fs.writeFile(localFile, data.Body);

    return localFile;
  }

  // 복호화 및 압축 해제
  async decryptAndDecompress(inputFile) {
    const outputFile = inputFile.replace('.gz.enc', '.sql');

    const command = `openssl enc -aes-256-cbc \
      -d \
      -pbkdf2 \
      -pass pass:${process.env.BACKUP_ENCRYPTION_KEY} \
      -in ${inputFile} | \
      gzip -d > ${outputFile}`;

    await exec(command);

    return outputFile;
  }

  // 데이터베이스 복원
  async restoreDatabase(sqlFile) {
    // 주의: 프로덕션에서는 매우 신중하게 실행
    const command = `psql ${process.env.DATABASE_URL} < ${sqlFile}`;

    await exec(command);
  }

  // 복원 검증
  async verifyRestore() {
    // 기본적인 테이블 존재 확인
    const tables = ['users', 'videos', 'search_logs'];

    for (const table of tables) {
      const { data, error } = await this.supabase
        .from(table)
        .select('count')
        .limit(1);

      if (error) {
        throw new Error(`Table ${table} verification failed`);
      }
    }
  }

  // 백업 스케줄 설정
  setupBackupSchedule() {
    const cron = require('node-cron');

    // 일일 백업 (매일 새벽 2시)
    cron.schedule('0 2 * * *', async () => {
      try {
        await this.performBackup('daily');
      } catch (error) {
        console.error('Daily backup failed:', error);
        await this.alertBackupFailure('daily', error);
      }
    });

    // 주간 백업 (매주 일요일 새벽 3시)
    cron.schedule('0 3 * * 0', async () => {
      try {
        await this.performBackup('weekly');
      } catch (error) {
        console.error('Weekly backup failed:', error);
        await this.alertBackupFailure('weekly', error);
      }
    });

    // 월간 백업 (매월 1일 새벽 4시)
    cron.schedule('0 4 1 * *', async () => {
      try {
        await this.performBackup('monthly');
      } catch (error) {
        console.error('Monthly backup failed:', error);
        await this.alertBackupFailure('monthly', error);
      }
    });

    console.log('Backup schedules configured');
  }

  // 백업 실패 알림
  async alertBackupFailure(type, error) {
    const alertingService = require('../monitoring/alerting');

    await alertingService.sendAlert({
      title: 'Database Backup Failed',
      component: 'backup',
      rule: 'backup_failure',
      priority: 'high',
      message: `${type} backup failed: ${error.message}`,
      details: {
        type,
        error: error.stack
      }
    });
  }
}

module.exports = new DatabaseBackupService();

### 11.3.2 재해 복구 계획

#### 재해 복구 전략 (Disaster Recovery Strategy)

```javascript
// disaster-recovery/drPlan.js
class DisasterRecoveryPlan {
  constructor() {
    this.rto = 4 * 60 * 60 * 1000; // Recovery Time Objective: 4시간
    this.rpo = 60 * 60 * 1000;     // Recovery Point Objective: 1시간
    this.healthChecks = new Map();
    this.failoverInProgress = false;
  }

  // DR 계획 초기화
  async initialize() {
    console.log('Initializing Disaster Recovery Plan...');

    // 1. 모든 서비스 헬스체크 설정
    this.setupHealthChecks();

    // 2. 백업 시스템 검증
    await this.verifyBackupSystems();

    // 3. 복구 절차 문서화
    this.documentRecoveryProcedures();

    // 4. 팀 알림 체계 구축
    this.setupAlertingChain();

    console.log('DR Plan initialized successfully');
  }

  // 헬스체크 설정
  setupHealthChecks() {
    const services = [
      {
        name: 'primary-api',
        url: process.env.PRIMARY_API_URL,
        interval: 30000, // 30초
        timeout: 5000,
        retries: 3
      },
      {
        name: 'database',
        checker: this.checkDatabase.bind(this),
        interval: 60000, // 1분
        timeout: 10000,
        retries: 2
      },
      {
        name: 'redis-cache',
        checker: this.checkRedis.bind(this),
        interval: 30000,
        timeout: 3000,
        retries: 3
      },
      {
        name: 'youtube-api',
        checker: this.checkYouTubeAPI.bind(this),
        interval: 300000, // 5분
        timeout: 15000,
        retries: 1
      }
    ];

    services.forEach(service => {
      this.startHealthCheck(service);
    });
  }

  // 개별 헬스체크 시작
  startHealthCheck(service) {
    const check = {
      ...service,
      status: 'unknown',
      lastCheck: null,
      failureCount: 0,
      successCount: 0
    };

    this.healthChecks.set(service.name, check);

    setInterval(async () => {
      await this.performHealthCheck(service);
    }, service.interval);

    // 초기 체크 실행
    this.performHealthCheck(service);
  }

  // 헬스체크 수행
  async performHealthCheck(service) {
    const check = this.healthChecks.get(service.name);
    let isHealthy = false;

    try {
      if (service.url) {
        // URL 기반 헬스체크
        const response = await fetch(service.url, {
          timeout: service.timeout,
          signal: AbortSignal.timeout(service.timeout)
        });
        isHealthy = response.ok;
      } else if (service.checker) {
        // 커스텀 체커
        isHealthy = await service.checker();
      }

      if (isHealthy) {
        check.status = 'healthy';
        check.successCount++;
        check.failureCount = 0;
      } else {
        throw new Error('Health check failed');
      }

    } catch (error) {
      check.failureCount++;

      if (check.failureCount >= service.retries) {
        check.status = 'unhealthy';
        await this.handleServiceFailure(service.name, error);
      } else {
        check.status = 'degraded';
      }
    }

    check.lastCheck = new Date().toISOString();
    this.healthChecks.set(service.name, check);
  }

  // 서비스 장애 처리
  async handleServiceFailure(serviceName, error) {
    console.error(`Service failure detected: ${serviceName}`, error);

    // 장애 유형별 대응
    switch (serviceName) {
      case 'primary-api':
        await this.initiateAPIFailover();
        break;
      case 'database':
        await this.initiateDatabaseFailover();
        break;
      case 'redis-cache':
        await this.handleCacheFailure();
        break;
      case 'youtube-api':
        await this.handleYouTubeAPIFailure();
        break;
    }

    // 팀 알림
    await this.alertTeam({
      severity: 'critical',
      service: serviceName,
      error: error.message,
      action: 'automatic-failover-initiated'
    });
  }

  // API 페일오버
  async initiateAPIFailover() {
    if (this.failoverInProgress) return;

    this.failoverInProgress = true;
    console.log('Initiating API failover...');

    try {
      // 1. 트래픽 라우팅 변경
      await this.updateLoadBalancer({
        primary: false,
        secondary: true
      });

      // 2. DNS 업데이트
      await this.updateDNS({
        record: 'api.ytshorts-curator.com',
        target: process.env.SECONDARY_API_URL
      });

      // 3. 캐시 워밍
      await this.warmSecondaryCache();

      // 4. 헬스체크 확인
      await this.verifyFailover('api');

      console.log('API failover completed successfully');

    } catch (error) {
      console.error('API failover failed:', error);
      await this.initiateManualRecovery('api', error);
    } finally {
      this.failoverInProgress = false;
    }
  }

  // 데이터베이스 페일오버
  async initiateDatabaseFailover() {
    console.log('Initiating database failover...');

    try {
      // 1. 읽기 전용 모드 활성화
      await this.enableReadOnlyMode();

      // 2. 스탠바이 DB 승격
      await this.promoteStandbyDatabase();

      // 3. 연결 문자열 업데이트
      process.env.DATABASE_URL = process.env.STANDBY_DATABASE_URL;

      // 4. 애플리케이션 재시작
      await this.gracefulRestart();

      // 5. 데이터 동기화 확인
      await this.verifyDatabaseSync();

      console.log('Database failover completed');

    } catch (error) {
      console.error('Database failover failed:', error);
      await this.executeEmergencyBackupRestore();
    }
  }

  // 캐시 장애 처리
  async handleCacheFailure() {
    console.log('Handling cache failure...');

    // 1. 캐시 바이패스 모드 활성화
    process.env.CACHE_BYPASS = 'true';

    // 2. 메모리 캐시로 폴백
    const memoryCache = require('../services/memoryCache');
    memoryCache.activate();

    // 3. Redis 클러스터 재구성 시도
    try {
      await this.reconfigureRedisCluster();
    } catch (error) {
      console.error('Redis recovery failed, continuing with memory cache');
    }
  }

  // YouTube API 장애 처리
  async handleYouTubeAPIFailure() {
    console.log('Handling YouTube API failure...');

    // 1. 캐시 전용 모드 활성화
    process.env.CACHE_ONLY_MODE = 'true';

    // 2. 대체 데이터 소스 활성화
    await this.activateAlternativeDataSources();

    // 3. 사용자에게 제한된 기능 알림
    await this.notifyUsersOfDegradedService();
  }

  // 백업 시스템 검증
  async verifyBackupSystems() {
    const backupService = require('./databaseBackup');

    // 1. 최신 백업 확인
    const latestBackup = await backupService.getLatestBackup();
    const backupAge = Date.now() - new Date(latestBackup.created_at).getTime();

    if (backupAge > this.rpo) {
      throw new Error(`Latest backup is too old: ${backupAge / 1000 / 60} minutes`);
    }

    // 2. 백업 무결성 검증
    const isValid = await backupService.verifyBackupIntegrity(latestBackup.id);
    if (!isValid) {
      throw new Error('Latest backup integrity check failed');
    }

    // 3. 복구 테스트 (월 1회)
    if (this.shouldRunRecoveryTest()) {
      await this.runRecoveryTest();
    }
  }

  // 복구 테스트 실행
  async runRecoveryTest() {
    console.log('Running recovery test...');

    const testEnv = process.env.DR_TEST_ENV;

    try {
      // 1. 테스트 환경에 백업 복원
      await this.restoreToTestEnvironment(testEnv);

      // 2. 기능 검증
      await this.verifyFunctionality(testEnv);

      // 3. 성능 벤치마크
      const metrics = await this.runPerformanceBenchmark(testEnv);

      // 4. 결과 보고
      await this.reportRecoveryTestResults({
        success: true,
        duration: metrics.duration,
        rto_achieved: metrics.duration < this.rto
      });

    } catch (error) {
      await this.reportRecoveryTestResults({
        success: false,
        error: error.message
      });
      throw error;
    }
  }

  // 복구 절차 문서화
  documentRecoveryProcedures() {
    const procedures = {
      api_failure: [
        '1. API 헬스체크 실패 확인',
        '2. 로드밸런서에서 장애 인스턴스 제외',
        '3. 대기 인스턴스로 트래픽 라우팅',
        '4. DNS 업데이트 (필요시)',
        '5. 모니터링 대시보드 확인',
        '6. 서비스 정상화 확인'
      ],
      database_failure: [
        '1. 데이터베이스 연결 실패 확인',
        '2. 읽기 전용 모드 전환',
        '3. 스탠바이 DB 상태 확인',
        '4. 스탠바이 DB를 프라이머리로 승격',
        '5. 애플리케이션 연결 문자열 업데이트',
        '6. 데이터 일관성 검증'
      ],
      complete_outage: [
        '1. 모든 서비스 상태 확인',
        '2. 네트워크 연결성 검증',
        '3. 클라우드 제공자 상태 확인',
        '4. DR 사이트 활성화',
        '5. DNS 페일오버 실행',
        '6. 사용자 커뮤니케이션'
      ]
    };

    // 문서를 파일로 저장
    require('fs').writeFileSync(
      './docs/disaster-recovery-procedures.json',
      JSON.stringify(procedures, null, 2)
    );
  }

  // 알림 체계 설정
  setupAlertingChain() {
    this.alertChain = [
      {
        level: 1,
        delay: 0,
        contacts: ['oncall@company.com'],
        method: ['email', 'slack']
      },
      {
        level: 2,
        delay: 15 * 60 * 1000, // 15분
        contacts: ['team-lead@company.com', 'oncall-backup@company.com'],
        method: ['email', 'slack', 'sms']
      },
      {
        level: 3,
        delay: 30 * 60 * 1000, // 30분
        contacts: ['cto@company.com', 'devops-team@company.com'],
        method: ['email', 'slack', 'sms', 'phone']
      }
    ];
  }

  // 팀 알림
  async alertTeam(incident) {
    const startTime = Date.now();

    for (const level of this.alertChain) {
      if (Date.now() - startTime >= level.delay) {
        await this.sendAlerts(level, incident);
      }
    }
  }

  // RTO/RPO 모니터링
  monitorRTORPO() {
    setInterval(async () => {
      const metrics = await this.calculateRecoveryMetrics();

      if (metrics.estimatedRTO > this.rto) {
        await this.alertTeam({
          severity: 'warning',
          message: `Estimated RTO (${metrics.estimatedRTO}ms) exceeds target (${this.rto}ms)`
        });
      }

      if (metrics.currentRPO > this.rpo) {
        await this.alertTeam({
          severity: 'warning',
          message: `Current RPO (${metrics.currentRPO}ms) exceeds target (${this.rpo}ms)`
        });
      }
    }, 60 * 60 * 1000); // 1시간마다
  }

  // 복구 메트릭 계산
  async calculateRecoveryMetrics() {
    const backupService = require('./databaseBackup');
    const latestBackup = await backupService.getLatestBackup();

    return {
      estimatedRTO: this.estimateRecoveryTime(),
      currentRPO: Date.now() - new Date(latestBackup.created_at).getTime(),
      backupSize: latestBackup.size,
      lastTestDate: this.lastRecoveryTest
    };
  }

  // 복구 시간 추정
  estimateRecoveryTime() {
    // 과거 복구 테스트 데이터 기반 추정
    const historicalData = this.getHistoricalRecoveryTimes();
    return historicalData.reduce((a, b) => a + b, 0) / historicalData.length;
  }
}

module.exports = new DisasterRecoveryPlan();

### 11.3.3 롤백 전략

#### 애플리케이션 롤백 시스템

```javascript
// deployment/rollbackStrategy.js
const { execSync } = require('child_process');
const semver = require('semver');

class RollbackStrategy {
  constructor() {
    this.deploymentHistory = [];
    this.maxHistorySize = 10;
    this.rollbackInProgress = false;
    this.healthCheckTimeout = 5 * 60 * 1000; // 5분
  }

  // 배포 기록
  async recordDeployment(deployment) {
    const record = {
      id: deployment.id,
      version: deployment.version,
      timestamp: new Date().toISOString(),
      commit: deployment.commit,
      environment: deployment.environment,
      status: 'in_progress',
      metrics: {
        startTime: Date.now(),
        healthChecks: []
      }
    };

    this.deploymentHistory.unshift(record);

    // 히스토리 크기 제한
    if (this.deploymentHistory.length > this.maxHistorySize) {
      this.deploymentHistory.pop();
    }

    // 데이터베이스에도 저장
    await this.saveDeploymentRecord(record);

    return record;
  }

  // 자동 롤백 모니터링
  async monitorDeployment(deploymentId) {
    const deployment = this.deploymentHistory.find(d => d.id === deploymentId);
    if (!deployment) {
      throw new Error(`Deployment ${deploymentId} not found`);
    }

    console.log(`Monitoring deployment ${deploymentId} for automatic rollback...`);

    const monitoringConfig = {
      errorRateThreshold: 5, // 5% 에러율
      responseTimeThreshold: 2000, // 2초
      availabilityThreshold: 99, // 99% 가용성
      monitoringDuration: 10 * 60 * 1000, // 10분
      checkInterval: 30 * 1000 // 30초
    };

    const endTime = Date.now() + monitoringConfig.monitoringDuration;
    let checksPassedCount = 0;
    let checksFailed = false;

    while (Date.now() < endTime && !checksFailed) {
      const healthStatus = await this.performHealthChecks(deployment);
      deployment.metrics.healthChecks.push(healthStatus);

      // 임계값 체크
      if (healthStatus.errorRate > monitoringConfig.errorRateThreshold ||
          healthStatus.avgResponseTime > monitoringConfig.responseTimeThreshold ||
          healthStatus.availability < monitoringConfig.availabilityThreshold) {

        console.error('Health check failed:', healthStatus);
        checksFailed = true;

        // 자동 롤백 실행
        await this.automaticRollback(deploymentId, healthStatus);

      } else {
        checksPassedCount++;
        console.log(`Health check passed (${checksPassedCount})`);
      }

      if (!checksFailed) {
        await new Promise(resolve => setTimeout(resolve, monitoringConfig.checkInterval));
      }
    }

    // 모니터링 완료
    if (!checksFailed) {
      deployment.status = 'success';
      console.log(`Deployment ${deploymentId} completed successfully`);
    }

    return deployment;
  }

  // 헬스체크 수행
  async performHealthChecks(deployment) {
    const metrics = {
      timestamp: new Date().toISOString(),
      errorRate: 0,
      avgResponseTime: 0,
      availability: 100,
      checks: []
    };

    // 1. API 엔드포인트 체크
    const apiChecks = await this.checkAPIEndpoints();
    metrics.checks.push(...apiChecks);

    // 2. 에러율 계산
    metrics.errorRate = await this.calculateErrorRate();

    // 3. 응답 시간 측정
    metrics.avgResponseTime = await this.measureResponseTime();

    // 4. 가용성 체크
    metrics.availability = await this.checkAvailability();

    // 5. 비즈니스 메트릭 체크
    const businessMetrics = await this.checkBusinessMetrics();
    metrics.businessHealth = businessMetrics;

    return metrics;
  }

  // API 엔드포인트 체크
  async checkAPIEndpoints() {
    const endpoints = [
      { path: '/health', expectedStatus: 200 },
      { path: '/api/videos/trending', expectedStatus: 200 },
      { path: '/api/auth/status', expectedStatus: 200 }
    ];

    const results = await Promise.all(
      endpoints.map(async endpoint => {
        try {
          const response = await fetch(`${process.env.API_URL}${endpoint.path}`);
          return {
            endpoint: endpoint.path,
            status: response.status,
            success: response.status === endpoint.expectedStatus,
            responseTime: response.headers.get('x-response-time')
          };
        } catch (error) {
          return {
            endpoint: endpoint.path,
            success: false,
            error: error.message
          };
        }
      })
    );

    return results;
  }

  // 에러율 계산
  async calculateErrorRate() {
    // 최근 5분간의 에러율 조회
    const query = `
      SELECT
        COUNT(CASE WHEN status_code >= 500 THEN 1 END) * 100.0 / COUNT(*) as error_rate
      FROM api_logs
      WHERE created_at > NOW() - INTERVAL '5 minutes'
    `;

    const result = await this.executeQuery(query);
    return result.rows[0]?.error_rate || 0;
  }

  // 자동 롤백 실행
  async automaticRollback(deploymentId, failureReason) {
    console.error(`Initiating automatic rollback for deployment ${deploymentId}`);

    if (this.rollbackInProgress) {
      console.warn('Rollback already in progress');
      return;
    }

    this.rollbackInProgress = true;

    try {
      // 1. 이전 안정 버전 찾기
      const targetVersion = await this.findLastStableVersion(deploymentId);

      if (!targetVersion) {
        throw new Error('No stable version found for rollback');
      }

      // 2. 알림 발송
      await this.notifyRollback({
        deploymentId,
        targetVersion,
        reason: failureReason,
        type: 'automatic'
      });

      // 3. 롤백 실행
      const rollbackResult = await this.executeRollback(targetVersion);

      // 4. 롤백 검증
      await this.verifyRollback(rollbackResult);

      // 5. 롤백 완료 알림
      await this.notifyRollbackComplete({
        deploymentId,
        targetVersion,
        success: true
      });

      console.log(`Automatic rollback completed successfully to version ${targetVersion.version}`);

    } catch (error) {
      console.error('Automatic rollback failed:', error);

      await this.notifyRollbackComplete({
        deploymentId,
        success: false,
        error: error.message
      });

      // 수동 개입 요청
      await this.requestManualIntervention(deploymentId, error);

    } finally {
      this.rollbackInProgress = false;
    }
  }

  // 수동 롤백
  async manualRollback(targetVersion, reason) {
    console.log(`Initiating manual rollback to version ${targetVersion}`);

    const deployment = {
      id: `rollback-${Date.now()}`,
      version: targetVersion,
      type: 'rollback',
      reason
    };

    await this.recordDeployment(deployment);

    try {
      // Railway를 통한 롤백
      const result = await this.executeRollback({ version: targetVersion });

      deployment.status = 'success';
      return result;

    } catch (error) {
      deployment.status = 'failed';
      deployment.error = error.message;
      throw error;
    }
  }

  // 롤백 실행
  async executeRollback(targetVersion) {
    console.log(`Executing rollback to ${targetVersion.version}`);

    // 1. Railway CLI를 사용한 롤백
    try {
      // 특정 커밋으로 롤백
      execSync(`railway up --detach --commit ${targetVersion.commit}`, {
        stdio: 'inherit'
      });

      // 배포 완료 대기
      await this.waitForDeployment(targetVersion.version);

      return {
        success: true,
        version: targetVersion.version,
        timestamp: new Date().toISOString()
      };

    } catch (error) {
      console.error('Railway rollback failed:', error);

      // 대체 롤백 방법 시도
      return await this.alternativeRollback(targetVersion);
    }
  }

  // 대체 롤백 방법
  async alternativeRollback(targetVersion) {
    console.log('Attempting alternative rollback method...');

    // Docker 이미지 기반 롤백
    const imageName = `ytshorts-curator:${targetVersion.version}`;

    try {
      // 이전 버전의 Docker 이미지로 전환
      execSync(`docker pull ${process.env.DOCKER_REGISTRY}/${imageName}`);
      execSync(`docker tag ${process.env.DOCKER_REGISTRY}/${imageName} ${imageName}`);

      // 컨테이너 재시작
      execSync(`docker-compose down && docker-compose up -d`);

      return {
        success: true,
        method: 'docker',
        version: targetVersion.version
      };

    } catch (error) {
      throw new Error(`Alternative rollback failed: ${error.message}`);
    }
  }

  // 마지막 안정 버전 찾기
  async findLastStableVersion(currentDeploymentId) {
    // 현재 배포 이전의 성공적인 배포 찾기
    const currentIndex = this.deploymentHistory.findIndex(d => d.id === currentDeploymentId);

    for (let i = currentIndex + 1; i < this.deploymentHistory.length; i++) {
      const deployment = this.deploymentHistory[i];

      if (deployment.status === 'success' &&
          deployment.environment === this.deploymentHistory[currentIndex].environment) {

        // 추가 안정성 검증
        const isStable = await this.verifyVersionStability(deployment);
        if (isStable) {
          return deployment;
        }
      }
    }

    return null;
  }

  // 버전 안정성 검증
  async verifyVersionStability(deployment) {
    // 해당 버전이 최소 1시간 이상 안정적으로 운영되었는지 확인
    const runningTime = Date.now() - new Date(deployment.timestamp).getTime();
    const minimumStableTime = 60 * 60 * 1000; // 1시간

    if (runningTime < minimumStableTime) {
      return false;
    }

    // 해당 버전의 에러율 확인
    const errorRate = await this.getVersionErrorRate(deployment.version);
    return errorRate < 1; // 1% 미만
  }

  // 롤백 검증
  async verifyRollback(rollbackResult) {
    console.log('Verifying rollback...');

    const verificationSteps = [
      {
        name: 'Version Check',
        verify: async () => {
          const currentVersion = await this.getCurrentVersion();
          return currentVersion === rollbackResult.version;
        }
      },
      {
        name: 'Health Check',
        verify: async () => {
          const health = await this.performHealthChecks({ version: rollbackResult.version });
          return health.availability >= 99;
        }
      },
      {
        name: 'Database Migration Check',
        verify: async () => {
          return await this.checkDatabaseCompatibility(rollbackResult.version);
        }
      },
      {
        name: 'API Compatibility Check',
        verify: async () => {
          return await this.checkAPICompatibility(rollbackResult.version);
        }
      }
    ];

    for (const step of verificationSteps) {
      console.log(`Running verification: ${step.name}`);
      const passed = await step.verify();

      if (!passed) {
        throw new Error(`Rollback verification failed: ${step.name}`);
      }
    }

    console.log('Rollback verification completed successfully');
  }

  // 데이터베이스 호환성 체크
  async checkDatabaseCompatibility(version) {
    // 버전별 마이그레이션 확인
    const migrations = await this.getDatabaseMigrations();
    const versionMigrations = migrations.filter(m =>
      semver.gt(m.version, version) && m.breaking
    );

    if (versionMigrations.length > 0) {
      console.warn('Breaking database changes detected:', versionMigrations);

      // 롤백 마이그레이션 실행 필요
      for (const migration of versionMigrations) {
        if (migration.rollback) {
          await this.executeMigrationRollback(migration);
        }
      }
    }

    return true;
  }

  // 롤백 알림
  async notifyRollback(details) {
    const message = {
      title: '🔄 Deployment Rollback Initiated',
      type: details.type,
      deployment: details.deploymentId,
      targetVersion: details.targetVersion.version,
      reason: details.reason,
      timestamp: new Date().toISOString()
    };

    // 다중 채널 알림
    await Promise.all([
      this.sendSlackNotification(message),
      this.sendEmailNotification(message),
      this.createIncidentTicket(message)
    ]);
  }

  // 카나리 배포 지원
  async canaryRollback(percentage) {
    console.log(`Initiating canary rollback to ${percentage}% of traffic`);

    try {
      // 로드밸런서 설정 업데이트
      await this.updateLoadBalancerWeights({
        current: 100 - percentage,
        previous: percentage
      });

      // 메트릭 모니터링
      const canaryMetrics = await this.monitorCanaryDeployment(30 * 60 * 1000); // 30분

      if (canaryMetrics.success) {
        // 점진적 롤백 완료
        await this.completeCanaryRollback();
      } else {
        // 전체 롤백
        await this.executeFullRollback();
      }

    } catch (error) {
      console.error('Canary rollback failed:', error);
      throw error;
    }
  }

  // 롤백 히스토리 관리
  async saveRollbackHistory(rollback) {
    const history = {
      ...rollback,
      id: `rollback-${Date.now()}`,
      timestamp: new Date().toISOString()
    };

    await this.supabase
      .from('rollback_history')
      .insert(history);

    return history;
  }
}

module.exports = new RollbackStrategy();

```

## DevOps 통합 예제

```jsx
// server.js - DevOps 통합
const express = require('express');
const app = express();

// DevOps 모듈 임포트
const deploymentManager = require('./scripts/deploy');
const loggingService = require('./config/logging');
const tracingService = require('./config/tracing');
const errorTracking = require('./monitoring/errorTracking');
const alertingService = require('./monitoring/alerting');
const databaseBackup = require('./backup/databaseBackup');
const disasterRecovery = require('./disaster-recovery/drPlan');
const rollbackStrategy = require('./deployment/rollbackStrategy');

// 초기화
async function initializeDevOps() {
  // 로깅 설정
  loggingService.setupExceptionHandlers();
  app.use(loggingService.expressMiddleware());

  // 추적 설정
  tracingService.initialize();
  app.use(tracingService.expressMiddleware());

  // 에러 추적 설정
  errorTracking.initialize(app);
  app.use(errorTracking.requestHandler());
  app.use(errorTracking.errorHandler());

  // 재해 복구 계획 초기화
  await disasterRecovery.initialize();
  disasterRecovery.monitorRTORPO();

  // 백업 스케줄 설정
  databaseBackup.setupBackupSchedule();

  console.log('DevOps systems initialized');
}

// 배포 웹훅 엔드포인트
app.post('/webhook/deploy', async (req, res) => {
  const deployment = {
    id: req.body.deployment_id,
    version: req.body.version,
    commit: req.body.commit,
    environment: req.body.environment
  };

  try {
    // 배포 기록
    const record = await rollbackStrategy.recordDeployment(deployment);

    // 비동기로 모니터링 시작
    rollbackStrategy.monitorDeployment(deployment.id)
      .catch(error => {
        console.error('Deployment monitoring failed:', error);
      });

    res.json({ success: true, deploymentId: record.id });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// 수동 롤백 엔드포인트
app.post('/api/rollback', async (req, res) => {
  try {
    const result = await rollbackStrategy.manualRollback(
      req.body.targetVersion,
      req.body.reason
    );
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// 시스템 상태 대시보드
app.get('/api/system/status', async (req, res) => {
  const status = {
    health: await disasterRecovery.getSystemHealth(),
    backups: await databaseBackup.getBackupStatus(),
    deployments: rollbackStrategy.deploymentHistory.slice(0, 5),
    alerts: await alertingService.getActiveAlerts()
  };

  res.json(status);
});

// 서버 시작
const PORT = process.env.PORT || 3000;
app.listen(PORT, async () => {
  await initializeDevOps();
  console.log(`Server running on port ${PORT} with full DevOps capabilities`);
});

// 정상 종료 처리
process.on('SIGTERM', async () => {
  console.log('SIGTERM received, shutting down gracefully...');

  await tracingService.shutdown();
  await databaseBackup.performBackup('shutdown');

  process.exit(0);
});

```

### 11.3.2 재해 복구 계획

### 재해 복구 전략 (Disaster Recovery Strategy)

```jsx
// disaster-recovery/drPlan.js
class DisasterRecoveryPlan {
  constructor() {
    this.rto = 4 * 60 * 60 * 1000; // Recovery Time Objective: 4시간
    this.rpo = 60 * 60 * 1000;     // Recovery Point Objective: 1시간
    this.healthChecks = new Map();
    this.failoverInProgress = false;
  }

  // DR 계획 초기화
  async initialize() {
    console.log('Initializing Disaster Recovery Plan...');

    // 1. 모든 서비스 헬스체크 설정
    this.setupHealthChecks();

    // 2. 백업 시스템 검증
    await this.verifyBackupSystems();

    // 3. 복구 절차 문서화
    this.documentRecoveryProcedures();

    // 4. 팀 알림 체계 구축
    this.setupAlertingChain();

    console.log('DR Plan initialized successfully');
  }

  // 헬스체크 설정
  setupHealthChecks() {
    const services = [
      {
        name: 'primary-api',
        url: process.env.PRIMARY_API_URL,
        interval: 30000, // 30초
        timeout: 5000,
        retries: 3
      },
      {
        name: 'database',
        checker: this.checkDatabase.bind(this),
        interval: 60000, // 1분
        timeout: 10000,
        retries: 2
      },
      {
        name: 'redis-cache',
        checker: this.checkRedis.bind(this),
        interval: 30000,
        timeout: 3000,
        retries: 3
      },
      {
        name: 'youtube-api',
        checker: this.checkYouTubeAPI.bind(this),
        interval: 300000, // 5분
        timeout: 15000,
        retries: 1
      }
    ];

    services.forEach(service => {
      this.startHealthCheck(service);
    });
  }

  // 개별 헬스체크 시작
  startHealthCheck(service) {
    const check = {
      ...service,
      status: 'unknown',
      lastCheck: null,
      failureCount: 0,
      successCount: 0
    };

    this.healthChecks.set(service.name, check);

    setInterval(async () => {
      await this.performHealthCheck(service);
    }, service.interval);

    // 초기 체크 실행
    this.performHealthCheck(service);
  }

  // 헬스체크 수행
  async performHealthCheck(service) {
    const check = this.healthChecks.get(service.name);
    let isHealthy = false;

    try {
      if (service.url) {
        // URL 기반 헬스체크
        const response = await fetch(service.url, {
          timeout: service.timeout,
          signal: AbortSignal.timeout(service.timeout)
        });
        isHealthy = response.ok;
      } else if (service.checker) {
        // 커스텀 체커
        isHealthy = await service.checker();
      }

      if (isHealthy) {
        check.status = 'healthy';
        check.successCount++;
        check.failureCount = 0;
      } else {
        throw new Error('Health check failed');
      }

    } catch (error) {
      check.failureCount++;

      if (check.failureCount >= service.retries) {
        check.status = 'unhealthy';
        await this.handleServiceFailure(service.name, error);
      } else {
        check.status = 'degraded';
      }
    }

    check.lastCheck = new Date().toISOString();
    this.healthChecks.set(service.name, check);
  }

  // 서비스 장애 처리
  async handleServiceFailure(serviceName, error) {
    console.error(`Service failure detected: ${serviceName}`, error);

    // 장애 유형별 대응
    switch (serviceName) {
      case 'primary-api':
        await this.initiateAPIFailover();
        break;
      case 'database':
        await this.initiateDatabaseFailover();
        break;
      case 'redis-cache':
        await this.handleCacheFailure();
        break;
      case 'youtube-api':
        await this.handleYouTubeAPIFailure();
        break;
    }

    // 팀 알림
    await this.alertTeam({
      severity: 'critical',
      service: serviceName,
      error: error.message,
      action: 'automatic-failover-initiated'
    });
  }

  // API 페일오버
  async initiateAPIFailover() {
    if (this.failoverInProgress) return;

    this.failoverInProgress = true;
    console.log('Initiating API failover...');

    try {
      // 1. 트래픽 라우팅 변경
      await this.updateLoadBalancer({
        primary: false,
        secondary: true
      });

      // 2. DNS 업데이트
      await this.updateDNS({
        record: 'api.ytshorts-curator.com',
        target: process.env.SECONDARY_API_URL
      });

      // 3. 캐시 워밍
      await this.warmSecondaryCache();

      // 4. 헬스체크 확인
      await this.verifyFailover('api');

      console.log('API failover completed successfully');

    } catch (error) {
      console.error('API failover failed:', error);
      await this.initiateManualRecovery('api', error);
    } finally {
      this.failoverInProgress = false;
    }
  }

  // 데이터베이스 페일오버
  async initiateDatabaseFailover() {
    console.log('Initiating database failover...');

    try {
      // 1. 읽기 전용 모드 활성화
      await this.enableReadOnlyMode();

      // 2. 스탠바이 DB 승격
      await this.promoteStandbyDatabase();

      // 3. 연결 문자열 업데이트
      process.env.DATABASE_URL = process.env.STANDBY_DATABASE_URL;

      // 4. 애플리케이션 재시작
      await this.gracefulRestart();

      // 5. 데이터 동기화 확인
      await this.verifyDatabaseSync();

      console.log('Database failover completed');

    } catch (error) {
      console.error('Database failover failed:', error);
      await this.executeEmergencyBackupRestore();
    }
  }

  // 캐시 장애 처리
  async handleCacheFailure() {
    console.log('Handling cache failure...');

    // 1. 캐시 바이패스 모드 활성화
    process.env.CACHE_BYPASS = 'true';

    // 2. 메모리 캐시로 폴백
    const memoryCache = require('../services/memoryCache');
    memoryCache.activate();

    // 3. Redis 클러스터 재구성 시도
    try {
      await this.reconfigureRedisCluster();
    } catch (error) {
      console.error('Redis recovery failed, continuing with memory cache');
    }
  }

  // YouTube API 장애 처리
  async handleYouTubeAPIFailure() {
    console.log('Handling YouTube API failure...');

    // 1. 캐시 전용 모드 활성화
    process.env.CACHE_ONLY_MODE = 'true';

    // 2. 대체 데이터 소스 활성화
    await this.activateAlternativeDataSources();

    // 3. 사용자에게 제한된 기능 알림
    await this.notifyUsersOfDegradedService();
  }

  // 백업 시스템 검증
  async verifyBackupSystems() {
    const backupService = require('./databaseBackup');

    // 1. 최신 백업 확인
    const latestBackup = await backupService.getLatestBackup();
    const backupAge = Date.now() - new Date(latestBackup.created_at).getTime();

    if (backupAge > this.rpo) {
      throw new Error(`Latest backup is too old: ${backupAge / 1000 / 60} minutes`);
    }

    // 2. 백업 무결성 검증
    const isValid = await backupService.verifyBackupIntegrity(latestBackup.id);
    if (!isValid) {
      throw new Error('Latest backup integrity check failed');
    }

    // 3. 복구 테스트 (월 1회)
    if (this.shouldRunRecoveryTest()) {
      await this.runRecoveryTest();
    }
  }

  // 복구 테스트 실행
  async runRecoveryTest() {
    console.log('Running recovery test...');

    const testEnv = process.env.DR_TEST_ENV;

    try {
      // 1. 테스트 환경에 백업 복원
      await this.restoreToTestEnvironment(testEnv);

      // 2. 기능 검증
      await this.verifyFunctionality(testEnv);

      // 3. 성능 벤치마크
      const metrics = await this.runPerformanceBenchmark(testEnv);

      // 4. 결과 보고
      await this.reportRecoveryTestResults({
        success: true,
        duration: metrics.duration,
        rto_achieved: metrics.duration < this.rto
      });

    } catch (error) {
      await this.reportRecoveryTestResults({
        success: false,
        error: error.message
      });
      throw error;
    }
  }

  // 복구 절차 문서화
  documentRecoveryProcedures() {
    const procedures = {
      api_failure: [
        '1. API 헬스체크 실패 확인',
        '2. 로드밸런서에서 장애 인스턴스 제외',
        '3. 대기 인스턴스로 트래픽 라우팅',
        '4. DNS 업데이트 (필요시)',
        '5. 모니터링 대시보드 확인',
        '6. 서비스 정상화 확인'
      ],
      database_failure: [
        '1. 데이터베이스 연결 실패 확인',
        '2. 읽기 전용 모드 전환',
        '3. 스탠바이 DB 상태 확인',
        '4. 스탠바이 DB를 프라이머리로 승격',
        '5. 애플리케이션 연결 문자열 업데이트',
        '6. 데이터 일관성 검증'
      ],
      complete_outage: [
        '1. 모든 서비스 상태 확인',
        '2. 네트워크 연결성 검증',
        '3. 클라우드 제공자 상태 확인',
        '4. DR 사이트 활성화',
        '5. DNS 페일오버 실행',
        '6. 사용자 커뮤니케이션'
      ]
    };

    // 문서를 파일로 저장
    require('fs').writeFileSync(
      './docs/disaster-recovery-procedures.json',
      JSON.stringify(procedures, null, 2)
    );
  }

  // 알림 체계 설정
  setupAlertingChain() {
    this.alertChain = [
      {
        level: 1,
        delay: 0,
        contacts: ['oncall@company.com'],
        method: ['email', 'slack']
      },
      {
        level: 2,
        delay: 15 * 60 * 1000, // 15분
        contacts: ['team-lead@company.com', 'oncall-backup@company.com'],
        method: ['email', 'slack', 'sms']
      },
      {
        level: 3,
        delay: 30 * 60 * 1000, // 30분
        contacts: ['cto@company.com', 'devops-team@company.com'],
        method: ['email', 'slack', 'sms', 'phone']
      }
    ];
  }

  // 팀 알림
  async alertTeam(incident) {
    const startTime = Date.now();

    for (const level of this.alertChain) {
      if (Date.now() - startTime >= level.delay) {
        await this.sendAlerts(level, incident);
      }
    }
  }

  // RTO/RPO 모니터링
  monitorRTORPO() {
    setInterval(async () => {
      const metrics = await this.calculateRecoveryMetrics();

      if (metrics.estimatedRTO > this.rto) {
        await this.alertTeam({
          severity: 'warning',
          message: `Estimated RTO (${metrics.estimatedRTO}ms) exceeds target (${this.rto}ms)`
        });
      }

      if (metrics.currentRPO > this.rpo) {
        await this.alertTeam({
          severity: 'warning',
          message: `Current RPO (${metrics.currentRPO}ms) exceeds target (${this.rpo}ms)`
        });
      }
    }, 60 * 60 * 1000); // 1시간마다
  }

  // 복구 메트릭 계산
  async calculateRecoveryMetrics() {
    const backupService = require('./databaseBackup');
    const latestBackup = await backupService.getLatestBackup();

    return {
      estimatedRTO: this.estimateRecoveryTime(),
      currentRPO: Date.now() - new Date(latestBackup.created_at).getTime(),
      backupSize: latestBackup.size,
      lastTestDate: this.lastRecoveryTest
    };
  }

  // 복구 시간 추정
  estimateRecoveryTime() {
    // 과거 복구 테스트 데이터 기반 추정
    const historicalData = this.getHistoricalRecoveryTimes();
    return historicalData.reduce((a, b) => a + b, 0) / historicalData.length;
  }
}

module.exports = new DisasterRecoveryPlan();

```

### 11.3.3 롤백 전략

### 애플리케이션 롤백 시스템

```jsx
// deployment/rollbackStrategy.js
const { execSync } = require('child_process');
const semver = require('semver');

class RollbackStrategy {
  constructor() {
    this.deploymentHistory = [];
    this.maxHistorySize = 10;
    this.rollbackInProgress = false;
    this.healthCheckTimeout = 5 * 60 * 1000; // 5분
  }

  // 배포 기록
  async recordDeployment(deployment) {
    const record = {
      id: deployment.id,
      version: deployment.version,
      timestamp: new Date().toISOString(),
      commit: deployment.commit,
      environment: deployment.environment,
      status: 'in_progress',
      metrics: {
        startTime: Date.now(),
        healthChecks: []
      }
    };

    this.deploymentHistory.unshift(record);

    // 히스토리 크기 제한
    if (this.deploymentHistory.length > this.maxHistorySize) {
      this.deploymentHistory.pop();
    }

    // 데이터베이스에도 저장
    await this.saveDeploymentRecord(record);

    return record;
  }

  // 자동 롤백 모니터링
  async monitorDeployment(deploymentId) {
    const deployment = this.deploymentHistory.find(d => d.id === deploymentId);
    if (!deployment) {
      throw new Error(`Deployment ${deploymentId} not found`);
    }

    console.log(`Monitoring deployment ${deploymentId} for automatic rollback...`);

    const monitoringConfig = {
      errorRateThreshold: 5, // 5% 에러율
      responseTimeThreshold: 2000, // 2초
      availabilityThreshold: 99, // 99% 가용성
      monitoringDuration: 10 * 60 * 1000, // 10분
      checkInterval: 30 * 1000 // 30초
    };

    const endTime = Date.now() + monitoringConfig.monitoringDuration;
    let checksPassedCount = 0;
    let checksFailed = false;

    while (Date.now() < endTime && !checksFailed) {
      const healthStatus = await this.performHealthChecks(deployment);
      deployment.metrics.healthChecks.push(healthStatus);

      // 임계값 체크
      if (healthStatus.errorRate > monitoringConfig.errorRateThreshold ||
          healthStatus.avgResponseTime > monitoringConfig.responseTimeThreshold ||
          healthStatus.availability < monitoringConfig.availabilityThreshold) {

        console.error('Health check failed:', healthStatus);
        checksFailed = true;

        // 자동 롤백 실행
        await this.automaticRollback(deploymentId, healthStatus);

      } else {
        checksPassedCount++;
        console.log(`Health check passed (${checksPassedCount})`);
      }

      if (!checksFailed) {
        await new Promise(resolve => setTimeout(resolve, monitoringConfig.checkInterval));
      }
    }

    // 모니터링 완료
    if (!checksFailed) {
      deployment.status = 'success';
      console.log(`Deployment ${deploymentId} completed successfully`);
    }

    return deployment;
  }

  // 헬스체크 수행
  async performHealthChecks(deployment) {
    const metrics = {
      timestamp: new Date().toISOString(),
      errorRate: 0,
      avgResponseTime: 0,
      availability: 100,
      checks: []
    };

    // 1. API 엔드포인트 체크
    const apiChecks = await this.checkAPIEndpoints();
    metrics.checks.push(...apiChecks);

    // 2. 에러율 계산
    metrics.errorRate = await this.calculateErrorRate();

    // 3. 응답 시간 측정
    metrics.avgResponseTime = await this.measureResponseTime();

    // 4. 가용성 체크
    metrics.availability = await this.checkAvailability();

    // 5. 비즈니스 메트릭 체크
    const businessMetrics = await this.checkBusinessMetrics();
    metrics.businessHealth = businessMetrics;

    return metrics;
  }

  // API 엔드포인트 체크
  async checkAPIEndpoints() {
    const endpoints = [
      { path: '/health', expectedStatus: 200 },
      { path: '/api/videos/trending', expectedStatus: 200 },
      { path: '/api/auth/status', expectedStatus: 200 }
    ];

    const results = await Promise.all(
      endpoints.map(async endpoint => {
        try {
          const response = await fetch(`${process.env.API_URL}${endpoint.path}`);
          return {
            endpoint: endpoint.path,
            status: response.status,
            success: response.status === endpoint.expectedStatus,
            responseTime: response.headers.get('x-response-time')
          };
        } catch (error) {
          return {
            endpoint: endpoint.path,
            success: false,
            error: error.message
          };
        }
      })
    );

    return results;
  }

  // 에러율 계산
  async calculateErrorRate() {
    // 최근 5분간의 에러율 조회
    const query = `
      SELECT
        COUNT(CASE WHEN status_code >= 500 THEN 1 END) * 100.0 / COUNT(*) as error_rate
      FROM api_logs
      WHERE created_at > NOW() - INTERVAL '5 minutes'
    `;

    const result = await this.executeQuery(query);
    return result.rows[0]?.error_rate || 0;
  }

  // 자동 롤백 실행
  async automaticRollback(deploymentId, failureReason) {
    console.error(`Initiating automatic rollback for deployment ${deploymentId}`);

    if (this.rollbackInProgress) {
      console.warn('Rollback already in progress');
      return;
    }

    this.rollbackInProgress = true;

    try {
      // 1. 이전 안정 버전 찾기
      const targetVersion = await this.findLastStableVersion(deploymentId);

      if (!targetVersion) {
        throw new Error('No stable version found for rollback');
      }

      // 2. 알림 발송
      await this.notifyRollback({
        deploymentId,
        targetVersion,
        reason: failureReason,
        type: 'automatic'
      });

      // 3. 롤백 실행
      const rollbackResult = await this.executeRollback(targetVersion);

      // 4. 롤백 검증
      await this.verifyRollback(rollbackResult);

      // 5. 롤백 완료 알림
      await this.notifyRollbackComplete({
        deploymentId,
        targetVersion,
        success: true
      });

      console.log(`Automatic rollback completed successfully to version ${targetVersion.version}`);

    } catch (error) {
      console.error('Automatic rollback failed:', error);

      await this.notifyRollbackComplete({
        deploymentId,
        success: false,
        error: error.message
      });

      // 수동 개입 요청
      await this.requestManualIntervention(deploymentId, error);

    } finally {
      this.rollbackInProgress = false;
    }
  }

  // 수동 롤백
  async manualRollback(targetVersion, reason) {
    console.log(`Initiating manual rollback to version ${targetVersion}`);

    const deployment = {
      id: `rollback-${Date.now()}`,
      version: targetVersion,
      type: 'rollback',
      reason
    };

    await this.recordDeployment(deployment);

    try {
      // Railway를 통한 롤백
      const result = await this.executeRollback({ version: targetVersion });

      deployment.status = 'success';
      return result;

    } catch (error) {
      deployment.status = 'failed';
      deployment.error = error.message;
      throw error;
    }
  }

  // 롤백 실행
  async executeRollback(targetVersion) {
    console.log(`Executing rollback to ${targetVersion.version}`);

    // 1. Railway CLI를 사용한 롤백
    try {
      // 특정 커밋으로 롤백
      execSync(`railway up --detach --commit ${targetVersion.commit}`, {
        stdio: 'inherit'
      });

      // 배포 완료 대기
      await this.waitForDeployment(targetVersion.version);

      return {
        success: true,
        version: targetVersion.version,
        timestamp: new Date().toISOString()
      };

    } catch (error) {
      console.error('Railway rollback failed:', error);

      // 대체 롤백 방법 시도
      return await this.alternativeRollback(targetVersion);
    }
  }

  // 대체 롤백 방법
  async alternativeRollback(targetVersion) {
    console.log('Attempting alternative rollback method...');

    // Docker 이미지 기반 롤백
    const imageName = `ytshorts-curator:${targetVersion.version}`;

    try {
      // 이전 버전의 Docker 이미지로 전환
      execSync(`docker pull ${process.env.DOCKER_REGISTRY}/${imageName}`);
      execSync(`docker tag ${process.env.DOCKER_REGISTRY}/${imageName} ${imageName}`);

      // 컨테이너 재시작
      execSync(`docker-compose down && docker-compose up -d`);

      return {
        success: true,
        method: 'docker',
        version: targetVersion.version
      };

    } catch (error) {
      throw new Error(`Alternative rollback failed: ${error.message}`);
    }
  }

  // 마지막 안정 버전 찾기
  async findLastStableVersion(currentDeploymentId) {
    // 현재 배포 이전의 성공적인 배포 찾기
    const currentIndex = this.deploymentHistory.findIndex(d => d.id === currentDeploymentId);

    for (let i = currentIndex + 1; i < this.deploymentHistory.length; i++) {
      const deployment = this.deploymentHistory[i];

      if (deployment.status === 'success' &&
          deployment.environment === this.deploymentHistory[currentIndex].environment) {

        // 추가 안정성 검증
        const isStable = await this.verifyVersionStability(deployment);
        if (isStable) {
          return deployment;
        }
      }
    }

    return null;
  }

  // 버전 안정성 검증
  async verifyVersionStability(deployment) {
    // 해당 버전이 최소 1시간 이상 안정적으로 운영되었는지 확인
    const runningTime = Date.now() - new Date(deployment.timestamp).getTime();
    const minimumStableTime = 60 * 60 * 1000; // 1시간

    if (runningTime < minimumStableTime) {
      return false;
    }

    // 해당 버전의 에러율 확인
    const errorRate = await this.getVersionErrorRate(deployment.version);
    return errorRate < 1; // 1% 미만
  }

  // 롤백 검증
  async verifyRollback(rollbackResult) {
    console.log('Verifying rollback...');

    const verificationSteps = [
      {
        name: 'Version Check',
        verify: async () => {
          const currentVersion = await this.getCurrentVersion();
          return currentVersion === rollbackResult.version;
        }
      },
      {
        name: 'Health Check',
        verify: async () => {
          const health = await this.performHealthChecks({ version: rollbackResult.version });
          return health.availability >= 99;
        }
      },
      {
        name: 'Database Migration Check',
        verify: async () => {
          return await this.checkDatabaseCompatibility(rollbackResult.version);
        }
      },
      {
        name: 'API Compatibility Check',
        verify: async () => {
          return await this.checkAPICompatibility(rollbackResult.version);
        }
      }
    ];

    for (const step of verificationSteps) {
      console.log(`Running verification: ${step.name}`);
      const passed = await step.verify();

      if (!passed) {
        throw new Error(`Rollback verification failed: ${step.name}`);
      }
    }

    console.log('Rollback verification completed successfully');
  }

  // 데이터베이스 호환성 체크
  async checkDatabaseCompatibility(version) {
    // 버전별 마이그레이션 확인
    const migrations = await this.getDatabaseMigrations();
    const versionMigrations = migrations.filter(m =>
      semver.gt(m.version, version) && m.breaking
    );

    if (versionMigrations.length > 0) {
      console.warn('Breaking database changes detected:', versionMigrations);

      // 롤백 마이그레이션 실행 필요
      for (const migration of versionMigrations) {
        if (migration.rollback) {
          await this.executeMigrationRollback(migration);
        }
      }
    }

    return true;
  }

  // 롤백 알림
  async notifyRollback(details) {
    const message = {
      title: '🔄 Deployment Rollback Initiated',
      type: details.type,
      deployment: details.deploymentId,
      targetVersion: details.targetVersion.version,
      reason: details.reason,
      timestamp: new Date().toISOString()
    };

    // 다중 채널 알림
    await Promise.all([
      this.sendSlackNotification(message),
      this.sendEmailNotification(message),
      this.createIncidentTicket(message)
    ]);
  }

  // 카나리 배포 지원
  async canaryRollback(percentage) {
    console.log(`Initiating canary rollback to ${percentage}% of traffic`);

    try {
      // 로드밸런서 설정 업데이트
      await this.updateLoadBalancerWeights({
        current: 100 - percentage,
        previous: percentage
      });

      // 메트릭 모니터링
      const canaryMetrics = await this.monitorCanaryDeployment(30 * 60 * 1000); // 30분

      if (canaryMetrics.success) {
        // 점진적 롤백 완료
        await this.completeCanaryRollback();
      } else {
        // 전체 롤백
        await this.executeFullRollback();
      }

    } catch (error) {
      console.error('Canary rollback failed:', error);
      throw error;
    }
  }

  // 롤백 히스토리 관리
  async saveRollbackHistory(rollback) {
    const history = {
      ...rollback,
      id: `rollback-${Date.now()}`,
      timestamp: new Date().toISOString()
    };

    await this.supabase
      .from('rollback_history')
      .insert(history);

    return history;
  }
}

module.exports = new RollbackStrategy();

```

## DevOps 통합 예제

```jsx
// server.js - DevOps 통합
const express = require('express');
const app = express();

// DevOps 모듈 임포트
const deploymentManager = require('./scripts/deploy');
const loggingService = require('./config/logging');
const tracingService = require('./config/tracing');
const errorTracking = require('./monitoring/errorTracking');
const alertingService = require('./monitoring/alerting');
const databaseBackup = require('./backup/databaseBackup');
const disasterRecovery = require('./disaster-recovery/drPlan');
const rollbackStrategy = require('./deployment/rollbackStrategy');

// 초기화
async function initializeDevOps() {
  // 로깅 설정
  loggingService.setupExceptionHandlers();
  app.use(loggingService.expressMiddleware());

  // 추적 설정
  tracingService.initialize();
  app.use(tracingService.expressMiddleware());

  // 에러 추적 설정
  errorTracking.initialize(app);
  app.use(errorTracking.requestHandler());
  app.use(errorTracking.errorHandler());

  // 재해 복구 계획 초기화
  await disasterRecovery.initialize();
  disasterRecovery.monitorRTORPO();

  // 백업 스케줄 설정
  databaseBackup.setupBackupSchedule();

  console.log('DevOps systems initialized');
}

// 배포 웹훅 엔드포인트
app.post('/webhook/deploy', async (req, res) => {
  const deployment = {
    id: req.body.deployment_id,
    version: req.body.version,
    commit: req.body.commit,
    environment: req.body.environment
  };

  try {
    // 배포 기록
    const record = await rollbackStrategy.recordDeployment(deployment);

    // 비동기로 모니터링 시작
    rollbackStrategy.monitorDeployment(deployment.id)
      .catch(error => {
        console.error('Deployment monitoring failed:', error);
      });

    res.json({ success: true, deploymentId: record.id });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// 수동 롤백 엔드포인트
app.post('/api/rollback', async (req, res) => {
  try {
    const result = await rollbackStrategy.manualRollback(
      req.body.targetVersion,
      req.body.reason
    );
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// 시스템 상태 대시보드
app.get('/api/system/status', async (req, res) => {
  const status = {
    health: await disasterRecovery.getSystemHealth(),
    backups: await databaseBackup.getBackupStatus(),
    deployments: rollbackStrategy.deploymentHistory.slice(0, 5),
    alerts: await alertingService.getActiveAlerts()
  };

  res.json(status);
});

// 서버 시작
const PORT = process.env.PORT || 3000;
app.listen(PORT, async () => {
  await initializeDevOps();
  console.log(`Server running on port ${PORT} with full DevOps capabilities`);
});

// 정상 종료 처리
process.on('SIGTERM', async () => {
  console.log('SIGTERM received, shutting down gracefully...');

  await tracingService.shutdown();
  await databaseBackup.performBackup('shutdown');

  process.exit(0);
});

```

### 11.3.2 재해 복구 계획

### 재해 복구 전략 (Disaster Recovery Strategy)

```jsx
// disaster-recovery/drPlan.js
class DisasterRecoveryPlan {
  constructor() {
    this.rto = 4 * 60 * 60 * 1000; // Recovery Time Objective: 4시간
    this.rpo = 60 * 60 * 1000;     // Recovery Point Objective: 1시간
    this.healthChecks = new Map();
    this.failoverInProgress = false;
  }

  // DR 계획 초기화
  async initialize() {
    console.log('Initializing Disaster Recovery Plan...');

    // 1. 모든 서비스 헬스체크 설정
    this.setupHealthChecks();

    // 2. 백업 시스템 검증
    await this.verifyBackupSystems();

    // 3. 복구 절차 문서화
    this.documentRecoveryProcedures();

    // 4. 팀 알림 체계 구축
    this.setupAlertingChain();

    console.log('DR Plan initialized successfully');
  }

  // 헬스체크 설정
  setupHealthChecks() {
    const services = [
      {
        name: 'primary-api',
        url: process.env.PRIMARY_API_URL,
        interval: 30000, // 30초
        timeout: 5000,
        retries: 3
      },
      {
        name: 'database',
        checker: this.checkDatabase.bind(this),
        interval: 60000, // 1분
        timeout: 10000,
        retries: 2
      },
      {
        name: 'redis-cache',
        checker: this.checkRedis.bind(this),
        interval: 30000,
        timeout: 3000,
        retries: 3
      },
      {
        name: 'youtube-api',
        checker: this.checkYouTubeAPI.bind(this),
        interval: 300000, // 5분
        timeout: 15000,
        retries: 1
      }
    ];

    services.forEach(service => {
      this.startHealthCheck(service);
    });
  }

  // 개별 헬스체크 시작
  startHealthCheck(service) {
    const check = {
      ...service,
      status: 'unknown',
      lastCheck: null,
      failureCount: 0,
      successCount: 0
    };

    this.healthChecks.set(service.name, check);

    setInterval(async () => {
      await this.performHealthCheck(service);
    }, service.interval);

    // 초기 체크 실행
    this.performHealthCheck(service);
  }

  // 헬스체크 수행
  async performHealthCheck(service) {
    const check = this.healthChecks.get(service.name);
    let isHealthy = false;

    try {
      if (service.url) {
        // URL 기반 헬스체크
        const response = await fetch(service.url, {
          timeout: service.timeout,
          signal: AbortSignal.timeout(service.timeout)
        });
        isHealthy = response.ok;
      } else if (service.checker) {
        // 커스텀 체커
        isHealthy = await service.checker();
      }

      if (isHealthy) {
        check.status = 'healthy';
        check.successCount++;
        check.failureCount = 0;
      } else {
        throw new Error('Health check failed');
      }

    } catch (error) {
      check.failureCount++;

      if (check.failureCount >= service.retries) {
        check.status = 'unhealthy';
        await this.handleServiceFailure(service.name, error);
      } else {
        check.status = 'degraded';
      }
    }

    check.lastCheck = new Date().toISOString();
    this.healthChecks.set(service.name, check);
  }

  // 서비스 장애 처리
  async handleServiceFailure(serviceName, error) {
    console.error(`Service failure detected: ${serviceName}`, error);

    // 장애 유형별 대응
    switch (serviceName) {
      case 'primary-api':
        await this.initiateAPIFailover();
        break;
      case 'database':
        await this.initiateDatabaseFailover();
        break;
      case 'redis-cache':
        await this.handleCacheFailure();
        break;
      case 'youtube-api':
        await this.handleYouTubeAPIFailure();
        break;
    }

    // 팀 알림
    await this.alertTeam({
      severity: 'critical',
      service: serviceName,
      error: error.message,
      action: 'automatic-failover-initiated'
    });
  }

  // API 페일오버
  async initiateAPIFailover() {
    if (this.failoverInProgress) return;

    this.failoverInProgress = true;
    console.log('Initiating API failover...');

    try {
      // 1. 트래픽 라우팅 변경
      await this.updateLoadBalancer({
        primary: false,
        secondary: true
      });

      // 2. DNS 업데이트
      await this.updateDNS({
        record: 'api.ytshorts-curator.com',
        target: process.env.SECONDARY_API_URL
      });

      // 3. 캐시 워밍
      await this.warmSecondaryCache();

      // 4. 헬스체크 확인
      await this.verifyFailover('api');

      console.log('API failover completed successfully');

    } catch (error) {
      console.error('API failover failed:', error);
      await this.initiateManualRecovery('api', error);
    } finally {
      this.failoverInProgress = false;
    }
  }

  // 데이터베이스 페일오버
  async initiateDatabaseFailover() {
    console.log('Initiating database failover...');

    try {
      // 1. 읽기 전용 모드 활성화
      await this.enableReadOnlyMode();

      // 2. 스탠바이 DB 승격
      await this.promoteStandbyDatabase();

      // 3. 연결 문자열 업데이트
      process.env.DATABASE_URL = process.env.STANDBY_DATABASE_URL;

      // 4. 애플리케이션 재시작
      await this.gracefulRestart();

      // 5. 데이터 동기화 확인
      await this.verifyDatabaseSync();

      console.log('Database failover completed');

    } catch (error) {
      console.error('Database failover failed:', error);
      await this.executeEmergencyBackupRestore();
    }
  }

  // 캐시 장애 처리
  async handleCacheFailure() {
    console.log('Handling cache failure...');

    // 1. 캐시 바이패스 모드 활성화
    process.env.CACHE_BYPASS = 'true';

    // 2. 메모리 캐시로 폴백
    const memoryCache = require('../services/memoryCache');
    memoryCache.activate();

    // 3. Redis 클러스터 재구성 시도
    try {
      await this.reconfigureRedisCluster();
    } catch (error) {
      console.error('Redis recovery failed, continuing with memory cache');
    }
  }

  // YouTube API 장애 처리
  async handleYouTubeAPIFailure() {
    console.log('Handling YouTube API failure...');

    // 1. 캐시 전용 모드 활성화
    process.env.CACHE_ONLY_MODE = 'true';

    // 2. 대체 데이터 소스 활성화
    await this.activateAlternativeDataSources();

    // 3. 사용자에게 제한된 기능 알림
    await this.notifyUsersOfDegradedService();
  }

  // 백업 시스템 검증
  async verifyBackupSystems() {
    const backupService = require('./databaseBackup');

    // 1. 최신 백업 확인
    const latestBackup = await backupService.getLatestBackup();
    const backupAge = Date.now() - new Date(latestBackup.created_at).getTime();

    if (backupAge > this.rpo) {
      throw new Error(`Latest backup is too old: ${backupAge / 1000 / 60} minutes`);
    }

    // 2. 백업 무결성 검증
    const isValid = await backupService.verifyBackupIntegrity(latestBackup.id);
    if (!isValid) {
      throw new Error('Latest backup integrity check failed');
    }

    // 3. 복구 테스트 (월 1회)
    if (this.shouldRunRecoveryTest()) {
      await this.runRecoveryTest();
    }
  }

  // 복구 테스트 실행
  async runRecoveryTest() {
    console.log('Running recovery test...');

    const testEnv = process.env.DR_TEST_ENV;

    try {
      // 1. 테스트 환경에 백업 복원
      await this.restoreToTestEnvironment(testEnv);

      // 2. 기능 검증
      await this.verifyFunctionality(testEnv);

      // 3. 성능 벤치마크
      const metrics = await this.runPerformanceBenchmark(testEnv);

      // 4. 결과 보고
      await this.reportRecoveryTestResults({
        success: true,
        duration: metrics.duration,
        rto_achieved: metrics.duration < this.rto
      });

    } catch (error) {
      await this.reportRecoveryTestResults({
        success: false,
        error: error.message
      });
      throw error;
    }
  }

  // 복구 절차 문서화
  documentRecoveryProcedures() {
    const procedures = {
      api_failure: [
        '1. API 헬스체크 실패 확인',
        '2. 로드밸런서에서 장애 인스턴스 제외',
        '3. 대기 인스턴스로 트래픽 라우팅',
        '4. DNS 업데이트 (필요시)',
        '5. 모니터링 대시보드 확인',
        '6. 서비스 정상화 확인'
      ],
      database_failure: [
        '1. 데이터베이스 연결 실패 확인',
        '2. 읽기 전용 모드 전환',
        '3. 스탠바이 DB 상태 확인',
        '4. 스탠바이 DB를 프라이머리로 승격',
        '5. 애플리케이션 연결 문자열 업데이트',
        '6. 데이터 일관성 검증'
      ],
      complete_outage: [
        '1. 모든 서비스 상태 확인',
        '2. 네트워크 연결성 검증',
        '3. 클라우드 제공자 상태 확인',
        '4. DR 사이트 활성화',
        '5. DNS 페일오버 실행',
        '6. 사용자 커뮤니케이션'
      ]
    };

    // 문서를 파일로 저장
    require('fs').writeFileSync(
      './docs/disaster-recovery-procedures.json',
      JSON.stringify(procedures, null, 2)
    );
  }

  // 알림 체계 설정
  setupAlertingChain() {
    this.alertChain = [
      {
        level: 1,
        delay: 0,
        contacts: ['oncall@company.com'],
        method: ['email', 'slack']
      },
      {
        level: 2,
        delay: 15 * 60 * 1000, // 15분
        contacts: ['team-lead@company.com', 'oncall-backup@company.com'],
        method: ['email', 'slack', 'sms']
      },
      {
        level: 3,
        delay: 30 * 60 * 1000, // 30분
        contacts: ['cto@company.com', 'devops-team@company.com'],
        method: ['email', 'slack', 'sms', 'phone']
      }
    ];
  }

  // 팀 알림
  async alertTeam(incident) {
    const startTime = Date.now();

    for (const level of this.alertChain) {
      if (Date.now() - startTime >= level.delay) {
        await this.sendAlerts(level, incident);
      }
    }
  }

  // RTO/RPO 모니터링
  monitorRTORPO() {
    setInterval(async () => {
      const metrics = await this.calculateRecoveryMetrics();

      if (metrics.estimatedRTO > this.rto) {
        await this.alertTeam({
          severity: 'warning',
          message: `Estimated RTO (${metrics.estimatedRTO}ms) exceeds target (${this.rto}ms)`
        });
      }

      if (metrics.currentRPO > this.rpo) {
        await this.alertTeam({
          severity: 'warning',
          message: `Current RPO (${metrics.currentRPO}ms) exceeds target (${this.rpo}ms)`
        });
      }
    }, 60 * 60 * 1000); // 1시간마다
  }

  // 복구 메트릭 계산
  async calculateRecoveryMetrics() {
    const backupService = require('./databaseBackup');
    const latestBackup = await backupService.getLatestBackup();

    return {
      estimatedRTO: this.estimateRecoveryTime(),
      currentRPO: Date.now() - new Date(latestBackup.created_at).getTime(),
      backupSize: latestBackup.size,
      lastTestDate: this.lastRecoveryTest
    };
  }

  // 복구 시간 추정
  estimateRecoveryTime() {
    // 과거 복구 테스트 데이터 기반 추정
    const historicalData = this.getHistoricalRecoveryTimes();
    return historicalData.reduce((a, b) => a + b, 0) / historicalData.length;
  }
}

module.exports = new DisasterRecoveryPlan();

```

### 11.3.3 롤백 전략

### 애플리케이션 롤백 시스템

```jsx
// deployment/rollbackStrategy.js
const { execSync } = require('child_process');
const semver = require('semver');

class RollbackStrategy {
  constructor() {
    this.deploymentHistory = [];
    this.maxHistorySize = 10;
    this.rollbackInProgress = false;
    this.healthCheckTimeout = 5 * 60 * 1000; // 5분
  }

  // 배포 기록
  async recordDeployment(deployment) {
    const record = {
      id: deployment.id,
      version: deployment.version,
      timestamp: new Date().toISOString(),
      commit: deployment.commit,
      environment: deployment.environment,
      status: 'in_progress',
      metrics: {
        startTime: Date.now(),
        healthChecks: []
      }
    };

    this.deploymentHistory.unshift(record);

    // 히스토리 크기 제한
    if (this.deploymentHistory.length > this.maxHistorySize) {
      this.deploymentHistory.pop();
    }

    // 데이터베이스에도 저장
    await this.saveDeploymentRecord(record);

    return record;
  }

  // 자동 롤백 모니터링
  async monitorDeployment(deploymentId) {
    const deployment = this.deploymentHistory.find(d => d.id === deploymentId);
    if (!deployment) {
      throw new Error(`Deployment ${deploymentId} not found`);
    }

    console.log(`Monitoring deployment ${deploymentId} for automatic rollback...`);

    const monitoringConfig = {
      errorRateThreshold: 5, // 5% 에러율
      responseTimeThreshold: 2000, // 2초
      availabilityThreshold: 99, // 99% 가용성
      monitoringDuration: 10 * 60 * 1000, // 10분
      checkInterval: 30 * 1000 // 30초
    };

    const endTime = Date.now() + monitoringConfig.monitoringDuration;
    let checksPassedCount = 0;
    let checksFailed = false;

    while (Date.now() < endTime && !checksFailed) {
      const healthStatus = await this.performHealthChecks(deployment);
      deployment.metrics.healthChecks.push(healthStatus);

      // 임계값 체크
      if (healthStatus.errorRate > monitoringConfig.errorRateThreshold ||
          healthStatus.avgResponseTime > monitoringConfig.responseTimeThreshold ||
          healthStatus.availability < monitoringConfig.availabilityThreshold) {

        console.error('Health check failed:', healthStatus);
        checksFailed = true;

        // 자동 롤백 실행
        await this.automaticRollback(deploymentId, healthStatus);

      } else {
        checksPassedCount++;
        console.log(`Health check passed (${checksPassedCount})`);
      }

      if (!checksFailed) {
        await new Promise(resolve => setTimeout(resolve, monitoringConfig.checkInterval));
      }
    }

    // 모니터링 완료
    if (!checksFailed) {
      deployment.status = 'success';
      console.log(`Deployment ${deploymentId} completed successfully`);
    }

    return deployment;
  }

  // 헬스체크 수행
  async performHealthChecks(deployment) {
    const metrics = {
      timestamp: new Date().toISOString(),
      errorRate: 0,
      avgResponseTime: 0,
      availability: 100,
      checks: []
    };

    // 1. API 엔드포인트 체크
    const apiChecks = await this.checkAPIEndpoints();
    metrics.checks.push(...apiChecks);

    // 2. 에러율 계산
    metrics.errorRate = await this.calculateErrorRate();

    // 3. 응답 시간 측정
    metrics.avgResponseTime = await this.measureResponseTime();

    // 4. 가용성 체크
    metrics.availability = await this.checkAvailability();

    // 5. 비즈니스 메트릭 체크
    const businessMetrics = await this.checkBusinessMetrics();
    metrics.businessHealth = businessMetrics;

    return metrics;
  }

  // API 엔드포인트 체크
  async checkAPIEndpoints() {
    const endpoints = [
      { path: '/health', expectedStatus: 200 },
      { path: '/api/videos/trending', expectedStatus: 200 },
      { path: '/api/auth/status', expectedStatus: 200 }
    ];

    const results = await Promise.all(
      endpoints.map(async endpoint => {
        try {
          const response = await fetch(`${process.env.API_URL}${endpoint.path}`);
          return {
            endpoint: endpoint.path,
            status: response.status,
            success: response.status === endpoint.expectedStatus,
            responseTime: response.headers.get('x-response-time')
          };
        } catch (error) {
          return {
            endpoint: endpoint.path,
            success: false,
            error: error.message
          };
        }
      })
    );

    return results;
  }

  // 에러율 계산
  async calculateErrorRate() {
    // 최근 5분간의 에러율 조회
    const query = `
      SELECT
        COUNT(CASE WHEN status_code >= 500 THEN 1 END) * 100.0 / COUNT(*) as error_rate
      FROM api_logs
      WHERE created_at > NOW() - INTERVAL '5 minutes'
    `;

    const result = await this.executeQuery(query);
    return result.rows[0]?.error_rate || 0;
  }

  // 자동 롤백 실행
  async automaticRollback(deploymentId, failureReason) {
    console.error(`Initiating automatic rollback for deployment ${deploymentId}`);

    if (this.rollbackInProgress) {
      console.warn('Rollback already in progress');
      return;
    }

    this.rollbackInProgress = true;

    try {
      // 1. 이전 안정 버전 찾기
      const targetVersion = await this.findLastStableVersion(deploymentId);

      if (!targetVersion) {
        throw new Error('No stable version found for rollback');
      }

      // 2. 알림 발송
      await this.notifyRollback({
        deploymentId,
        targetVersion,
        reason: failureReason,
        type: 'automatic'
      });

      // 3. 롤백 실행
      const rollbackResult = await this.executeRollback(targetVersion);

      // 4. 롤백 검증
      await this.verifyRollback(rollbackResult);

      // 5. 롤백 완료 알림
      await this.notifyRollbackComplete({
        deploymentId,
        targetVersion,
        success: true
      });

      console.log(`Automatic rollback completed successfully to version ${targetVersion.version}`);

    } catch (error) {
      console.error('Automatic rollback failed:', error);

      await this.notifyRollbackComplete({
        deploymentId,
        success: false,
        error: error.message
      });

      // 수동 개입 요청
      await this.requestManualIntervention(deploymentId, error);

    } finally {
      this.rollbackInProgress = false;
    }
  }

  // 수동 롤백
  async manualRollback(targetVersion, reason) {
    console.log(`Initiating manual rollback to version ${targetVersion}`);

    const deployment = {
      id: `rollback-${Date.now()}`,
      version: targetVersion,
      type: 'rollback',
      reason
    };

    await this.recordDeployment(deployment);

    try {
      // Railway를 통한 롤백
      const result = await this.executeRollback({ version: targetVersion });

      deployment.status = 'success';
      return result;

    } catch (error) {
      deployment.status = 'failed';
      deployment.error = error.message;
      throw error;
    }
  }

  // 롤백 실행
  async executeRollback(targetVersion) {
    console.log(`Executing rollback to ${targetVersion.version}`);

    // 1. Railway CLI를 사용한 롤백
    try {
      // 특정 커밋으로 롤백
      execSync(`railway up --detach --commit ${targetVersion.commit}`, {
        stdio: 'inherit'
      });

      // 배포 완료 대기
      await this.waitForDeployment(targetVersion.version);

      return {
        success: true,
        version: targetVersion.version,
        timestamp: new Date().toISOString()
      };

    } catch (error) {
      console.error('Railway rollback failed:', error);

      // 대체 롤백 방법 시도
      return await this.alternativeRollback(targetVersion);
    }
  }

  // 대체 롤백 방법
  async alternativeRollback(targetVersion) {
    console.log('Attempting alternative rollback method...');

    // Docker 이미지 기반 롤백
    const imageName = `ytshorts-curator:${targetVersion.version}`;

    try {
      // 이전 버전의 Docker 이미지로 전환
      execSync(`docker pull ${process.env.DOCKER_REGISTRY}/${imageName}`);
      execSync(`docker tag ${process.env.DOCKER_REGISTRY}/${imageName} ${imageName}`);

      // 컨테이너 재시작
      execSync(`docker-compose down && docker-compose up -d`);

      return {
        success: true,
        method: 'docker',
        version: targetVersion.version
      };

    } catch (error) {
      throw new Error(`Alternative rollback failed: ${error.message}`);
    }
  }

  // 마지막 안정 버전 찾기
  async findLastStableVersion(currentDeploymentId) {
    // 현재 배포 이전의 성공적인 배포 찾기
    const currentIndex = this.deploymentHistory.findIndex(d => d.id === currentDeploymentId);

    for (let i = currentIndex + 1; i < this.deploymentHistory.length; i++) {
      const deployment = this.deploymentHistory[i];

      if (deployment.status === 'success' &&
          deployment.environment === this.deploymentHistory[currentIndex].environment) {

        // 추가 안정성 검증
        const isStable = await this.verifyVersionStability(deployment);
        if (isStable) {
          return deployment;
        }
      }
    }

    return null;
  }

  // 버전 안정성 검증
  async verifyVersionStability(deployment) {
    // 해당 버전이 최소 1시간 이상 안정적으로 운영되었는지 확인
    const runningTime = Date.now() - new Date(deployment.timestamp).getTime();
    const minimumStableTime = 60 * 60 * 1000; // 1시간

    if (runningTime < minimumStableTime) {
      return false;
    }

    // 해당 버전의 에러율 확인
    const errorRate = await this.getVersionErrorRate(deployment.version);
    return errorRate < 1; // 1% 미만
  }

  // 롤백 검증
  async verifyRollback(rollbackResult) {
    console.log('Verifying rollback...');

    const verificationSteps = [
      {
        name: 'Version Check',
        verify: async () => {
          const currentVersion = await this.getCurrentVersion();
          return currentVersion === rollbackResult.version;
        }
      },
      {
        name: 'Health Check',
        verify: async () => {
          const health = await this.performHealthChecks({ version: rollbackResult.version });
          return health.availability >= 99;
        }
      },
      {
        name: 'Database Migration Check',
        verify: async () => {
          return await this.checkDatabaseCompatibility(rollbackResult.version);
        }
      },
      {
        name: 'API Compatibility Check',
        verify: async () => {
          return await this.checkAPICompatibility(rollbackResult.version);
        }
      }
    ];

    for (const step of verificationSteps) {
      console.log(`Running verification: ${step.name}`);
      const passed = await step.verify();

      if (!passed) {
        throw new Error(`Rollback verification failed: ${step.name}`);
      }
    }

    console.log('Rollback verification completed successfully');
  }

  // 데이터베이스 호환성 체크
  async checkDatabaseCompatibility(version) {
    // 버전별 마이그레이션 확인
    const migrations = await this.getDatabaseMigrations();
    const versionMigrations = migrations.filter(m =>
      semver.gt(m.version, version) && m.breaking
    );

    if (versionMigrations.length > 0) {
      console.warn('Breaking database changes detected:', versionMigrations);

      // 롤백 마이그레이션 실행 필요
      for (const migration of versionMigrations) {
        if (migration.rollback) {
          await this.executeMigrationRollback(migration);
        }
      }
    }

    return true;
  }

  // 롤백 알림
  async notifyRollback(details) {
    const message = {
      title: '🔄 Deployment Rollback Initiated',
      type: details.type,
      deployment: details.deploymentId,
      targetVersion: details.targetVersion.version,
      reason: details.reason,
      timestamp: new Date().toISOString()
    };

    // 다중 채널 알림
    await Promise.all([
      this.sendSlackNotification(message),
      this.sendEmailNotification(message),
      this.createIncidentTicket(message)
    ]);
  }

  // 카나리 배포 지원
  async canaryRollback(percentage) {
    console.log(`Initiating canary rollback to ${percentage}% of traffic`);

    try {
      // 로드밸런서 설정 업데이트
      await this.updateLoadBalancerWeights({
        current: 100 - percentage,
        previous: percentage
      });

      // 메트릭 모니터링
      const canaryMetrics = await this.monitorCanaryDeployment(30 * 60 * 1000); // 30분

      if (canaryMetrics.success) {
        // 점진적 롤백 완료
        await this.completeCanaryRollback();
      } else {
        // 전체 롤백
        await this.executeFullRollback();
      }

    } catch (error) {
      console.error('Canary rollback failed:', error);
      throw error;
    }
  }

  // 롤백 히스토리 관리
  async saveRollbackHistory(rollback) {
    const history = {
      ...rollback,
      id: `rollback-${Date.now()}`,
      timestamp: new Date().toISOString()
    };

    await this.supabase
      .from('rollback_history')
      .insert(history);

    return history;
  }
}

module.exports = new RollbackStrategy();

```

## DevOps 통합 예제

```jsx
// server.js - DevOps 통합
const express = require('express');
const app = express();

// DevOps 모듈 임포트
const deploymentManager = require('./scripts/deploy');
const loggingService = require('./config/logging');
const tracingService = require('./config/tracing');
const errorTracking = require('./monitoring/errorTracking');
const alertingService = require('./monitoring/alerting');
const databaseBackup = require('./backup/databaseBackup');
const disasterRecovery = require('./disaster-recovery/drPlan');
const rollbackStrategy = require('./deployment/rollbackStrategy');

// 초기화
async function initializeDevOps() {
  // 로깅 설정
  loggingService.setupExceptionHandlers();
  app.use(loggingService.expressMiddleware());

  // 추적 설정
  tracingService.initialize();
  app.use(tracingService.expressMiddleware());

  // 에러 추적 설정
  errorTracking.initialize(app);
  app.use(errorTracking.requestHandler());
  app.use(errorTracking.errorHandler());

  // 재해 복구 계획 초기화
  await disasterRecovery.initialize();
  disasterRecovery.monitorRTORPO();

  // 백업 스케줄 설정
  databaseBackup.setupBackupSchedule();

  console.log('DevOps systems initialized');
}

// 배포 웹훅 엔드포인트
app.post('/webhook/deploy', async (req, res) => {
  const deployment = {
    id: req.body.deployment_id,
    version: req.body.version,
    commit: req.body.commit,
    environment: req.body.environment
  };

  try {
    // 배포 기록
    const record = await rollbackStrategy.recordDeployment(deployment);

    // 비동기로 모니터링 시작
    rollbackStrategy.monitorDeployment(deployment.id)
      .catch(error => {
        console.error('Deployment monitoring failed:', error);
      });

    res.json({ success: true, deploymentId: record.id });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// 수동 롤백 엔드포인트
app.post('/api/rollback', async (req, res) => {
  try {
    const result = await rollbackStrategy.manualRollback(
      req.body.targetVersion,
      req.body.reason
    );
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// 시스템 상태 대시보드
app.get('/api/system/status', async (req, res) => {
  const status = {
    health: await disasterRecovery.getSystemHealth(),
    backups: await databaseBackup.getBackupStatus(),
    deployments: rollbackStrategy.deploymentHistory.slice(0, 5),
    alerts: await alertingService.getActiveAlerts()
  };

  res.json(status);
});

// 서버 시작
const PORT = process.env.PORT || 3000;
app.listen(PORT, async () => {
  await initializeDevOps();
  console.log(`Server running on port ${PORT} with full DevOps capabilities`);
});

// 정상 종료 처리
process.on('SIGTERM', async () => {
  console.log('SIGTERM received, shutting down gracefully...');

  await tracingService.shutdown();
  await databaseBackup.performBackup('shutdown');

  process.exit(0);
});

```

```
return outputFile;

```

}

// S3 업로드
async uploadToS3(file, backupId) {
const key = `database/${new Date().getFullYear()}/${backupId}.gz.enc`;

```
const fileStream = await fs.readFile(file);

const params = {
  Bucket: this.backupBucket,
  Key: key,
  Body: fileStream,
  ServerSideEncryption: 'AES256',
  StorageClass: 'STANDARD_IA',
  Metadata: {
    'backup-id': backupId,
    'backup-date': new Date().toISOString(),
    'service': 'youtube-shorts-curator'
  }
};

await this.s3.upload(params).promise();

return `s3://${this.backupBucket}/${key}`;

```

}

// 백업 메타데이터 저장
async saveBackupMetadata(metadata) {
const { error } = await this.supabase
.from('backup_history')
.insert({
...metadata,
created_at: new Date().toISOString()
});

```
if (error) {
  console.error('Failed to save backup metadata:', error);
}

```

}

// 백업 ID 생성
generateBackupId() {
const timestamp = new Date().toISOString().replace(/[:-]/g, '').replace(/..+/, '');
const random = Math.random().toString(36).substring(2, 8);
return `backup-${timestamp}-${random}`;
}

// 파일 크기 확인
async getFileSize(file) {
const stats = await fs.stat(file);
return stats.size;
}

// 로컬 파일 정리
async cleanupLocalFiles(files) {
for (const file of files) {
try {
await fs.unlink(file);
} catch (error) {
console.error(`Failed to delete ${file}:`, error);
}
}
}

// 오래된 백업 정리
async cleanupOldBackups() {
const retentionDays = {
daily: 7,
weekly: 30,
monthly: 365
};

```
// S3에서 오래된 백업 삭제
const cutoffDate = new Date();
cutoffDate.setDate(cutoffDate.getDate() - retentionDays.daily);

const listParams = {
  Bucket: this.backupBucket,
  Prefix: 'database/'
};

const objects = await this.s3.listObjectsV2(listParams).promise();

const toDelete = objects.Contents
  .filter(obj => new Date(obj.LastModified) < cutoffDate)
  .map(obj => ({ Key: obj.Key }));

if (toDelete.length > 0) {
  await this.s3.deleteObjects({
    Bucket: this.backupBucket,
    Delete: { Objects: toDelete }
  }).promise();

  console.log(`Deleted ${toDelete.length} old backups`);
}

```

}

// 백업 복원
async restoreBackup(backupId) {
console.log(`Starting restore for backup: ${backupId}`);

```
try {
  // 1. 백업 메타데이터 조회
  const { data: backup } = await this.supabase
    .from('backup_history')
    .select('*')
    .eq('id', backupId)
    .single();

  if (!backup) {
    throw new Error('Backup not found');
  }

  // 2. S3에서 백업 다운로드
  const localFile = await this.downloadFromS3(backup.location);

  // 3. 복호화 및 압축 해제
  const sqlFile = await this.decryptAndDecompress(localFile);

  // 4. 데이터베이스 복원
  await this.restoreDatabase(sqlFile);

  // 5. 복원 후 검증
  await this.verifyRestore();

  // 6. 정리
  await this.cleanupLocalFiles([localFile, sqlFile]);

  console.log(`Restore completed for backup: ${backupId}`);

  return { success: true };

} catch (error) {
  console.error(`Restore failed for backup: ${backupId}`, error);
  throw error;
}

```

}

// S3에서 다운로드
async downloadFromS3(s3Location) {
const match = s3Location.match(/s3://([^/]+)/(.+)/);
if (!match) {
throw new Error('Invalid S3 location');
}

```
const [, bucket, key] = match;
const localFile = path.join('/tmp', path.basename(key));

const params = {
  Bucket: bucket,
  Key: key
};

const data = await this.s3.getObject(params).promise();
await fs.writeFile(localFile, data.Body);

return localFile;

```

}

// 복호화 및 압축 해제
async decryptAndDecompress(inputFile) {
const outputFile = inputFile.replace('.gz.enc', '.sql');

```
const command = `openssl enc -aes-256-cbc \
  -d \
  -pbkdf2 \
  -pass pass:${process.env.BACKUP_ENCRYPTION_KEY} \
  -in ${inputFile} | \
  gzip -d > ${outputFile}`;

await exec(command);

return outputFile;

```

}

// 데이터베이스 복원
async restoreDatabase(sqlFile) {
// 주의: 프로덕션에서는 매우 신중하게 실행
const command = `psql ${process.env.DATABASE_URL} < ${sqlFile}`;

```
await exec(command);

```

}

// 복원 검증
async verifyRestore() {
// 기본적인 테이블 존재 확인
const tables = ['users', 'videos', 'search_logs'];

```
for (const table of tables) {
  const { data, error } = await this.supabase
    .from(table)
    .select('count')
    .limit(1);

  if (error) {
    throw new Error(`Table ${table} verification failed`);
  }
}

```

}

// 백업 스케줄 설정
setupBackupSchedule() {
const cron = require('node-cron');

```
// 일일 백업 (매일 새벽 2시)
cron.schedule('0 2 * * *', async () => {
  try {
    await this.performBackup('daily');
  } catch (error) {
    console.error('Daily backup failed:', error);
    await this.alertBackupFailure('daily', error);
  }
});

// 주간 백업 (매주 일요일 새벽 3시)
cron.schedule('0 3 * * 0', async () => {
  try {
    await this.performBackup('weekly');
  } catch (error) {
    console.error('Weekly backup failed:', error);
    await this.alertBackupFailure('weekly', error);
  }
});

// 월간 백업 (매월 1일 새벽 4시)
cron.schedule('0 4 1 * *', async () => {
  try {
    await this.performBackup('monthly');
  } catch (error) {
    console.error('Monthly backup failed:', error);
    await this.alertBackupFailure('monthly', error);
  }
});

console.log('Backup schedules configured');

```

}

// 백업 실패 알림
async alertBackupFailure(type, error) {
const alertingService = require('../monitoring/alerting');

```
await alertingService.sendAlert({
  title: 'Database Backup Failed',
  component: 'backup',
  rule: 'backup_failure',
  priority: 'high',
  message: `${type} backup failed: ${error.message}`,
  details: {
    type,
    error: error.stack
  }
});

```

}
}

```
return dumpFile;

```

}

// 압축 및 암호화
async compressAndEncrypt(inputFile) {
const outputFile = `${inputFile}.gz.enc`;

```
// gzip 압축 후 openssl 암호화
const command = `gzip -c ${inputFile} | \
  openssl enc -aes-256-cbc \
  -salt \
  -pbkdf2 \
  -pass pass:${process.env.BACKUP_ENCRYPTION_KEY} \
  -out ${outputFile}`;

await exec(command);

```