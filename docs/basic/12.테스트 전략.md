# í…ŒìŠ¤íŠ¸ ì „ëµ (Testing Strategy)

## 12.1 ë‹¨ìœ„ í…ŒìŠ¤íŠ¸

### 12.1.1 Jest ì„¤ì •

### ê¸°ë³¸ ì„¤ì • íŒŒì¼ (jest.config.js)

```jsx
module.exports = {
  // í…ŒìŠ¤íŠ¸ í™˜ê²½ ì„¤ì •
  testEnvironment: 'node',

  // í…ŒìŠ¤íŠ¸ íŒŒì¼ íŒ¨í„´
  testMatch: [
    '**/tests/unit/**/*.test.js',
    '**/tests/unit/**/*.spec.js'
  ],

  // ì»¤ë²„ë¦¬ì§€ ì„¤ì •
  collectCoverage: true,
  coverageDirectory: 'coverage',
  coveragePathIgnorePatterns: [
    '/node_modules/',
    '/tests/',
    '/mobile/'
  ],

  // ìµœì†Œ ì»¤ë²„ë¦¬ì§€ ì„ê³„ê°’
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 85,
      lines: 85,
      statements: 85
    }
  },

  // ëª¨ë“ˆ ë³„ì¹­ ì„¤ì •
  moduleNameMapper: {
    '@/(.*)': '<rootDir>/backend/$1',
    '@supabase/(.*)': '<rootDir>/tests/mocks/supabase/$1'
  },

  // Setup íŒŒì¼
  setupFilesAfterEnv: ['<rootDir>/tests/setup.js'],

  // íƒ€ì„ì•„ì›ƒ ì„¤ì •
  testTimeout: 10000
};

```

### í…ŒìŠ¤íŠ¸ í™˜ê²½ ì„¤ì • (tests/setup.js)

```jsx
// í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
process.env.NODE_ENV = 'test';
process.env.SUPABASE_URL = 'https://test.supabase.co';
process.env.SUPABASE_ANON_KEY = 'test-anon-key';
process.env.YOUTUBE_API_KEY = 'test-youtube-key';
process.env.CLAUDE_API_KEY = 'test-claude-key';

// ì „ì—­ Mock ì„¤ì •
global.fetch = jest.fn();
global.console = {
  ...console,
  error: jest.fn(),
  warn: jest.fn(),
  log: jest.fn()
};

// Supabase Mock
jest.mock('@supabase/supabase-js', () => ({
  createClient: jest.fn(() => ({
    auth: {
      signUp: jest.fn(),
      signIn: jest.fn(),
      signOut: jest.fn(),
      getUser: jest.fn()
    },
    from: jest.fn(() => ({
      select: jest.fn().mockReturnThis(),
      insert: jest.fn().mockReturnThis(),
      update: jest.fn().mockReturnThis(),
      delete: jest.fn().mockReturnThis(),
      eq: jest.fn().mockReturnThis(),
      single: jest.fn()
    }))
  }))
}));

```

### 12.1.2 í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€

### í•µì‹¬ ëª¨ë“ˆë³„ í…ŒìŠ¤íŠ¸ ìš°ì„ ìˆœìœ„

```jsx
// í…ŒìŠ¤íŠ¸ ìš°ì„ ìˆœìœ„ ë§¤íŠ¸ë¦­ìŠ¤
const testPriority = {
  critical: [
    'auth.js',              // ì¸ì¦ ê´€ë ¨ - 95% ì»¤ë²„ë¦¬ì§€
    'youtube-service.js',   // YouTube API - 90% ì»¤ë²„ë¦¬ì§€
    'keyword-extractor.js', // AI í‚¤ì›Œë“œ ì¶”ì¶œ - 90% ì»¤ë²„ë¦¬ì§€
    'mcp-server.js'        // MCP êµ¬í˜„ - 90% ì»¤ë²„ë¦¬ì§€
  ],
  high: [
    'cache-manager.js',     // ìºì‹± ì‹œìŠ¤í…œ - 85% ì»¤ë²„ë¦¬ì§€
    'api-quota.js',        // API í• ë‹¹ëŸ‰ ê´€ë¦¬ - 85% ì»¤ë²„ë¦¬ì§€
    'personalization.js'   // ê°œì¸í™” ì—”ì§„ - 85% ì»¤ë²„ë¦¬ì§€
  ],
  medium: [
    'trend-analyzer.js',    // íŠ¸ë Œë“œ ë¶„ì„ - 80% ì»¤ë²„ë¦¬ì§€
    'video-filter.js',     // ì˜ìƒ í•„í„°ë§ - 80% ì»¤ë²„ë¦¬ì§€
    'user-preferences.js'  // ì‚¬ìš©ì ì„ í˜¸ë„ - 80% ì»¤ë²„ë¦¬ì§€
  ]
};

```

### 12.1.3 ëª¨í‚¹ ì „ëµ

### YouTube API Mock (tests/mocks/youtube-api.mock.js)

```jsx
const mockSearchResponse = {
  data: {
    items: [
      {
        id: { videoId: 'test123' },
        snippet: {
          title: 'í…ŒìŠ¤íŠ¸ ì˜ìƒ',
          description: 'í…ŒìŠ¤íŠ¸ ì„¤ëª…',
          channelTitle: 'í…ŒìŠ¤íŠ¸ ì±„ë„',
          thumbnails: {
            default: { url: 'https://test.com/thumb.jpg' }
          }
        }
      }
    ],
    pageInfo: {
      totalResults: 100,
      resultsPerPage: 50
    }
  }
};

const mockVideoDetailsResponse = {
  data: {
    items: [
      {
        id: 'test123',
        contentDetails: {
          duration: 'PT59S'  // 59ì´ˆ (Shorts)
        },
        statistics: {
          viewCount: '150000',
          likeCount: '5000'
        },
        status: {
          embeddable: true
        }
      }
    ]
  }
};

module.exports = {
  mockSearchResponse,
  mockVideoDetailsResponse,
  // API í• ë‹¹ëŸ‰ ì‹œë®¬ë ˆì´ì…˜
  mockQuotaExceeded: {
    response: {
      status: 403,
      data: {
        error: {
          code: 403,
          message: 'Quota exceeded'
        }
      }
    }
  }
};

```

### Claude API Mock (tests/mocks/claude-api.mock.js)

```jsx
const mockKeywordExtraction = {
  // ë‹¤ì–‘í•œ ì‹œë‚˜ë¦¬ì˜¤ë³„ ì‘ë‹µ
  casual: {
    keywords: ['íë§', 'íœ´ì‹', 'ìì—°', 'ASMR'],
    mood: 'relaxed',
    context: 'evening_rest'
  },
  energetic: {
    keywords: ['ëŒ„ìŠ¤', 'ìš´ë™', 'ì—ë„ˆì§€', 'ì‹ ë‚˜ëŠ”'],
    mood: 'excited',
    context: 'morning_motivation'
  },
  educational: {
    keywords: ['ìš”ë¦¬', 'ë ˆì‹œí”¼', 'íŒ', 'ê¿€íŒ'],
    mood: 'curious',
    context: 'learning'
  }
};

// MCP ë„êµ¬ í˜¸ì¶œ Mock
const mockMCPTools = {
  searchPersonalizedShorts: jest.fn(),
  analyzeUserMood: jest.fn(),
  generateContextualResponse: jest.fn(),
  analyzeTrends: jest.fn()
};

module.exports = {
  mockKeywordExtraction,
  mockMCPTools
};

```

## 12.2 í†µí•© í…ŒìŠ¤íŠ¸

### 12.2.1 API í…ŒìŠ¤íŠ¸

### ì¸ì¦ í”Œë¡œìš° í†µí•© í…ŒìŠ¤íŠ¸ (tests/integration/auth.test.js)

```jsx
const request = require('supertest');
const app = require('../../backend/server');
const { createClient } = require('@supabase/supabase-js');

describe('Authentication Flow Integration Tests', () => {
  let server;
  let testUser;

  beforeAll(async () => {
    server = app.listen(0);
    testUser = {
      email: 'test@example.com',
      password: 'TestPassword123!',
      name: 'í…ŒìŠ¤íŠ¸ ì‚¬ìš©ì'
    };
  });

  afterAll(async () => {
    await server.close();
  });

  describe('íšŒì›ê°€ì… í”„ë¡œì„¸ìŠ¤', () => {
    test('ì •ìƒì ì¸ íšŒì›ê°€ì…', async () => {
      const response = await request(server)
        .post('/api/register')
        .send(testUser)
        .expect(201);

      expect(response.body).toMatchObject({
        success: true,
        user: {
          email: testUser.email,
          name: testUser.name
        }
      });

      // ë°ì´í„°ë² ì´ìŠ¤ í™•ì¸
      expect(createClient).toHaveBeenCalled();
    });

    test('ì¤‘ë³µ ì´ë©”ì¼ ì²˜ë¦¬', async () => {
      // ì²« ë²ˆì§¸ ê°€ì…
      await request(server)
        .post('/api/register')
        .send(testUser);

      // ì¤‘ë³µ ê°€ì… ì‹œë„
      const response = await request(server)
        .post('/api/register')
        .send(testUser)
        .expect(409);

      expect(response.body).toMatchObject({
        success: false,
        error: 'ì´ë¯¸ ë“±ë¡ëœ ì´ë©”ì¼ì…ë‹ˆë‹¤'
      });
    });

    test('ìœ íš¨í•˜ì§€ ì•Šì€ ì´ë©”ì¼ í˜•ì‹', async () => {
      const response = await request(server)
        .post('/api/register')
        .send({
          ...testUser,
          email: 'invalid-email'
        })
        .expect(400);

      expect(response.body.error).toContain('ìœ íš¨í•œ ì´ë©”ì¼');
    });
  });

  describe('ë¡œê·¸ì¸/ë¡œê·¸ì•„ì›ƒ í”„ë¡œì„¸ìŠ¤', () => {
    let authToken;

    test('ì •ìƒì ì¸ ë¡œê·¸ì¸', async () => {
      const response = await request(server)
        .post('/api/login')
        .send({
          email: testUser.email,
          password: testUser.password
        })
        .expect(200);

      expect(response.body).toHaveProperty('token');
      authToken = response.body.token;

      // JWT í† í° ê²€ì¦
      expect(authToken).toMatch(/^eyJ/);
    });

    test('ì˜ëª»ëœ ë¹„ë°€ë²ˆí˜¸', async () => {
      const response = await request(server)
        .post('/api/login')
        .send({
          email: testUser.email,
          password: 'WrongPassword'
        })
        .expect(401);

      expect(response.body.error).toContain('ì¸ì¦ ì‹¤íŒ¨');
    });

    test('ì¸ì¦ëœ ìš”ì²­ í…ŒìŠ¤íŠ¸', async () => {
      const response = await request(server)
        .get('/api/user/profile')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      expect(response.body.user.email).toBe(testUser.email);
    });
  });
});

```

### 12.2.2 E2E í…ŒìŠ¤íŠ¸

### Playwright ì„¤ì • (playwright.config.js)

```jsx
module.exports = {
  testDir: './tests/e2e',
  timeout: 30000,
  retries: 2,
  workers: 1,

  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure'
  },

  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] }
    },
    {
      name: 'mobile',
      use: { ...devices['iPhone 13'] }
    }
  ],

  webServer: {
    command: 'npm run dev',
    port: 3000,
    reuseExistingServer: !process.env.CI
  }
};

```

### í•µì‹¬ ì‚¬ìš©ì ì‹œë‚˜ë¦¬ì˜¤ E2E í…ŒìŠ¤íŠ¸ (tests/e2e/user-journey.spec.js)

```jsx
const { test, expect } = require('@playwright/test');

test.describe('YouTube Shorts íë ˆì´ì…˜ ì‚¬ìš©ì ì—¬ì •', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
  });

  test('ì‹ ê·œ ì‚¬ìš©ì ì²« ë°©ë¬¸ ì‹œë‚˜ë¦¬ì˜¤', async ({ page }) => {
    // 1. ë©”ì¸ í˜ì´ì§€ ì ‘ì†
    await expect(page.locator('h1')).toContainText('YouTube Shorts');

    // 2. íŠ¸ë Œë“œ í‚¤ì›Œë“œ í™•ì¸
    const trendingKeywords = page.locator('.trending-keywords .keyword-card');
    await expect(trendingKeywords).toHaveCount(8);

    // 3. í‚¤ì›Œë“œ í´ë¦­
    await trendingKeywords.first().click();

    // 4. ì˜ìƒ ë¦¬ìŠ¤íŠ¸ ë¡œë”© í™•ì¸
    await expect(page.locator('.video-grid')).toBeVisible();
    const videos = page.locator('.video-card');
    await expect(videos.first()).toBeVisible({ timeout: 5000 });

    // 5. ë¬´í•œ ìŠ¤í¬ë¡¤ í…ŒìŠ¤íŠ¸
    const initialCount = await videos.count();
    await page.evaluate(() => window.scrollTo(0, document.body.scrollHeight));
    await page.waitForTimeout(1000);
    const afterScrollCount = await videos.count();
    expect(afterScrollCount).toBeGreaterThan(initialCount);

    // 6. ì˜ìƒ ì¬ìƒ
    await videos.first().click();
    await expect(page.locator('iframe[src*="youtube.com"]')).toBeVisible();
  });

  test('í”„ë¦¬ë¯¸ì—„ ì‚¬ìš©ì ëŒ€í™”í˜• ê²€ìƒ‰', async ({ page }) => {
    // ë¡œê·¸ì¸
    await page.goto('/login');
    await page.fill('input[name="email"]', 'premium@test.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');

    // ëŒ€í™” í˜ì´ì§€ë¡œ ì´ë™
    await page.click('nav >> text=AI ì¶”ì²œ');

    // ëŒ€í™” ì‹œì‘
    await page.fill('.chat-input', 'ì €ë…ì— í¸ì•ˆí•˜ê²Œ ë³¼ ìˆ˜ ìˆëŠ” ì˜ìƒ ì¶”ì²œí•´ì¤˜');
    await page.keyboard.press('Enter');

    // AI ì‘ë‹µ ëŒ€ê¸°
    await expect(page.locator('.ai-response')).toBeVisible({ timeout: 10000 });

    // ì¶”ì²œ í‚¤ì›Œë“œ í™•ì¸
    const suggestedKeywords = page.locator('.suggested-keywords button');
    await expect(suggestedKeywords).toHaveCount(4);

    // í‚¤ì›Œë“œ ì„ íƒ
    await suggestedKeywords.first().click();

    // ì˜ìƒ ê²°ê³¼ í™•ì¸
    await expect(page.locator('.recommended-videos')).toBeVisible();
  });

  test('ëª¨ë°”ì¼ ë°˜ì‘í˜• í…ŒìŠ¤íŠ¸', async ({ page, isMobile }) => {
    if (!isMobile) {
      await page.setViewportSize({ width: 375, height: 667 });
    }

    // í–„ë²„ê±° ë©”ë‰´ í™•ì¸
    await expect(page.locator('.mobile-menu-toggle')).toBeVisible();

    // ë©”ë‰´ ì—´ê¸°
    await page.click('.mobile-menu-toggle');
    await expect(page.locator('.mobile-nav')).toBeVisible();

    // ì˜ìƒ ì¹´ë“œ ë ˆì´ì•„ì›ƒ í™•ì¸
    await page.goto('/videos/trending');
    const videoGrid = page.locator('.video-grid');
    const gridColumns = await videoGrid.evaluate(el =>
      window.getComputedStyle(el).gridTemplateColumns
    );
    expect(gridColumns).toContain('1fr');  // ëª¨ë°”ì¼ì—ì„œëŠ” 1ì—´
  });
});

```

### 12.2.3 ì„±ëŠ¥ í…ŒìŠ¤íŠ¸

### ë¶€í•˜ í…ŒìŠ¤íŠ¸ ìŠ¤í¬ë¦½íŠ¸ (tests/performance/load-test.js)

```jsx
const autocannon = require('autocannon');
const { performance } = require('perf_hooks');

// ë¶€í•˜ í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤
const scenarios = {
  // ê¸°ë³¸ API ì—”ë“œí¬ì¸íŠ¸ í…ŒìŠ¤íŠ¸
  basic: {
    title: 'ê¸°ë³¸ API ë¶€í•˜ í…ŒìŠ¤íŠ¸',
    url: 'http://localhost:3000/api/health',
    connections: 10,
    duration: 30,
    pipelining: 1
  },

  // ê²€ìƒ‰ API ë¶€í•˜ í…ŒìŠ¤íŠ¸
  search: {
    title: 'ê²€ìƒ‰ API ë¶€í•˜ í…ŒìŠ¤íŠ¸',
    url: 'http://localhost:3000/api/search',
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': 'Bearer test-token'
    },
    body: JSON.stringify({
      keyword: 'ìš”ë¦¬',
      source: 'cache'
    }),
    connections: 50,
    duration: 60,
    pipelining: 10
  },

  // ë™ì‹œ ì‚¬ìš©ì ì‹œë®¬ë ˆì´ì…˜
  concurrent: {
    title: 'ë™ì‹œ ì‚¬ìš©ì ì‹œë®¬ë ˆì´ì…˜',
    url: 'http://localhost:3000',
    connections: 100,
    duration: 120,
    pipelining: 1,
    bailout: 1000  // 1ì´ˆ ì´ìƒ ì‘ë‹µ ì‹œ ì‹¤íŒ¨
  }
};

// ì„±ëŠ¥ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
class PerformanceCollector {
  constructor() {
    this.metrics = {
      responseTime: [],
      throughput: [],
      errors: 0,
      timeouts: 0
    };
  }

  collect(result) {
    this.metrics.responseTime.push({
      p50: result.latency.p50,
      p90: result.latency.p90,
      p99: result.latency.p99,
      mean: result.latency.mean
    });

    this.metrics.throughput.push({
      requests: result.requests.total,
      bytes: result.throughput.total,
      duration: result.duration
    });

    this.metrics.errors += result.errors;
    this.metrics.timeouts += result.timeouts;
  }

  generateReport() {
    const avgResponseTime = this.metrics.responseTime.reduce((acc, curr) =>
      acc + curr.mean, 0) / this.metrics.responseTime.length;

    const totalRequests = this.metrics.throughput.reduce((acc, curr) =>
      acc + curr.requests, 0);

    return {
      summary: {
        avgResponseTime: `${avgResponseTime.toFixed(2)}ms`,
        totalRequests,
        errorRate: `${((this.metrics.errors / totalRequests) * 100).toFixed(2)}%`,
        timeoutRate: `${((this.metrics.timeouts / totalRequests) * 100).toFixed(2)}%`
      },
      details: this.metrics
    };
  }
}

// í…ŒìŠ¤íŠ¸ ì‹¤í–‰
async function runLoadTests() {
  const collector = new PerformanceCollector();

  for (const [name, scenario] of Object.entries(scenarios)) {
    console.log(`\nì‹¤í–‰ ì¤‘: ${scenario.title}`);

    const result = await autocannon(scenario);
    collector.collect(result);

    console.log(`ì™„ë£Œ: ${result.requests.total} requests, ${result.errors} errors`);

    // ì„±ëŠ¥ ê¸°ì¤€ ê²€ì¦
    if (result.latency.p99 > 1000) {
      console.warn('âš ï¸  ê²½ê³ : P99 ì‘ë‹µì‹œê°„ì´ 1ì´ˆë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤!');
    }

    if (result.errors > result.requests.total * 0.01) {
      console.error('âŒ ì‹¤íŒ¨: ì—ëŸ¬ìœ¨ì´ 1%ë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤!');
    }
  }

  // ìµœì¢… ë³´ê³ ì„œ
  const report = collector.generateReport();
  console.log('\n=== ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ ìµœì¢… ë³´ê³ ì„œ ===');
  console.log(JSON.stringify(report, null, 2));

  // ì„±ëŠ¥ ê¸°ì¤€ ì¶©ì¡± ì—¬ë¶€
  const passed = report.summary.errorRate < 1 &&
                 parseFloat(report.summary.avgResponseTime) < 500;

  if (!passed) {
    throw new Error('ì„±ëŠ¥ ê¸°ì¤€ì„ ì¶©ì¡±í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤');
  }
}

// ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ í…ŒìŠ¤íŠ¸
async function memoryLeakTest() {
  const baseline = process.memoryUsage().heapUsed;
  const iterations = 1000;

  for (let i = 0; i < iterations; i++) {
    // API í˜¸ì¶œ ì‹œë®¬ë ˆì´ì…˜
    await fetch('http://localhost:3000/api/search', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ keyword: `test${i}` })
    });

    if (i % 100 === 0) {
      global.gc();  // ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ ê°•ì œ ì‹¤í–‰
      const current = process.memoryUsage().heapUsed;
      const increase = ((current - baseline) / baseline) * 100;

      console.log(`ë°˜ë³µ ${i}: ë©”ëª¨ë¦¬ ì¦ê°€ìœ¨ ${increase.toFixed(2)}%`);

      if (increase > 50) {
        console.error('âŒ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ê°ì§€!');
        process.exit(1);
      }
    }
  }
}

// ì‹¤í–‰
if (require.main === module) {
  runLoadTests()
    .then(() => memoryLeakTest())
    .catch(console.error);
}

```

## 12.3 ì‚¬ìš©ì í…ŒìŠ¤íŠ¸

### 12.3.1 ë² íƒ€ í…ŒìŠ¤íŠ¸ ê³„íš

### ë² íƒ€ í…ŒìŠ¤í„° ëª¨ì§‘ ë° ê´€ë¦¬

```jsx
// ë² íƒ€ í…ŒìŠ¤í„° ê´€ë¦¬ ì‹œìŠ¤í…œ (backend/beta-management.js)
class BetaTesterManager {
  constructor(supabaseClient) {
    this.supabase = supabaseClient;
    this.testGroups = {
      A: { feature: 'baseline', size: 100 },
      B: { feature: 'new_ui', size: 100 },
      C: { feature: 'advanced_mcp', size: 50 }
    };
  }

  // ë² íƒ€ í…ŒìŠ¤í„° ë“±ë¡
  async registerBetaTester(userData) {
    const group = this.assignTestGroup(userData);

    const { data, error } = await this.supabase
      .from('beta_testers')
      .insert({
        user_id: userData.id,
        email: userData.email,
        test_group: group,
        enrolled_at: new Date(),
        consent_given: true,
        demographics: {
          age_range: userData.ageRange,
          youtube_usage: userData.youtubeUsage,
          device_type: userData.deviceType
        }
      });

    if (!error) {
      await this.sendWelcomeEmail(userData.email, group);
    }

    return { group, error };
  }

  // í…ŒìŠ¤íŠ¸ ê·¸ë£¹ ìë™ í• ë‹¹
  assignTestGroup(userData) {
    // ê· ë“± ë¶„ë°° ì•Œê³ ë¦¬ì¦˜
    const groups = Object.keys(this.testGroups);
    const hash = this.hashUserId(userData.id);
    return groups[hash % groups.length];
  }

  // í”¼ë“œë°± ìˆ˜ì§‘
  async collectFeedback(userId, feedback) {
    const enrichedFeedback = {
      ...feedback,
      user_id: userId,
      timestamp: new Date(),
      session_data: await this.getSessionData(userId),
      feature_usage: await this.getFeatureUsage(userId)
    };

    return await this.supabase
      .from('beta_feedback')
      .insert(enrichedFeedback);
  }

  // ì‚¬ìš© ë©”íŠ¸ë¦­ ì¶”ì 
  async trackMetrics(userId, event) {
    const metrics = {
      user_id: userId,
      event_type: event.type,
      event_data: event.data,
      timestamp: new Date(),
      session_id: event.sessionId,
      test_group: await this.getUserTestGroup(userId)
    };

    // ì‹¤ì‹œê°„ ë¶„ì„ì„ ìœ„í•œ ì´ë²¤íŠ¸ ë°œí–‰
    this.publishAnalyticsEvent(metrics);

    return await this.supabase
      .from('beta_metrics')
      .insert(metrics);
  }
}

```

### 12.3.2 A/B í…ŒìŠ¤íŠ¸

### A/B í…ŒìŠ¤íŠ¸ í”„ë ˆì„ì›Œí¬

```jsx
// A/B í…ŒìŠ¤íŠ¸ ê´€ë¦¬ì (backend/ab-testing.js)
class ABTestManager {
  constructor() {
    this.experiments = new Map();
    this.results = new Map();
  }

  // ì‹¤í—˜ ì •ì˜
  defineExperiment(config) {
    const experiment = {
      id: config.id,
      name: config.name,
      variants: config.variants,
      metrics: config.metrics,
      startDate: new Date(),
      endDate: null,
      sampleSize: config.sampleSize,
      confidenceLevel: config.confidenceLevel || 0.95
    };

    this.experiments.set(config.id, experiment);
    return experiment;
  }

  // ì£¼ìš” ì‹¤í—˜ ì„¤ì •
  setupExperiments() {
    // 1. ì¶”ì²œ ì•Œê³ ë¦¬ì¦˜ í…ŒìŠ¤íŠ¸
    this.defineExperiment({
      id: 'recommendation_algorithm',
      name: 'ì¶”ì²œ ì•Œê³ ë¦¬ì¦˜ ìµœì í™”',
      variants: {
        control: { algorithm: 'collaborative_filtering' },
        treatment: { algorithm: 'mcp_enhanced' }
      },
      metrics: ['click_through_rate', 'watch_time', 'user_retention'],
      sampleSize: 1000
    });

    // 2. UI ë ˆì´ì•„ì›ƒ í…ŒìŠ¤íŠ¸
    this.defineExperiment({
      id: 'video_layout',
      name: 'ì˜ìƒ ê·¸ë¦¬ë“œ ë ˆì´ì•„ì›ƒ',
      variants: {
        control: { layout: 'grid_2x2' },
        treatment_a: { layout: 'grid_3x3' },
        treatment_b: { layout: 'masonry' }
      },
      metrics: ['scroll_depth', 'videos_watched', 'bounce_rate'],
      sampleSize: 1500
    });

    // 3. ëŒ€í™”í˜• ì¸í„°í˜ì´ìŠ¤ í…ŒìŠ¤íŠ¸
    this.defineExperiment({
      id: 'chat_interface',
      name: 'ëŒ€í™”í˜• ì¶”ì²œ ì¸í„°í˜ì´ìŠ¤',
      variants: {
        control: { interface: 'simple_search' },
        treatment: { interface: 'conversational_ai' }
      },
      metrics: ['engagement_rate', 'satisfaction_score', 'feature_adoption'],
      sampleSize: 500
    });
  }

  // ì‚¬ìš©ìë¥¼ ì‹¤í—˜ ê·¸ë£¹ì— í• ë‹¹
  assignUserToExperiment(userId, experimentId) {
    const experiment = this.experiments.get(experimentId);
    if (!experiment) return null;

    // ê²°ì •ì  í• ë‹¹ (ê°™ì€ ì‚¬ìš©ìëŠ” í•­ìƒ ê°™ì€ ê·¸ë£¹)
    const hash = this.hashString(`${userId}-${experimentId}`);
    const variants = Object.keys(experiment.variants);
    const variantIndex = hash % variants.length;

    return {
      experimentId,
      variant: variants[variantIndex],
      config: experiment.variants[variants[variantIndex]]
    };
  }

  // ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ë° ë¶„ì„
  async analyzeResults(experimentId) {
    const experiment = this.experiments.get(experimentId);
    const data = await this.fetchExperimentData(experimentId);

    const results = {
      experimentId,
      sampleSizes: {},
      metrics: {}
    };

    // ê° ë³€í˜•ë³„ ê²°ê³¼ ê³„ì‚°
    for (const variant of Object.keys(experiment.variants)) {
      const variantData = data.filter(d => d.variant === variant);
      results.sampleSizes[variant] = variantData.length;

      for (const metric of experiment.metrics) {
        if (!results.metrics[metric]) {
          results.metrics[metric] = {};
        }

        results.metrics[metric][variant] = {
          mean: this.calculateMean(variantData, metric),
          stdDev: this.calculateStdDev(variantData, metric),
          confidence: this.calculateConfidenceInterval(variantData, metric)
        };
      }
    }

    // í†µê³„ì  ìœ ì˜ì„± ê²€ì •
    results.significance = this.performSignificanceTest(results);

    // ìŠ¹ì ê²°ì •
    results.winner = this.determineWinner(results);

    return results;
  }

  // í†µê³„ì  ìœ ì˜ì„± ê²€ì • (T-test)
  performSignificanceTest(results) {
    const significance = {};

    for (const metric of Object.keys(results.metrics)) {
      const control = results.metrics[metric].control;
      const treatments = Object.keys(results.metrics[metric])
        .filter(k => k !== 'control');

      significance[metric] = {};

      for (const treatment of treatments) {
        const treatmentData = results.metrics[metric][treatment];

        // T-test ìˆ˜í–‰
        const tScore = this.calculateTScore(
          control.mean, treatmentData.mean,
          control.stdDev, treatmentData.stdDev,
          results.sampleSizes.control, results.sampleSizes[treatment]
        );

        const pValue = this.calculatePValue(tScore,
          results.sampleSizes.control + results.sampleSizes[treatment] - 2
        );

        significance[metric][treatment] = {
          tScore,
          pValue,
          isSignificant: pValue < 0.05,
          improvement: ((treatmentData.mean - control.mean) / control.mean) * 100
        };
      }
    }

    return significance;
  }
}

```

### 12.3.3 í”¼ë“œë°± ìˆ˜ì§‘

### ì‹¤ì‹œê°„ í”¼ë“œë°± ì‹œìŠ¤í…œ

```jsx
// í”¼ë“œë°± ìˆ˜ì§‘ ìœ„ì ¯ (frontend/js/components/FeedbackWidget.js)
class FeedbackWidget extends Component {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this.feedbackTypes = ['bug', 'feature', 'ui', 'performance'];
    this.sessionData = this.collectSessionData();
  }

  connectedCallback() {
    this.render();
    this.setupEventListeners();
    this.setupHotkeys();
  }

  render() {
    this.shadowRoot.innerHTML = `
      <style>
        :host {
          position: fixed;
          bottom: 20px;
          right: 20px;
          z-index: 1000;
        }

        .feedback-button {
          background: #ff6b6b;
          color: white;
          border: none;
          border-radius: 50%;
          width: 60px;
          height: 60px;
          font-size: 24px;
          cursor: pointer;
          box-shadow: 0 4px 12px rgba(0,0,0,0.15);
          transition: transform 0.2s;
        }

        .feedback-button:hover {
          transform: scale(1.1);
        }

        .feedback-modal {
          display: none;
          position: fixed;
          bottom: 90px;
          right: 20px;
          background: white;
          border-radius: 12px;
          box-shadow: 0 10px 40px rgba(0,0,0,0.15);
          width: 400px;
          max-height: 600px;
          overflow-y: auto;
        }

        .feedback-modal.active {
          display: block;
          animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp {
          from {
            opacity: 0;
            transform: translateY(20px);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }

        .modal-header {
          padding: 20px;
          border-bottom: 1px solid #eee;
        }

        .modal-body {
          padding: 20px;
        }

        .feedback-type {
          display: flex;
          gap: 10px;
          margin-bottom: 20px;
        }

        .type-button {
          flex: 1;
          padding: 10px;
          border: 2px solid #eee;
          background: white;
          border-radius: 8px;
          cursor: pointer;
          transition: all 0.2s;
        }

        .type-button.selected {
          border-color: #ff6b6b;
          background: #fff5f5;
        }

        .feedback-form textarea {
          width: 100%;
          min-height: 120px;
          padding: 12px;
          border: 2px solid #eee;
          border-radius: 8px;
          resize: vertical;
        }

        .screenshot-preview {
          margin: 15px 0;
          max-width: 100%;
          border-radius: 8px;
          border: 2px solid #eee;
        }

        .submit-button {
          width: 100%;
          padding: 12px;
          background: #ff6b6b;
          color: white;
          border: none;
          border-radius: 8px;
          font-size: 16px;
          cursor: pointer;
        }

        .nps-survey {
          margin: 20px 0;
        }

        .nps-scale {
          display: flex;
          justify-content: space-between;
          margin: 10px 0;
        }

        .nps-button {
          width: 30px;
          height: 30px;
          border: 1px solid #ddd;
          background: white;
          cursor: pointer;
          transition: all 0.2s;
        }

        .nps-button:hover {
          background: #f0f0f0;
        }

        .nps-button.selected {
          background: #ff6b6b;
          color: white;
          border-color: #ff6b6b;
        }
      </style>

      <button class="feedback-button" id="feedbackTrigger">
        ğŸ’¬
      </button>

      <div class="feedback-modal" id="feedbackModal">
        <div class="modal-header">
          <h3>í”¼ë“œë°± ë³´ë‚´ê¸°</h3>
          <p>ì—¬ëŸ¬ë¶„ì˜ ì˜ê²¬ì´ ì„œë¹„ìŠ¤ë¥¼ ê°œì„ í•©ë‹ˆë‹¤!</p>
        </div>

        <div class="modal-body">
          <div class="feedback-type">
            <button class="type-button" data-type="bug">ğŸ› ë²„ê·¸</button>
            <button class="type-button" data-type="feature">âœ¨ ê¸°ëŠ¥ ì œì•ˆ</button>
            <button class="type-button" data-type="ui">ğŸ¨ UI/UX</button>
            <button class="type-button" data-type="performance">âš¡ ì„±ëŠ¥</button>
          </div>

          <form id="feedbackForm">
            <textarea
              placeholder="ì–´ë–¤ ì ì„ ê°œì„ í•˜ë©´ ì¢‹ì„ê¹Œìš”?"
              required
            ></textarea>

            <div class="screenshot-section">
              <label>
                <input type="checkbox" id="includeScreenshot">
                í˜„ì¬ í™”ë©´ ìŠ¤í¬ë¦°ìƒ· í¬í•¨
              </label>
              <img class="screenshot-preview" id="screenshotPreview" style="display:none;">
            </div>

            <div class="nps-survey">
              <p>ì´ ì„œë¹„ìŠ¤ë¥¼ ì¹œêµ¬ì—ê²Œ ì¶”ì²œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?</p>
              <div class="nps-scale">
                ${[...Array(11)].map((_, i) =>
                  `<button type="button" class="nps-button" data-score="${i}">${i}</button>`
                ).join('')}
              </div>
              <div style="display:flex;justify-content:space-between;font-size:12px;color:#666;">
                <span>ì¶”ì²œí•˜ì§€ ì•ŠìŒ</span>
                <span>ì ê·¹ ì¶”ì²œ</span>
              </div>
            </div>

            <button type="submit" class="submit-button">
              í”¼ë“œë°± ì „ì†¡
            </button>
          </form>
        </div>
      </div>
    `;
  }

  setupEventListeners() {
    const trigger = this.shadowRoot.getElementById('feedbackTrigger');
    const modal = this.shadowRoot.getElementById('feedbackModal');
    const form = this.shadowRoot.getElementById('feedbackForm');

    // ëª¨ë‹¬ í† ê¸€
    trigger.addEventListener('click', () => {
      modal.classList.toggle('active');
      if (modal.classList.contains('active')) {
        this.trackEvent('feedback_modal_opened');
      }
    });

    // í”¼ë“œë°± íƒ€ì… ì„ íƒ
    this.shadowRoot.querySelectorAll('.type-button').forEach(button => {
      button.addEventListener('click', (e) => {
        this.shadowRoot.querySelectorAll('.type-button').forEach(b =>
          b.classList.remove('selected')
        );
        e.target.classList.add('selected');
        this.selectedType = e.target.dataset.type;
      });
    });

    // NPS ì ìˆ˜ ì„ íƒ
    this.shadowRoot.querySelectorAll('.nps-button').forEach(button => {
      button.addEventListener('click', (e) => {
        this.shadowRoot.querySelectorAll('.nps-button').forEach(b =>
          b.classList.remove('selected')
        );
        e.target.classList.add('selected');
        this.npsScore = parseInt(e.target.dataset.score);
      });
    });

    // ìŠ¤í¬ë¦°ìƒ· ì˜µì…˜
    const screenshotCheckbox = this.shadowRoot.getElementById('includeScreenshot');
    screenshotCheckbox.addEventListener('change', async (e) => {
      if (e.target.checked) {
        const screenshot = await this.captureScreenshot();
        const preview = this.shadowRoot.getElementById('screenshotPreview');
        preview.src = screenshot;
        preview.style.display = 'block';
      } else {
        this.shadowRoot.getElementById('screenshotPreview').style.display = 'none';
      }
    });

    // í¼ ì œì¶œ
    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      await this.submitFeedback();
    });
  }

  setupHotkeys() {
    // Ctrl+Shift+Fë¡œ í”¼ë“œë°± ëª¨ë‹¬ ì—´ê¸°
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.shiftKey && e.key === 'F') {
        e.preventDefault();
        this.shadowRoot.getElementById('feedbackModal').classList.toggle('active');
      }
    });
  }

  async captureScreenshot() {
    // ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” html2canvas ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš©
    return 'data:image/png;base64,placeholder';
  }

  collectSessionData() {
    return {
      url: window.location.href,
      userAgent: navigator.userAgent,
      screenResolution: `${screen.width}x${screen.height}`,
      viewport: `${window.innerWidth}x${window.innerHeight}`,
      timestamp: new Date().toISOString(),
      sessionId: this.getSessionId(),
      userId: this.getUserId()
    };
  }

  async submitFeedback() {
    const textarea = this.shadowRoot.querySelector('textarea');
    const screenshot = this.shadowRoot.getElementById('includeScreenshot').checked
      ? this.shadowRoot.getElementById('screenshotPreview').src
      : null;

    const feedbackData = {
      type: this.selectedType || 'general',
      message: textarea.value,
      npsScore: this.npsScore,
      screenshot,
      sessionData: this.sessionData,
      metadata: {
        currentPage: window.location.pathname,
        referrer: document.referrer,
        timeSpentOnPage: performance.now() / 1000
      }
    };

    try {
      const response = await fetch('/api/feedback', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.getAuthToken()}`
        },
        body: JSON.stringify(feedbackData)
      });

      if (response.ok) {
        this.showSuccessMessage();
        this.shadowRoot.getElementById('feedbackModal').classList.remove('active');
        textarea.value = '';

        // ë¶„ì„ ì´ë²¤íŠ¸ ì „ì†¡
        this.trackEvent('feedback_submitted', {
          type: feedbackData.type,
          npsScore: feedbackData.npsScore
        });
      }
    } catch (error) {
      console.error('í”¼ë“œë°± ì „ì†¡ ì‹¤íŒ¨:', error);
      this.showErrorMessage();
    }
  }

  trackEvent(eventName, data = {}) {
    // ë¶„ì„ ì´ë²¤íŠ¸ ì „ì†¡
    if (window.analytics) {
      window.analytics.track(eventName, {
        ...data,
        component: 'FeedbackWidget'
      });
    }
  }
}

// ì›¹ ì»´í¬ë„ŒíŠ¸ ë“±ë¡
customElements.define('feedback-widget', FeedbackWidget);

```

### í”¼ë“œë°± ë¶„ì„ ëŒ€ì‹œë³´ë“œ

```jsx
// í”¼ë“œë°± ë¶„ì„ ì‹œìŠ¤í…œ (backend/feedback-analytics.js)
class FeedbackAnalytics {
  constructor(supabaseClient) {
    this.supabase = supabaseClient;
    this.sentimentAnalyzer = new SentimentAnalyzer();
    this.categories = {
      bug: ['ë²„ê·¸', 'ì˜¤ë¥˜', 'ì—ëŸ¬', 'ì‘ë™', 'ì•ˆë¨'],
      feature: ['ê¸°ëŠ¥', 'ì¶”ê°€', 'ì œì•ˆ', 'ìˆìœ¼ë©´', 'í–ˆìœ¼ë©´'],
      ui: ['ë””ìì¸', 'UI', 'UX', 'í™”ë©´', 'ë³´ê¸°'],
      performance: ['ëŠë¦¼', 'ë¹ ë¦„', 'ì†ë„', 'ë¡œë”©', 'ì„±ëŠ¥']
    };
  }

  // í”¼ë“œë°± ìë™ ë¶„ë¥˜
  async categorizeFeedback(feedback) {
    const text = feedback.message.toLowerCase();
    const scores = {};

    // í‚¤ì›Œë“œ ë§¤ì¹­
    for (const [category, keywords] of Object.entries(this.categories)) {
      scores[category] = keywords.filter(keyword =>
        text.includes(keyword)
      ).length;
    }

    // AI ê¸°ë°˜ ë¶„ë¥˜ (MCP í™œìš©)
    if (this.mcpClient) {
      const aiCategory = await this.mcpClient.categorize(text);
      scores[aiCategory] = (scores[aiCategory] || 0) + 2;
    }

    // ìµœì¢… ì¹´í…Œê³ ë¦¬ ê²°ì •
    const primaryCategory = Object.entries(scores)
      .sort(([,a], [,b]) => b - a)[0][0];

    return {
      primary: primaryCategory,
      confidence: scores[primaryCategory] / Object.values(scores).reduce((a,b) => a+b, 0),
      allScores: scores
    };
  }

  // ê°ì„± ë¶„ì„
  async analyzeSentiment(feedback) {
    const sentiment = await this.sentimentAnalyzer.analyze(feedback.message);

    return {
      score: sentiment.score,  // -1 ~ 1
      magnitude: sentiment.magnitude,
      label: sentiment.score > 0.3 ? 'positive'
           : sentiment.score < -0.3 ? 'negative'
           : 'neutral'
    };
  }

  // ì‹¤ì‹œê°„ ëŒ€ì‹œë³´ë“œ ë°ì´í„°
  async getDashboardMetrics(timeRange = '7d') {
    const startDate = this.getStartDate(timeRange);

    // ê¸°ë³¸ ë©”íŠ¸ë¦­
    const { data: feedbacks } = await this.supabase
      .from('feedback')
      .select('*')
      .gte('created_at', startDate);

    // NPS ê³„ì‚°
    const npsScores = feedbacks
      .filter(f => f.nps_score !== null)
      .map(f => f.nps_score);

    const nps = this.calculateNPS(npsScores);

    // ì¹´í…Œê³ ë¦¬ë³„ ë¶„í¬
    const categoryDistribution = await this.getCategoryDistribution(feedbacks);

    // ê°ì„± ë¶„ì„ ê²°ê³¼
    const sentimentDistribution = await this.getSentimentDistribution(feedbacks);

    // ì£¼ìš” ì´ìŠˆ ì¶”ì¶œ
    const topIssues = await this.extractTopIssues(feedbacks);

    // ì‘ë‹µë¥  ê³„ì‚°
    const responseMetrics = await this.getResponseMetrics(feedbacks);

    return {
      summary: {
        totalFeedbacks: feedbacks.length,
        npsScore: nps.score,
        npsCategory: nps.category,
        avgSentiment: sentimentDistribution.average,
        responseRate: responseMetrics.rate
      },
      distributions: {
        categories: categoryDistribution,
        sentiment: sentimentDistribution,
        nps: nps.distribution
      },
      trends: {
        daily: await this.getDailyTrends(startDate),
        weekly: await this.getWeeklyTrends()
      },
      insights: {
        topIssues,
        improvementAreas: await this.getImprovementAreas(feedbacks),
        userSegments: await this.getUserSegmentAnalysis(feedbacks)
      }
    };
  }

  // NPS ê³„ì‚°
  calculateNPS(scores) {
    const promoters = scores.filter(s => s >= 9).length;
    const detractors = scores.filter(s => s <= 6).length;
    const total = scores.length;

    const npsScore = ((promoters - detractors) / total) * 100;

    return {
      score: Math.round(npsScore),
      category: npsScore >= 50 ? 'Excellent'
              : npsScore >= 0 ? 'Good'
              : 'Needs Improvement',
      distribution: {
        promoters: (promoters / total) * 100,
        passives: ((total - promoters - detractors) / total) * 100,
        detractors: (detractors / total) * 100
      }
    };
  }

  // ì£¼ìš” ì´ìŠˆ ì¶”ì¶œ
  async extractTopIssues(feedbacks) {
    const issues = [];

    // ë¶€ì •ì  í”¼ë“œë°± ì¤‘ ìì£¼ ì–¸ê¸‰ë˜ëŠ” í‚¤ì›Œë“œ ì¶”ì¶œ
    const negativeFeedbacks = feedbacks.filter(f =>
      f.sentiment && f.sentiment.score < -0.3
    );

    // í…ìŠ¤íŠ¸ ë§ˆì´ë‹
    const wordFrequency = {};
    negativeFeedbacks.forEach(feedback => {
      const words = feedback.message.split(/\s+/);
      words.forEach(word => {
        if (word.length > 3) {  // ì˜ë¯¸ìˆëŠ” ë‹¨ì–´ë§Œ
          wordFrequency[word] = (wordFrequency[word] || 0) + 1;
        }
      });
    });

    // ìƒìœ„ ì´ìŠˆ ì„ ì •
    const topWords = Object.entries(wordFrequency)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 10);

    for (const [word, frequency] of topWords) {
      const relatedFeedbacks = negativeFeedbacks.filter(f =>
        f.message.includes(word)
      );

      issues.push({
        keyword: word,
        frequency,
        severity: this.calculateSeverity(relatedFeedbacks),
        examples: relatedFeedbacks.slice(0, 3).map(f => ({
          message: f.message,
          date: f.created_at
        }))
      });
    }

    return issues;
  }
}

```

## 12.4 í…ŒìŠ¤íŠ¸ ìë™í™” ë° CI/CD

### GitHub Actions ì›Œí¬í”Œë¡œìš° (.github/workflows/test.yml)

```yaml
name: í…ŒìŠ¤íŠ¸ ìë™í™”

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  unit-tests:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [16.x, 18.x]

    steps:
    - uses: actions/checkout@v3

    - name: Node.js ${{ matrix.node-version }} ì„¤ì •
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'

    - name: ì˜ì¡´ì„± ì„¤ì¹˜
      run: npm ci

    - name: ë¦°íŠ¸ ê²€ì‚¬
      run: npm run lint

    - name: ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‹¤í–‰
      run: npm run test:unit

    - name: ì»¤ë²„ë¦¬ì§€ ë¦¬í¬íŠ¸ ì—…ë¡œë“œ
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/lcov.info
        flags: unittests
        name: codecov-umbrella

  integration-tests:
    runs-on: ubuntu-latest
    needs: unit-tests

    services:
      postgres:
        image: supabase/postgres:14.1.0
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - uses: actions/checkout@v3

    - name: Node.js ì„¤ì •
      uses: actions/setup-node@v3
      with:
        node-version: 18.x

    - name: ì˜ì¡´ì„± ì„¤ì¹˜
      run: npm ci

    - name: Supabase ì„¤ì •
      run: |
        npm install -g supabase
        supabase init
        supabase db push

    - name: í†µí•© í…ŒìŠ¤íŠ¸ ì‹¤í–‰
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test
      run: npm run test:integration

  e2e-tests:
    runs-on: ubuntu-latest
    needs: integration-tests

    steps:
    - uses: actions/checkout@v3

    - name: Node.js ì„¤ì •
      uses: actions/setup-node@v3
      with:
        node-version: 18.x

    - name: ì˜ì¡´ì„± ì„¤ì¹˜
      run: |
        npm ci
        npx playwright install

    - name: ì• í”Œë¦¬ì¼€ì´ì…˜ ë¹Œë“œ
      run: npm run build

    - name: E2E í…ŒìŠ¤íŠ¸ ì‹¤í–‰
      run: npm run test:e2e

    - name: í…ŒìŠ¤íŠ¸ ê²°ê³¼ ì—…ë¡œë“œ
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: playwright-report
        path: playwright-report/
        retention-days: 30

  performance-tests:
    runs-on: ubuntu-latest
    needs: e2e-tests
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
    - uses: actions/checkout@v3

    - name: ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ ì‹¤í–‰
      run: |
        npm ci
        npm run build
        npm run test:performance

    - name: ì„±ëŠ¥ ë¦¬í¬íŠ¸ ìƒì„±
      run: |
        echo "## ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ ê²°ê³¼" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        cat performance-report.json | jq -r '.summary' >> $GITHUB_STEP_SUMMARY

```

## 12.5 í…ŒìŠ¤íŠ¸ ëª¨ë‹ˆí„°ë§ ë° ë¦¬í¬íŒ…

### í…ŒìŠ¤íŠ¸ ëŒ€ì‹œë³´ë“œ ì„¤ì •

```jsx
// í…ŒìŠ¤íŠ¸ ë©”íŠ¸ë¦­ ìˆ˜ì§‘ê¸° (tests/metrics-collector.js)
class TestMetricsCollector {
  constructor() {
    this.metrics = {
      testRuns: [],
      coverage: [],
      performance: [],
      flakiness: new Map()
    };
  }

  // í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ê²°ê³¼ ìˆ˜ì§‘
  collectTestRun(results) {
    const summary = {
      timestamp: new Date(),
      duration: results.duration,
      total: results.numTotalTests,
      passed: results.numPassedTests,
      failed: results.numFailedTests,
      skipped: results.numPendingTests,
      coverage: results.coverageMap ? this.summarizeCoverage(results.coverageMap) : null
    };

    this.metrics.testRuns.push(summary);

    // Flaky í…ŒìŠ¤íŠ¸ ì¶”ì 
    this.trackFlakyTests(results);

    return summary;
  }

  // Flaky í…ŒìŠ¤íŠ¸ ê°ì§€
  trackFlakyTests(results) {
    results.testResults.forEach(testFile => {
      testFile.testResults.forEach(test => {
        const testId = `${testFile.testFilePath}::${test.fullName}`;

        if (!this.metrics.flakiness.has(testId)) {
          this.metrics.flakiness.set(testId, {
            runs: 0,
            failures: 0,
            lastFailure: null
          });
        }

        const stats = this.metrics.flakiness.get(testId);
        stats.runs++;

        if (test.status === 'failed') {
          stats.failures++;
          stats.lastFailure = new Date();
        }

        // Flakiness ë¹„ìœ¨ ê³„ì‚°
        stats.flakiness = (stats.failures / stats.runs) * 100;
      });
    });
  }

  // ì£¼ê°„ ë¦¬í¬íŠ¸ ìƒì„±
  generateWeeklyReport() {
    const oneWeekAgo = new Date();
    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);

    const weeklyRuns = this.metrics.testRuns.filter(run =>
      run.timestamp > oneWeekAgo
    );

    // Flaky í…ŒìŠ¤íŠ¸ TOP 10
    const flakyTests = Array.from(this.metrics.flakiness.entries())
      .filter(([, stats]) => stats.flakiness > 10)
      .sort(([, a], [, b]) => b.flakiness - a.flakiness)
      .slice(0, 10);

    return {
      period: {
        start: oneWeekAgo,
        end: new Date()
      },
      summary: {
        totalRuns: weeklyRuns.length,
        avgDuration: this.average(weeklyRuns.map(r => r.duration)),
        successRate: this.average(weeklyRuns.map(r => r.passed / r.total * 100)),
        avgCoverage: this.average(weeklyRuns.map(r => r.coverage?.overall || 0))
      },
      trends: {
        duration: this.calculateTrend(weeklyRuns, 'duration'),
        coverage: this.calculateTrend(weeklyRuns, 'coverage.overall'),
        failures: this.calculateTrend(weeklyRuns, 'failed')
      },
      issues: {
        flakyTests: flakyTests.map(([testId, stats]) => ({
          test: testId,
          flakiness: `${stats.flakiness.toFixed(1)}%`,
          failures: `${stats.failures}/${stats.runs}`,
          lastFailure: stats.lastFailure
        })),
        coverageDrops: this.detectCoverageDrops(weeklyRuns),
        performanceRegression: this.detectPerformanceRegression(weeklyRuns)
      }
    };
  }
}

```