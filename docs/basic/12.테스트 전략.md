# 테스트 전략 (Testing Strategy)

## 12.1 단위 테스트

### 12.1.1 Jest 설정

### 기본 설정 파일 (jest.config.js)

```jsx
module.exports = {
  // 테스트 환경 설정
  testEnvironment: 'node',

  // 테스트 파일 패턴
  testMatch: [
    '**/tests/unit/**/*.test.js',
    '**/tests/unit/**/*.spec.js'
  ],

  // 커버리지 설정
  collectCoverage: true,
  coverageDirectory: 'coverage',
  coveragePathIgnorePatterns: [
    '/node_modules/',
    '/tests/',
    '/mobile/'
  ],

  // 최소 커버리지 임계값
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 85,
      lines: 85,
      statements: 85
    }
  },

  // 모듈 별칭 설정
  moduleNameMapper: {
    '@/(.*)': '<rootDir>/backend/$1',
    '@supabase/(.*)': '<rootDir>/tests/mocks/supabase/$1'
  },

  // Setup 파일
  setupFilesAfterEnv: ['<rootDir>/tests/setup.js'],

  // 타임아웃 설정
  testTimeout: 10000
};

```

### 테스트 환경 설정 (tests/setup.js)

```jsx
// 환경 변수 설정
process.env.NODE_ENV = 'test';
process.env.SUPABASE_URL = 'https://test.supabase.co';
process.env.SUPABASE_ANON_KEY = 'test-anon-key';
process.env.YOUTUBE_API_KEY = 'test-youtube-key';
process.env.CLAUDE_API_KEY = 'test-claude-key';

// 전역 Mock 설정
global.fetch = jest.fn();
global.console = {
  ...console,
  error: jest.fn(),
  warn: jest.fn(),
  log: jest.fn()
};

// Supabase Mock
jest.mock('@supabase/supabase-js', () => ({
  createClient: jest.fn(() => ({
    auth: {
      signUp: jest.fn(),
      signIn: jest.fn(),
      signOut: jest.fn(),
      getUser: jest.fn()
    },
    from: jest.fn(() => ({
      select: jest.fn().mockReturnThis(),
      insert: jest.fn().mockReturnThis(),
      update: jest.fn().mockReturnThis(),
      delete: jest.fn().mockReturnThis(),
      eq: jest.fn().mockReturnThis(),
      single: jest.fn()
    }))
  }))
}));

```

### 12.1.2 테스트 커버리지

### 핵심 모듈별 테스트 우선순위

```jsx
// 테스트 우선순위 매트릭스
const testPriority = {
  critical: [
    'auth.js',              // 인증 관련 - 95% 커버리지
    'youtube-service.js',   // YouTube API - 90% 커버리지
    'keyword-extractor.js', // AI 키워드 추출 - 90% 커버리지
    'mcp-server.js'        // MCP 구현 - 90% 커버리지
  ],
  high: [
    'cache-manager.js',     // 캐싱 시스템 - 85% 커버리지
    'api-quota.js',        // API 할당량 관리 - 85% 커버리지
    'personalization.js'   // 개인화 엔진 - 85% 커버리지
  ],
  medium: [
    'trend-analyzer.js',    // 트렌드 분석 - 80% 커버리지
    'video-filter.js',     // 영상 필터링 - 80% 커버리지
    'user-preferences.js'  // 사용자 선호도 - 80% 커버리지
  ]
};

```

### 12.1.3 모킹 전략

### YouTube API Mock (tests/mocks/youtube-api.mock.js)

```jsx
const mockSearchResponse = {
  data: {
    items: [
      {
        id: { videoId: 'test123' },
        snippet: {
          title: '테스트 영상',
          description: '테스트 설명',
          channelTitle: '테스트 채널',
          thumbnails: {
            default: { url: 'https://test.com/thumb.jpg' }
          }
        }
      }
    ],
    pageInfo: {
      totalResults: 100,
      resultsPerPage: 50
    }
  }
};

const mockVideoDetailsResponse = {
  data: {
    items: [
      {
        id: 'test123',
        contentDetails: {
          duration: 'PT59S'  // 59초 (Shorts)
        },
        statistics: {
          viewCount: '150000',
          likeCount: '5000'
        },
        status: {
          embeddable: true
        }
      }
    ]
  }
};

module.exports = {
  mockSearchResponse,
  mockVideoDetailsResponse,
  // API 할당량 시뮬레이션
  mockQuotaExceeded: {
    response: {
      status: 403,
      data: {
        error: {
          code: 403,
          message: 'Quota exceeded'
        }
      }
    }
  }
};

```

### Claude API Mock (tests/mocks/claude-api.mock.js)

```jsx
const mockKeywordExtraction = {
  // 다양한 시나리오별 응답
  casual: {
    keywords: ['힐링', '휴식', '자연', 'ASMR'],
    mood: 'relaxed',
    context: 'evening_rest'
  },
  energetic: {
    keywords: ['댄스', '운동', '에너지', '신나는'],
    mood: 'excited',
    context: 'morning_motivation'
  },
  educational: {
    keywords: ['요리', '레시피', '팁', '꿀팁'],
    mood: 'curious',
    context: 'learning'
  }
};

// MCP 도구 호출 Mock
const mockMCPTools = {
  searchPersonalizedShorts: jest.fn(),
  analyzeUserMood: jest.fn(),
  generateContextualResponse: jest.fn(),
  analyzeTrends: jest.fn()
};

module.exports = {
  mockKeywordExtraction,
  mockMCPTools
};

```

## 12.2 통합 테스트

### 12.2.1 API 테스트

### 인증 플로우 통합 테스트 (tests/integration/auth.test.js)

```jsx
const request = require('supertest');
const app = require('../../backend/server');
const { createClient } = require('@supabase/supabase-js');

describe('Authentication Flow Integration Tests', () => {
  let server;
  let testUser;

  beforeAll(async () => {
    server = app.listen(0);
    testUser = {
      email: 'test@example.com',
      password: 'TestPassword123!',
      name: '테스트 사용자'
    };
  });

  afterAll(async () => {
    await server.close();
  });

  describe('회원가입 프로세스', () => {
    test('정상적인 회원가입', async () => {
      const response = await request(server)
        .post('/api/register')
        .send(testUser)
        .expect(201);

      expect(response.body).toMatchObject({
        success: true,
        user: {
          email: testUser.email,
          name: testUser.name
        }
      });

      // 데이터베이스 확인
      expect(createClient).toHaveBeenCalled();
    });

    test('중복 이메일 처리', async () => {
      // 첫 번째 가입
      await request(server)
        .post('/api/register')
        .send(testUser);

      // 중복 가입 시도
      const response = await request(server)
        .post('/api/register')
        .send(testUser)
        .expect(409);

      expect(response.body).toMatchObject({
        success: false,
        error: '이미 등록된 이메일입니다'
      });
    });

    test('유효하지 않은 이메일 형식', async () => {
      const response = await request(server)
        .post('/api/register')
        .send({
          ...testUser,
          email: 'invalid-email'
        })
        .expect(400);

      expect(response.body.error).toContain('유효한 이메일');
    });
  });

  describe('로그인/로그아웃 프로세스', () => {
    let authToken;

    test('정상적인 로그인', async () => {
      const response = await request(server)
        .post('/api/login')
        .send({
          email: testUser.email,
          password: testUser.password
        })
        .expect(200);

      expect(response.body).toHaveProperty('token');
      authToken = response.body.token;

      // JWT 토큰 검증
      expect(authToken).toMatch(/^eyJ/);
    });

    test('잘못된 비밀번호', async () => {
      const response = await request(server)
        .post('/api/login')
        .send({
          email: testUser.email,
          password: 'WrongPassword'
        })
        .expect(401);

      expect(response.body.error).toContain('인증 실패');
    });

    test('인증된 요청 테스트', async () => {
      const response = await request(server)
        .get('/api/user/profile')
        .set('Authorization', `Bearer ${authToken}`)
        .expect(200);

      expect(response.body.user.email).toBe(testUser.email);
    });
  });
});

```

### 12.2.2 E2E 테스트

### Playwright 설정 (playwright.config.js)

```jsx
module.exports = {
  testDir: './tests/e2e',
  timeout: 30000,
  retries: 2,
  workers: 1,

  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure'
  },

  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] }
    },
    {
      name: 'mobile',
      use: { ...devices['iPhone 13'] }
    }
  ],

  webServer: {
    command: 'npm run dev',
    port: 3000,
    reuseExistingServer: !process.env.CI
  }
};

```

### 핵심 사용자 시나리오 E2E 테스트 (tests/e2e/user-journey.spec.js)

```jsx
const { test, expect } = require('@playwright/test');

test.describe('YouTube Shorts 큐레이션 사용자 여정', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
  });

  test('신규 사용자 첫 방문 시나리오', async ({ page }) => {
    // 1. 메인 페이지 접속
    await expect(page.locator('h1')).toContainText('YouTube Shorts');

    // 2. 트렌드 키워드 확인
    const trendingKeywords = page.locator('.trending-keywords .keyword-card');
    await expect(trendingKeywords).toHaveCount(8);

    // 3. 키워드 클릭
    await trendingKeywords.first().click();

    // 4. 영상 리스트 로딩 확인
    await expect(page.locator('.video-grid')).toBeVisible();
    const videos = page.locator('.video-card');
    await expect(videos.first()).toBeVisible({ timeout: 5000 });

    // 5. 무한 스크롤 테스트
    const initialCount = await videos.count();
    await page.evaluate(() => window.scrollTo(0, document.body.scrollHeight));
    await page.waitForTimeout(1000);
    const afterScrollCount = await videos.count();
    expect(afterScrollCount).toBeGreaterThan(initialCount);

    // 6. 영상 재생
    await videos.first().click();
    await expect(page.locator('iframe[src*="youtube.com"]')).toBeVisible();
  });

  test('프리미엄 사용자 대화형 검색', async ({ page }) => {
    // 로그인
    await page.goto('/login');
    await page.fill('input[name="email"]', 'premium@test.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');

    // 대화 페이지로 이동
    await page.click('nav >> text=AI 추천');

    // 대화 시작
    await page.fill('.chat-input', '저녁에 편안하게 볼 수 있는 영상 추천해줘');
    await page.keyboard.press('Enter');

    // AI 응답 대기
    await expect(page.locator('.ai-response')).toBeVisible({ timeout: 10000 });

    // 추천 키워드 확인
    const suggestedKeywords = page.locator('.suggested-keywords button');
    await expect(suggestedKeywords).toHaveCount(4);

    // 키워드 선택
    await suggestedKeywords.first().click();

    // 영상 결과 확인
    await expect(page.locator('.recommended-videos')).toBeVisible();
  });

  test('모바일 반응형 테스트', async ({ page, isMobile }) => {
    if (!isMobile) {
      await page.setViewportSize({ width: 375, height: 667 });
    }

    // 햄버거 메뉴 확인
    await expect(page.locator('.mobile-menu-toggle')).toBeVisible();

    // 메뉴 열기
    await page.click('.mobile-menu-toggle');
    await expect(page.locator('.mobile-nav')).toBeVisible();

    // 영상 카드 레이아웃 확인
    await page.goto('/videos/trending');
    const videoGrid = page.locator('.video-grid');
    const gridColumns = await videoGrid.evaluate(el =>
      window.getComputedStyle(el).gridTemplateColumns
    );
    expect(gridColumns).toContain('1fr');  // 모바일에서는 1열
  });
});

```

### 12.2.3 성능 테스트

### 부하 테스트 스크립트 (tests/performance/load-test.js)

```jsx
const autocannon = require('autocannon');
const { performance } = require('perf_hooks');

// 부하 테스트 시나리오
const scenarios = {
  // 기본 API 엔드포인트 테스트
  basic: {
    title: '기본 API 부하 테스트',
    url: 'http://localhost:3000/api/health',
    connections: 10,
    duration: 30,
    pipelining: 1
  },

  // 검색 API 부하 테스트
  search: {
    title: '검색 API 부하 테스트',
    url: 'http://localhost:3000/api/search',
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': 'Bearer test-token'
    },
    body: JSON.stringify({
      keyword: '요리',
      source: 'cache'
    }),
    connections: 50,
    duration: 60,
    pipelining: 10
  },

  // 동시 사용자 시뮬레이션
  concurrent: {
    title: '동시 사용자 시뮬레이션',
    url: 'http://localhost:3000',
    connections: 100,
    duration: 120,
    pipelining: 1,
    bailout: 1000  // 1초 이상 응답 시 실패
  }
};

// 성능 메트릭 수집
class PerformanceCollector {
  constructor() {
    this.metrics = {
      responseTime: [],
      throughput: [],
      errors: 0,
      timeouts: 0
    };
  }

  collect(result) {
    this.metrics.responseTime.push({
      p50: result.latency.p50,
      p90: result.latency.p90,
      p99: result.latency.p99,
      mean: result.latency.mean
    });

    this.metrics.throughput.push({
      requests: result.requests.total,
      bytes: result.throughput.total,
      duration: result.duration
    });

    this.metrics.errors += result.errors;
    this.metrics.timeouts += result.timeouts;
  }

  generateReport() {
    const avgResponseTime = this.metrics.responseTime.reduce((acc, curr) =>
      acc + curr.mean, 0) / this.metrics.responseTime.length;

    const totalRequests = this.metrics.throughput.reduce((acc, curr) =>
      acc + curr.requests, 0);

    return {
      summary: {
        avgResponseTime: `${avgResponseTime.toFixed(2)}ms`,
        totalRequests,
        errorRate: `${((this.metrics.errors / totalRequests) * 100).toFixed(2)}%`,
        timeoutRate: `${((this.metrics.timeouts / totalRequests) * 100).toFixed(2)}%`
      },
      details: this.metrics
    };
  }
}

// 테스트 실행
async function runLoadTests() {
  const collector = new PerformanceCollector();

  for (const [name, scenario] of Object.entries(scenarios)) {
    console.log(`\n실행 중: ${scenario.title}`);

    const result = await autocannon(scenario);
    collector.collect(result);

    console.log(`완료: ${result.requests.total} requests, ${result.errors} errors`);

    // 성능 기준 검증
    if (result.latency.p99 > 1000) {
      console.warn('⚠️  경고: P99 응답시간이 1초를 초과했습니다!');
    }

    if (result.errors > result.requests.total * 0.01) {
      console.error('❌ 실패: 에러율이 1%를 초과했습니다!');
    }
  }

  // 최종 보고서
  const report = collector.generateReport();
  console.log('\n=== 성능 테스트 최종 보고서 ===');
  console.log(JSON.stringify(report, null, 2));

  // 성능 기준 충족 여부
  const passed = report.summary.errorRate < 1 &&
                 parseFloat(report.summary.avgResponseTime) < 500;

  if (!passed) {
    throw new Error('성능 기준을 충족하지 못했습니다');
  }
}

// 메모리 누수 테스트
async function memoryLeakTest() {
  const baseline = process.memoryUsage().heapUsed;
  const iterations = 1000;

  for (let i = 0; i < iterations; i++) {
    // API 호출 시뮬레이션
    await fetch('http://localhost:3000/api/search', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ keyword: `test${i}` })
    });

    if (i % 100 === 0) {
      global.gc();  // 가비지 컬렉션 강제 실행
      const current = process.memoryUsage().heapUsed;
      const increase = ((current - baseline) / baseline) * 100;

      console.log(`반복 ${i}: 메모리 증가율 ${increase.toFixed(2)}%`);

      if (increase > 50) {
        console.error('❌ 메모리 누수 감지!');
        process.exit(1);
      }
    }
  }
}

// 실행
if (require.main === module) {
  runLoadTests()
    .then(() => memoryLeakTest())
    .catch(console.error);
}

```

## 12.3 사용자 테스트

### 12.3.1 베타 테스트 계획

### 베타 테스터 모집 및 관리

```jsx
// 베타 테스터 관리 시스템 (backend/beta-management.js)
class BetaTesterManager {
  constructor(supabaseClient) {
    this.supabase = supabaseClient;
    this.testGroups = {
      A: { feature: 'baseline', size: 100 },
      B: { feature: 'new_ui', size: 100 },
      C: { feature: 'advanced_mcp', size: 50 }
    };
  }

  // 베타 테스터 등록
  async registerBetaTester(userData) {
    const group = this.assignTestGroup(userData);

    const { data, error } = await this.supabase
      .from('beta_testers')
      .insert({
        user_id: userData.id,
        email: userData.email,
        test_group: group,
        enrolled_at: new Date(),
        consent_given: true,
        demographics: {
          age_range: userData.ageRange,
          youtube_usage: userData.youtubeUsage,
          device_type: userData.deviceType
        }
      });

    if (!error) {
      await this.sendWelcomeEmail(userData.email, group);
    }

    return { group, error };
  }

  // 테스트 그룹 자동 할당
  assignTestGroup(userData) {
    // 균등 분배 알고리즘
    const groups = Object.keys(this.testGroups);
    const hash = this.hashUserId(userData.id);
    return groups[hash % groups.length];
  }

  // 피드백 수집
  async collectFeedback(userId, feedback) {
    const enrichedFeedback = {
      ...feedback,
      user_id: userId,
      timestamp: new Date(),
      session_data: await this.getSessionData(userId),
      feature_usage: await this.getFeatureUsage(userId)
    };

    return await this.supabase
      .from('beta_feedback')
      .insert(enrichedFeedback);
  }

  // 사용 메트릭 추적
  async trackMetrics(userId, event) {
    const metrics = {
      user_id: userId,
      event_type: event.type,
      event_data: event.data,
      timestamp: new Date(),
      session_id: event.sessionId,
      test_group: await this.getUserTestGroup(userId)
    };

    // 실시간 분석을 위한 이벤트 발행
    this.publishAnalyticsEvent(metrics);

    return await this.supabase
      .from('beta_metrics')
      .insert(metrics);
  }
}

```

### 12.3.2 A/B 테스트

### A/B 테스트 프레임워크

```jsx
// A/B 테스트 관리자 (backend/ab-testing.js)
class ABTestManager {
  constructor() {
    this.experiments = new Map();
    this.results = new Map();
  }

  // 실험 정의
  defineExperiment(config) {
    const experiment = {
      id: config.id,
      name: config.name,
      variants: config.variants,
      metrics: config.metrics,
      startDate: new Date(),
      endDate: null,
      sampleSize: config.sampleSize,
      confidenceLevel: config.confidenceLevel || 0.95
    };

    this.experiments.set(config.id, experiment);
    return experiment;
  }

  // 주요 실험 설정
  setupExperiments() {
    // 1. 추천 알고리즘 테스트
    this.defineExperiment({
      id: 'recommendation_algorithm',
      name: '추천 알고리즘 최적화',
      variants: {
        control: { algorithm: 'collaborative_filtering' },
        treatment: { algorithm: 'mcp_enhanced' }
      },
      metrics: ['click_through_rate', 'watch_time', 'user_retention'],
      sampleSize: 1000
    });

    // 2. UI 레이아웃 테스트
    this.defineExperiment({
      id: 'video_layout',
      name: '영상 그리드 레이아웃',
      variants: {
        control: { layout: 'grid_2x2' },
        treatment_a: { layout: 'grid_3x3' },
        treatment_b: { layout: 'masonry' }
      },
      metrics: ['scroll_depth', 'videos_watched', 'bounce_rate'],
      sampleSize: 1500
    });

    // 3. 대화형 인터페이스 테스트
    this.defineExperiment({
      id: 'chat_interface',
      name: '대화형 추천 인터페이스',
      variants: {
        control: { interface: 'simple_search' },
        treatment: { interface: 'conversational_ai' }
      },
      metrics: ['engagement_rate', 'satisfaction_score', 'feature_adoption'],
      sampleSize: 500
    });
  }

  // 사용자를 실험 그룹에 할당
  assignUserToExperiment(userId, experimentId) {
    const experiment = this.experiments.get(experimentId);
    if (!experiment) return null;

    // 결정적 할당 (같은 사용자는 항상 같은 그룹)
    const hash = this.hashString(`${userId}-${experimentId}`);
    const variants = Object.keys(experiment.variants);
    const variantIndex = hash % variants.length;

    return {
      experimentId,
      variant: variants[variantIndex],
      config: experiment.variants[variants[variantIndex]]
    };
  }

  // 메트릭 수집 및 분석
  async analyzeResults(experimentId) {
    const experiment = this.experiments.get(experimentId);
    const data = await this.fetchExperimentData(experimentId);

    const results = {
      experimentId,
      sampleSizes: {},
      metrics: {}
    };

    // 각 변형별 결과 계산
    for (const variant of Object.keys(experiment.variants)) {
      const variantData = data.filter(d => d.variant === variant);
      results.sampleSizes[variant] = variantData.length;

      for (const metric of experiment.metrics) {
        if (!results.metrics[metric]) {
          results.metrics[metric] = {};
        }

        results.metrics[metric][variant] = {
          mean: this.calculateMean(variantData, metric),
          stdDev: this.calculateStdDev(variantData, metric),
          confidence: this.calculateConfidenceInterval(variantData, metric)
        };
      }
    }

    // 통계적 유의성 검정
    results.significance = this.performSignificanceTest(results);

    // 승자 결정
    results.winner = this.determineWinner(results);

    return results;
  }

  // 통계적 유의성 검정 (T-test)
  performSignificanceTest(results) {
    const significance = {};

    for (const metric of Object.keys(results.metrics)) {
      const control = results.metrics[metric].control;
      const treatments = Object.keys(results.metrics[metric])
        .filter(k => k !== 'control');

      significance[metric] = {};

      for (const treatment of treatments) {
        const treatmentData = results.metrics[metric][treatment];

        // T-test 수행
        const tScore = this.calculateTScore(
          control.mean, treatmentData.mean,
          control.stdDev, treatmentData.stdDev,
          results.sampleSizes.control, results.sampleSizes[treatment]
        );

        const pValue = this.calculatePValue(tScore,
          results.sampleSizes.control + results.sampleSizes[treatment] - 2
        );

        significance[metric][treatment] = {
          tScore,
          pValue,
          isSignificant: pValue < 0.05,
          improvement: ((treatmentData.mean - control.mean) / control.mean) * 100
        };
      }
    }

    return significance;
  }
}

```

### 12.3.3 피드백 수집

### 실시간 피드백 시스템

```jsx
// 피드백 수집 위젯 (frontend/js/components/FeedbackWidget.js)
class FeedbackWidget extends Component {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this.feedbackTypes = ['bug', 'feature', 'ui', 'performance'];
    this.sessionData = this.collectSessionData();
  }

  connectedCallback() {
    this.render();
    this.setupEventListeners();
    this.setupHotkeys();
  }

  render() {
    this.shadowRoot.innerHTML = `
      <style>
        :host {
          position: fixed;
          bottom: 20px;
          right: 20px;
          z-index: 1000;
        }

        .feedback-button {
          background: #ff6b6b;
          color: white;
          border: none;
          border-radius: 50%;
          width: 60px;
          height: 60px;
          font-size: 24px;
          cursor: pointer;
          box-shadow: 0 4px 12px rgba(0,0,0,0.15);
          transition: transform 0.2s;
        }

        .feedback-button:hover {
          transform: scale(1.1);
        }

        .feedback-modal {
          display: none;
          position: fixed;
          bottom: 90px;
          right: 20px;
          background: white;
          border-radius: 12px;
          box-shadow: 0 10px 40px rgba(0,0,0,0.15);
          width: 400px;
          max-height: 600px;
          overflow-y: auto;
        }

        .feedback-modal.active {
          display: block;
          animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp {
          from {
            opacity: 0;
            transform: translateY(20px);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }

        .modal-header {
          padding: 20px;
          border-bottom: 1px solid #eee;
        }

        .modal-body {
          padding: 20px;
        }

        .feedback-type {
          display: flex;
          gap: 10px;
          margin-bottom: 20px;
        }

        .type-button {
          flex: 1;
          padding: 10px;
          border: 2px solid #eee;
          background: white;
          border-radius: 8px;
          cursor: pointer;
          transition: all 0.2s;
        }

        .type-button.selected {
          border-color: #ff6b6b;
          background: #fff5f5;
        }

        .feedback-form textarea {
          width: 100%;
          min-height: 120px;
          padding: 12px;
          border: 2px solid #eee;
          border-radius: 8px;
          resize: vertical;
        }

        .screenshot-preview {
          margin: 15px 0;
          max-width: 100%;
          border-radius: 8px;
          border: 2px solid #eee;
        }

        .submit-button {
          width: 100%;
          padding: 12px;
          background: #ff6b6b;
          color: white;
          border: none;
          border-radius: 8px;
          font-size: 16px;
          cursor: pointer;
        }

        .nps-survey {
          margin: 20px 0;
        }

        .nps-scale {
          display: flex;
          justify-content: space-between;
          margin: 10px 0;
        }

        .nps-button {
          width: 30px;
          height: 30px;
          border: 1px solid #ddd;
          background: white;
          cursor: pointer;
          transition: all 0.2s;
        }

        .nps-button:hover {
          background: #f0f0f0;
        }

        .nps-button.selected {
          background: #ff6b6b;
          color: white;
          border-color: #ff6b6b;
        }
      </style>

      <button class="feedback-button" id="feedbackTrigger">
        💬
      </button>

      <div class="feedback-modal" id="feedbackModal">
        <div class="modal-header">
          <h3>피드백 보내기</h3>
          <p>여러분의 의견이 서비스를 개선합니다!</p>
        </div>

        <div class="modal-body">
          <div class="feedback-type">
            <button class="type-button" data-type="bug">🐛 버그</button>
            <button class="type-button" data-type="feature">✨ 기능 제안</button>
            <button class="type-button" data-type="ui">🎨 UI/UX</button>
            <button class="type-button" data-type="performance">⚡ 성능</button>
          </div>

          <form id="feedbackForm">
            <textarea
              placeholder="어떤 점을 개선하면 좋을까요?"
              required
            ></textarea>

            <div class="screenshot-section">
              <label>
                <input type="checkbox" id="includeScreenshot">
                현재 화면 스크린샷 포함
              </label>
              <img class="screenshot-preview" id="screenshotPreview" style="display:none;">
            </div>

            <div class="nps-survey">
              <p>이 서비스를 친구에게 추천하시겠습니까?</p>
              <div class="nps-scale">
                ${[...Array(11)].map((_, i) =>
                  `<button type="button" class="nps-button" data-score="${i}">${i}</button>`
                ).join('')}
              </div>
              <div style="display:flex;justify-content:space-between;font-size:12px;color:#666;">
                <span>추천하지 않음</span>
                <span>적극 추천</span>
              </div>
            </div>

            <button type="submit" class="submit-button">
              피드백 전송
            </button>
          </form>
        </div>
      </div>
    `;
  }

  setupEventListeners() {
    const trigger = this.shadowRoot.getElementById('feedbackTrigger');
    const modal = this.shadowRoot.getElementById('feedbackModal');
    const form = this.shadowRoot.getElementById('feedbackForm');

    // 모달 토글
    trigger.addEventListener('click', () => {
      modal.classList.toggle('active');
      if (modal.classList.contains('active')) {
        this.trackEvent('feedback_modal_opened');
      }
    });

    // 피드백 타입 선택
    this.shadowRoot.querySelectorAll('.type-button').forEach(button => {
      button.addEventListener('click', (e) => {
        this.shadowRoot.querySelectorAll('.type-button').forEach(b =>
          b.classList.remove('selected')
        );
        e.target.classList.add('selected');
        this.selectedType = e.target.dataset.type;
      });
    });

    // NPS 점수 선택
    this.shadowRoot.querySelectorAll('.nps-button').forEach(button => {
      button.addEventListener('click', (e) => {
        this.shadowRoot.querySelectorAll('.nps-button').forEach(b =>
          b.classList.remove('selected')
        );
        e.target.classList.add('selected');
        this.npsScore = parseInt(e.target.dataset.score);
      });
    });

    // 스크린샷 옵션
    const screenshotCheckbox = this.shadowRoot.getElementById('includeScreenshot');
    screenshotCheckbox.addEventListener('change', async (e) => {
      if (e.target.checked) {
        const screenshot = await this.captureScreenshot();
        const preview = this.shadowRoot.getElementById('screenshotPreview');
        preview.src = screenshot;
        preview.style.display = 'block';
      } else {
        this.shadowRoot.getElementById('screenshotPreview').style.display = 'none';
      }
    });

    // 폼 제출
    form.addEventListener('submit', async (e) => {
      e.preventDefault();
      await this.submitFeedback();
    });
  }

  setupHotkeys() {
    // Ctrl+Shift+F로 피드백 모달 열기
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.shiftKey && e.key === 'F') {
        e.preventDefault();
        this.shadowRoot.getElementById('feedbackModal').classList.toggle('active');
      }
    });
  }

  async captureScreenshot() {
    // 실제 구현에서는 html2canvas 라이브러리 사용
    return 'data:image/png;base64,placeholder';
  }

  collectSessionData() {
    return {
      url: window.location.href,
      userAgent: navigator.userAgent,
      screenResolution: `${screen.width}x${screen.height}`,
      viewport: `${window.innerWidth}x${window.innerHeight}`,
      timestamp: new Date().toISOString(),
      sessionId: this.getSessionId(),
      userId: this.getUserId()
    };
  }

  async submitFeedback() {
    const textarea = this.shadowRoot.querySelector('textarea');
    const screenshot = this.shadowRoot.getElementById('includeScreenshot').checked
      ? this.shadowRoot.getElementById('screenshotPreview').src
      : null;

    const feedbackData = {
      type: this.selectedType || 'general',
      message: textarea.value,
      npsScore: this.npsScore,
      screenshot,
      sessionData: this.sessionData,
      metadata: {
        currentPage: window.location.pathname,
        referrer: document.referrer,
        timeSpentOnPage: performance.now() / 1000
      }
    };

    try {
      const response = await fetch('/api/feedback', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${this.getAuthToken()}`
        },
        body: JSON.stringify(feedbackData)
      });

      if (response.ok) {
        this.showSuccessMessage();
        this.shadowRoot.getElementById('feedbackModal').classList.remove('active');
        textarea.value = '';

        // 분석 이벤트 전송
        this.trackEvent('feedback_submitted', {
          type: feedbackData.type,
          npsScore: feedbackData.npsScore
        });
      }
    } catch (error) {
      console.error('피드백 전송 실패:', error);
      this.showErrorMessage();
    }
  }

  trackEvent(eventName, data = {}) {
    // 분석 이벤트 전송
    if (window.analytics) {
      window.analytics.track(eventName, {
        ...data,
        component: 'FeedbackWidget'
      });
    }
  }
}

// 웹 컴포넌트 등록
customElements.define('feedback-widget', FeedbackWidget);

```

### 피드백 분석 대시보드

```jsx
// 피드백 분석 시스템 (backend/feedback-analytics.js)
class FeedbackAnalytics {
  constructor(supabaseClient) {
    this.supabase = supabaseClient;
    this.sentimentAnalyzer = new SentimentAnalyzer();
    this.categories = {
      bug: ['버그', '오류', '에러', '작동', '안됨'],
      feature: ['기능', '추가', '제안', '있으면', '했으면'],
      ui: ['디자인', 'UI', 'UX', '화면', '보기'],
      performance: ['느림', '빠름', '속도', '로딩', '성능']
    };
  }

  // 피드백 자동 분류
  async categorizeFeedback(feedback) {
    const text = feedback.message.toLowerCase();
    const scores = {};

    // 키워드 매칭
    for (const [category, keywords] of Object.entries(this.categories)) {
      scores[category] = keywords.filter(keyword =>
        text.includes(keyword)
      ).length;
    }

    // AI 기반 분류 (MCP 활용)
    if (this.mcpClient) {
      const aiCategory = await this.mcpClient.categorize(text);
      scores[aiCategory] = (scores[aiCategory] || 0) + 2;
    }

    // 최종 카테고리 결정
    const primaryCategory = Object.entries(scores)
      .sort(([,a], [,b]) => b - a)[0][0];

    return {
      primary: primaryCategory,
      confidence: scores[primaryCategory] / Object.values(scores).reduce((a,b) => a+b, 0),
      allScores: scores
    };
  }

  // 감성 분석
  async analyzeSentiment(feedback) {
    const sentiment = await this.sentimentAnalyzer.analyze(feedback.message);

    return {
      score: sentiment.score,  // -1 ~ 1
      magnitude: sentiment.magnitude,
      label: sentiment.score > 0.3 ? 'positive'
           : sentiment.score < -0.3 ? 'negative'
           : 'neutral'
    };
  }

  // 실시간 대시보드 데이터
  async getDashboardMetrics(timeRange = '7d') {
    const startDate = this.getStartDate(timeRange);

    // 기본 메트릭
    const { data: feedbacks } = await this.supabase
      .from('feedback')
      .select('*')
      .gte('created_at', startDate);

    // NPS 계산
    const npsScores = feedbacks
      .filter(f => f.nps_score !== null)
      .map(f => f.nps_score);

    const nps = this.calculateNPS(npsScores);

    // 카테고리별 분포
    const categoryDistribution = await this.getCategoryDistribution(feedbacks);

    // 감성 분석 결과
    const sentimentDistribution = await this.getSentimentDistribution(feedbacks);

    // 주요 이슈 추출
    const topIssues = await this.extractTopIssues(feedbacks);

    // 응답률 계산
    const responseMetrics = await this.getResponseMetrics(feedbacks);

    return {
      summary: {
        totalFeedbacks: feedbacks.length,
        npsScore: nps.score,
        npsCategory: nps.category,
        avgSentiment: sentimentDistribution.average,
        responseRate: responseMetrics.rate
      },
      distributions: {
        categories: categoryDistribution,
        sentiment: sentimentDistribution,
        nps: nps.distribution
      },
      trends: {
        daily: await this.getDailyTrends(startDate),
        weekly: await this.getWeeklyTrends()
      },
      insights: {
        topIssues,
        improvementAreas: await this.getImprovementAreas(feedbacks),
        userSegments: await this.getUserSegmentAnalysis(feedbacks)
      }
    };
  }

  // NPS 계산
  calculateNPS(scores) {
    const promoters = scores.filter(s => s >= 9).length;
    const detractors = scores.filter(s => s <= 6).length;
    const total = scores.length;

    const npsScore = ((promoters - detractors) / total) * 100;

    return {
      score: Math.round(npsScore),
      category: npsScore >= 50 ? 'Excellent'
              : npsScore >= 0 ? 'Good'
              : 'Needs Improvement',
      distribution: {
        promoters: (promoters / total) * 100,
        passives: ((total - promoters - detractors) / total) * 100,
        detractors: (detractors / total) * 100
      }
    };
  }

  // 주요 이슈 추출
  async extractTopIssues(feedbacks) {
    const issues = [];

    // 부정적 피드백 중 자주 언급되는 키워드 추출
    const negativeFeedbacks = feedbacks.filter(f =>
      f.sentiment && f.sentiment.score < -0.3
    );

    // 텍스트 마이닝
    const wordFrequency = {};
    negativeFeedbacks.forEach(feedback => {
      const words = feedback.message.split(/\s+/);
      words.forEach(word => {
        if (word.length > 3) {  // 의미있는 단어만
          wordFrequency[word] = (wordFrequency[word] || 0) + 1;
        }
      });
    });

    // 상위 이슈 선정
    const topWords = Object.entries(wordFrequency)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 10);

    for (const [word, frequency] of topWords) {
      const relatedFeedbacks = negativeFeedbacks.filter(f =>
        f.message.includes(word)
      );

      issues.push({
        keyword: word,
        frequency,
        severity: this.calculateSeverity(relatedFeedbacks),
        examples: relatedFeedbacks.slice(0, 3).map(f => ({
          message: f.message,
          date: f.created_at
        }))
      });
    }

    return issues;
  }
}

```

## 12.4 테스트 자동화 및 CI/CD

### GitHub Actions 워크플로우 (.github/workflows/test.yml)

```yaml
name: 테스트 자동화

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  unit-tests:
    runs-on: ubuntu-latest

    strategy:
      matrix:
        node-version: [16.x, 18.x]

    steps:
    - uses: actions/checkout@v3

    - name: Node.js ${{ matrix.node-version }} 설정
      uses: actions/setup-node@v3
      with:
        node-version: ${{ matrix.node-version }}
        cache: 'npm'

    - name: 의존성 설치
      run: npm ci

    - name: 린트 검사
      run: npm run lint

    - name: 단위 테스트 실행
      run: npm run test:unit

    - name: 커버리지 리포트 업로드
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage/lcov.info
        flags: unittests
        name: codecov-umbrella

  integration-tests:
    runs-on: ubuntu-latest
    needs: unit-tests

    services:
      postgres:
        image: supabase/postgres:14.1.0
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
    - uses: actions/checkout@v3

    - name: Node.js 설정
      uses: actions/setup-node@v3
      with:
        node-version: 18.x

    - name: 의존성 설치
      run: npm ci

    - name: Supabase 설정
      run: |
        npm install -g supabase
        supabase init
        supabase db push

    - name: 통합 테스트 실행
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test
      run: npm run test:integration

  e2e-tests:
    runs-on: ubuntu-latest
    needs: integration-tests

    steps:
    - uses: actions/checkout@v3

    - name: Node.js 설정
      uses: actions/setup-node@v3
      with:
        node-version: 18.x

    - name: 의존성 설치
      run: |
        npm ci
        npx playwright install

    - name: 애플리케이션 빌드
      run: npm run build

    - name: E2E 테스트 실행
      run: npm run test:e2e

    - name: 테스트 결과 업로드
      uses: actions/upload-artifact@v3
      if: always()
      with:
        name: playwright-report
        path: playwright-report/
        retention-days: 30

  performance-tests:
    runs-on: ubuntu-latest
    needs: e2e-tests
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
    - uses: actions/checkout@v3

    - name: 성능 테스트 실행
      run: |
        npm ci
        npm run build
        npm run test:performance

    - name: 성능 리포트 생성
      run: |
        echo "## 성능 테스트 결과" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        cat performance-report.json | jq -r '.summary' >> $GITHUB_STEP_SUMMARY

```

## 12.5 테스트 모니터링 및 리포팅

### 테스트 대시보드 설정

```jsx
// 테스트 메트릭 수집기 (tests/metrics-collector.js)
class TestMetricsCollector {
  constructor() {
    this.metrics = {
      testRuns: [],
      coverage: [],
      performance: [],
      flakiness: new Map()
    };
  }

  // 테스트 실행 결과 수집
  collectTestRun(results) {
    const summary = {
      timestamp: new Date(),
      duration: results.duration,
      total: results.numTotalTests,
      passed: results.numPassedTests,
      failed: results.numFailedTests,
      skipped: results.numPendingTests,
      coverage: results.coverageMap ? this.summarizeCoverage(results.coverageMap) : null
    };

    this.metrics.testRuns.push(summary);

    // Flaky 테스트 추적
    this.trackFlakyTests(results);

    return summary;
  }

  // Flaky 테스트 감지
  trackFlakyTests(results) {
    results.testResults.forEach(testFile => {
      testFile.testResults.forEach(test => {
        const testId = `${testFile.testFilePath}::${test.fullName}`;

        if (!this.metrics.flakiness.has(testId)) {
          this.metrics.flakiness.set(testId, {
            runs: 0,
            failures: 0,
            lastFailure: null
          });
        }

        const stats = this.metrics.flakiness.get(testId);
        stats.runs++;

        if (test.status === 'failed') {
          stats.failures++;
          stats.lastFailure = new Date();
        }

        // Flakiness 비율 계산
        stats.flakiness = (stats.failures / stats.runs) * 100;
      });
    });
  }

  // 주간 리포트 생성
  generateWeeklyReport() {
    const oneWeekAgo = new Date();
    oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);

    const weeklyRuns = this.metrics.testRuns.filter(run =>
      run.timestamp > oneWeekAgo
    );

    // Flaky 테스트 TOP 10
    const flakyTests = Array.from(this.metrics.flakiness.entries())
      .filter(([, stats]) => stats.flakiness > 10)
      .sort(([, a], [, b]) => b.flakiness - a.flakiness)
      .slice(0, 10);

    return {
      period: {
        start: oneWeekAgo,
        end: new Date()
      },
      summary: {
        totalRuns: weeklyRuns.length,
        avgDuration: this.average(weeklyRuns.map(r => r.duration)),
        successRate: this.average(weeklyRuns.map(r => r.passed / r.total * 100)),
        avgCoverage: this.average(weeklyRuns.map(r => r.coverage?.overall || 0))
      },
      trends: {
        duration: this.calculateTrend(weeklyRuns, 'duration'),
        coverage: this.calculateTrend(weeklyRuns, 'coverage.overall'),
        failures: this.calculateTrend(weeklyRuns, 'failed')
      },
      issues: {
        flakyTests: flakyTests.map(([testId, stats]) => ({
          test: testId,
          flakiness: `${stats.flakiness.toFixed(1)}%`,
          failures: `${stats.failures}/${stats.runs}`,
          lastFailure: stats.lastFailure
        })),
        coverageDrops: this.detectCoverageDrops(weeklyRuns),
        performanceRegression: this.detectPerformanceRegression(weeklyRuns)
      }
    };
  }
}

```