# API 설계 및 구현 (API Design & Implementation)

## 5.1 RESTful API 설계 원칙

### API 아키텍처 개요

```yaml
Base URL: https://api.shortscurator.com/v1
Protocol: HTTPS only
Format: JSON
Versioning: URL path (/v1, /v2)
Rate Limiting: Token bucket algorithm
Authentication: JWT Bearer tokens

```

### 설계 원칙

```yaml
RESTful 원칙:
  - 리소스 중심 URL 설계
  - HTTP 메소드 의미론적 사용
  - 상태 비저장 (Stateless)
  - 계층적 구조
  - 캐시 가능성

추가 원칙:
  - HATEOAS (선택적 적용)
  - 일관된 에러 응답
  - 페이지네이션 표준화
  - 필터링/정렬 지원
  - 부분 응답 지원 (fields 파라미터)

```

### API 응답 구조

```jsx
// 성공 응답
{
  "success": true,
  "data": {
    // 실제 데이터
  },
  "meta": {
    "timestamp": "2025-06-04T10:00:00Z",
    "version": "1.0",
    "request_id": "req_abc123"
  }
}

// 에러 응답
{
  "success": false,
  "error": {
    "code": "RESOURCE_NOT_FOUND",
    "message": "The requested video was not found",
    "details": {
      "video_id": "xyz789"
    }
  },
  "meta": {
    "timestamp": "2025-06-04T10:00:00Z",
    "request_id": "req_abc123"
  }
}

// 페이지네이션 응답
{
  "success": true,
  "data": [...],
  "pagination": {
    "current_page": 1,
    "per_page": 20,
    "total_pages": 10,
    "total_items": 195,
    "has_next": true,
    "has_prev": false
  },
  "meta": {...}
}

```

## 5.2 인증 및 권한 관리

### 5.2.1 JWT 토큰 전략

### JWT 구조 설계

```jsx
// JWT Payload 구조
{
  // 표준 클레임
  "sub": "user_uuid",           // Subject (user ID)
  "iat": 1717491600,            // Issued at
  "exp": 1717495200,            // Expiration (1시간)
  "nbf": 1717491600,            // Not before
  "jti": "token_unique_id",     // JWT ID

  // 커스텀 클레임
  "user": {
    "id": "user_uuid",
    "email": "user@example.com",
    "tier": "premium",
    "tier_expires": "2025-12-31T23:59:59Z"
  },
  "permissions": [
    "videos:read",
    "videos:like",
    "ai_chat:use",
    "trends:advanced"
  ],
  "session": {
    "id": "session_uuid",
    "device": "mobile",
    "ip": "1.2.3.4"
  }
}

```

### 토큰 관리 구현

```jsx
// token-manager.js
const jwt = require('jsonwebtoken');
const { createHash } = require('crypto');

class TokenManager {
  constructor() {
    this.accessTokenSecret = process.env.JWT_ACCESS_SECRET;
    this.refreshTokenSecret = process.env.JWT_REFRESH_SECRET;
    this.accessTokenExpiry = '1h';
    this.refreshTokenExpiry = '30d';
  }

  async generateTokenPair(user) {
    const tokenId = this.generateTokenId();

    // Access Token
    const accessToken = jwt.sign(
      {
        sub: user.id,
        jti: tokenId,
        user: {
          id: user.id,
          email: user.email,
          tier: user.user_tier,
          tier_expires: user.subscription_end
        },
        permissions: await this.getUserPermissions(user)
      },
      this.accessTokenSecret,
      {
        expiresIn: this.accessTokenExpiry,
        issuer: 'shortscurator.com',
        audience: 'shortscurator-api'
      }
    );

    // Refresh Token
    const refreshToken = jwt.sign(
      {
        sub: user.id,
        jti: tokenId,
        type: 'refresh'
      },
      this.refreshTokenSecret,
      {
        expiresIn: this.refreshTokenExpiry
      }
    );

    // 토큰 저장 (화이트리스트)
    await this.storeTokens(user.id, tokenId, refreshToken);

    return {
      access_token: accessToken,
      refresh_token: refreshToken,
      token_type: 'Bearer',
      expires_in: 3600
    };
  }

  async verifyAccessToken(token) {
    try {
      const decoded = jwt.verify(token, this.accessTokenSecret, {
        issuer: 'shortscurator.com',
        audience: 'shortscurator-api'
      });

      // 토큰 블랙리스트 확인
      if (await this.isTokenBlacklisted(decoded.jti)) {
        throw new Error('Token has been revoked');
      }

      return decoded;
    } catch (error) {
      throw new AuthError('Invalid access token', error);
    }
  }

  async refreshTokens(refreshToken) {
    try {
      const decoded = jwt.verify(refreshToken, this.refreshTokenSecret);

      // Refresh token 유효성 확인
      const stored = await this.getStoredToken(decoded.sub, decoded.jti);
      if (!stored || stored.refresh_token !== refreshToken) {
        throw new Error('Invalid refresh token');
      }

      // 새 토큰 쌍 생성
      const user = await this.getUser(decoded.sub);
      return this.generateTokenPair(user);
    } catch (error) {
      throw new AuthError('Token refresh failed', error);
    }
  }

  generateTokenId() {
    return createHash('sha256')
      .update(`${Date.now()}-${Math.random()}`)
      .digest('hex')
      .substring(0, 16);
  }
}

```

### 5.2.2 OAuth 2.0 구현

### OAuth 2.0 플로우

```jsx
// oauth-provider.js
class OAuthProvider {
  constructor() {
    this.providers = {
      google: {
        clientId: process.env.GOOGLE_CLIENT_ID,
        clientSecret: process.env.GOOGLE_CLIENT_SECRET,
        redirectUri: process.env.GOOGLE_REDIRECT_URI,
        scope: ['openid', 'email', 'profile']
      },
      kakao: {
        clientId: process.env.KAKAO_CLIENT_ID,
        clientSecret: process.env.KAKAO_CLIENT_SECRET,
        redirectUri: process.env.KAKAO_REDIRECT_URI
      }
    };
  }

  // Authorization Code Flow
  async getAuthorizationUrl(provider, state) {
    const config = this.providers[provider];
    const params = new URLSearchParams({
      client_id: config.clientId,
      redirect_uri: config.redirectUri,
      response_type: 'code',
      scope: config.scope?.join(' ') || '',
      state: state,
      access_type: 'offline',
      prompt: 'consent'
    });

    const urls = {
      google: `https://accounts.google.com/o/oauth2/v2/auth?${params}`,
      kakao: `https://kauth.kakao.com/oauth/authorize?${params}`
    };

    return urls[provider];
  }

  async exchangeCodeForTokens(provider, code) {
    const config = this.providers[provider];

    const tokenEndpoints = {
      google: 'https://oauth2.googleapis.com/token',
      kakao: 'https://kauth.kakao.com/oauth/token'
    };

    const response = await fetch(tokenEndpoints[provider], {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: new URLSearchParams({
        grant_type: 'authorization_code',
        code: code,
        client_id: config.clientId,
        client_secret: config.clientSecret,
        redirect_uri: config.redirectUri
      })
    });

    return response.json();
  }

  async getUserInfo(provider, accessToken) {
    const userInfoEndpoints = {
      google: 'https://www.googleapis.com/oauth2/v2/userinfo',
      kakao: 'https://kapi.kakao.com/v2/user/me'
    };

    const response = await fetch(userInfoEndpoints[provider], {
      headers: {
        'Authorization': `Bearer ${accessToken}`
      }
    });

    const data = await response.json();

    // 통합 사용자 정보 포맷
    return this.normalizeUserInfo(provider, data);
  }

  normalizeUserInfo(provider, data) {
    const normalizers = {
      google: (data) => ({
        provider: 'google',
        provider_id: data.id,
        email: data.email,
        name: data.name,
        avatar: data.picture,
        verified: data.verified_email
      }),
      kakao: (data) => ({
        provider: 'kakao',
        provider_id: data.id.toString(),
        email: data.kakao_account?.email,
        name: data.properties?.nickname,
        avatar: data.properties?.profile_image,
        verified: data.kakao_account?.is_email_verified
      })
    };

    return normalizers[provider](data);
  }
}

```

### 5.2.3 Rate Limiting

### Token Bucket 알고리즘 구현

```jsx
// rate-limiter.js
class RateLimiter {
  constructor(redis) {
    this.redis = redis;
    this.limits = {
      anonymous: { capacity: 100, refillRate: 100, period: 3600 },
      free: { capacity: 1000, refillRate: 1000, period: 3600 },
      premium: { capacity: 10000, refillRate: 10000, period: 3600 },
      pro: { capacity: 50000, refillRate: 50000, period: 3600 }
    };
  }

  async checkLimit(userId, userTier = 'anonymous') {
    const key = `rate_limit:${userId || 'anonymous'}`;
    const limit = this.limits[userTier];
    const now = Date.now();

    // Lua 스크립트로 원자적 처리
    const luaScript = `
      local key = KEYS[1]
      local capacity = tonumber(ARGV[1])
      local refill_rate = tonumber(ARGV[2])
      local period = tonumber(ARGV[3])
      local now = tonumber(ARGV[4])
      local requested = tonumber(ARGV[5])

      local bucket = redis.call('HMGET', key, 'tokens', 'last_refill')
      local tokens = tonumber(bucket[1]) or capacity
      local last_refill = tonumber(bucket[2]) or now

      -- 토큰 리필 계산
      local elapsed = math.max(0, now - last_refill)
      local refill_amount = math.floor(elapsed / 1000 * refill_rate / period)
      tokens = math.min(capacity, tokens + refill_amount)

      if tokens >= requested then
        tokens = tokens - requested
        redis.call('HMSET', key, 'tokens', tokens, 'last_refill', now)
        redis.call('EXPIRE', key, period)
        return {1, tokens, capacity}
      else
        return {0, tokens, capacity}
      end
    `;

    const result = await this.redis.eval(
      luaScript,
      1,
      key,
      limit.capacity,
      limit.refillRate,
      limit.period,
      now,
      1 // 요청 토큰 수
    );

    return {
      allowed: result[0] === 1,
      remaining: result[1],
      limit: result[2],
      reset: Math.floor(now / 1000) + limit.period
    };
  }

  middleware() {
    return async (req, res, next) => {
      const userId = req.user?.id;
      const userTier = req.user?.tier || 'anonymous';

      const result = await this.checkLimit(userId, userTier);

      // Rate limit 헤더 설정
      res.set({
        'X-RateLimit-Limit': result.limit,
        'X-RateLimit-Remaining': result.remaining,
        'X-RateLimit-Reset': result.reset
      });

      if (!result.allowed) {
        return res.status(429).json({
          success: false,
          error: {
            code: 'RATE_LIMIT_EXCEEDED',
            message: 'Too many requests',
            retry_after: result.reset - Math.floor(Date.now() / 1000)
          }
        });
      }

      next();
    };
  }
}

```

## 5.3 핵심 API 엔드포인트

### 5.3.1 사용자 관리 API

```jsx
// routes/users.js
const express = require('express');
const router = express.Router();
const { body, validationResult } = require('express-validator');

// POST /api/v1/users/register
router.post('/register', [
  body('email').isEmail().normalizeEmail(),
  body('password').isLength({ min: 8 }).matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)/),
  body('username').isLength({ min: 3, max: 20 }).matches(/^[a-zA-Z0-9_]+$/)
], async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({
      success: false,
      error: {
        code: 'VALIDATION_ERROR',
        message: 'Invalid input',
        details: errors.array()
      }
    });
  }

  try {
    const { email, password, username } = req.body;

    // 중복 확인
    const existing = await supabase
      .from('users')
      .select('id')
      .or(`email.eq.${email},username.eq.${username}`)
      .single();

    if (existing) {
      return res.status(409).json({
        success: false,
        error: {
          code: 'USER_EXISTS',
          message: 'Email or username already exists'
        }
      });
    }

    // Supabase Auth 사용자 생성
    const { data: authUser, error: authError } = await supabase.auth.signUp({
      email,
      password,
      options: {
        data: { username }
      }
    });

    if (authError) throw authError;

    // 사용자 프로필 생성
    const { data: user, error: dbError } = await supabase
      .from('users')
      .insert({
        auth_id: authUser.user.id,
        email,
        username,
        user_tier: 'free'
      })
      .select()
      .single();

    if (dbError) throw dbError;

    // 기본 프로필 생성
    await supabase
      .from('user_profiles')
      .insert({
        user_id: user.id,
        preferred_categories: ['general'],
        preferred_keywords: []
      });

    res.status(201).json({
      success: true,
      data: {
        user: {
          id: user.id,
          email: user.email,
          username: user.username,
          user_tier: user.user_tier
        },
        message: 'Registration successful. Please check your email for verification.'
      }
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({
      success: false,
      error: {
        code: 'INTERNAL_ERROR',
        message: 'Registration failed'
      }
    });
  }
});

// GET /api/v1/users/profile
router.get('/profile', authenticate, async (req, res) => {
  try {
    const { data: user, error } = await supabase
      .from('users')
      .select(`
        *,
        user_profiles (
          preferred_categories,
          preferred_keywords,
          time_preferences,
          profile_confidence
        )
      `)
      .eq('id', req.user.id)
      .single();

    if (error) throw error;

    res.json({
      success: true,
      data: {
        user: {
          id: user.id,
          email: user.email,
          username: user.username,
          user_tier: user.user_tier,
          created_at: user.created_at,
          preferences: user.user_profiles[0] || {}
        }
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: {
        code: 'INTERNAL_ERROR',
        message: 'Failed to fetch profile'
      }
    });
  }
});

// PATCH /api/v1/users/profile
router.patch('/profile', authenticate, [
  body('username').optional().isLength({ min: 3, max: 20 }),
  body('preferences.categories').optional().isArray(),
  body('preferences.keywords').optional().isArray()
], async (req, res) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({
      success: false,
      error: {
        code: 'VALIDATION_ERROR',
        message: 'Invalid input',
        details: errors.array()
      }
    });
  }

  try {
    const updates = {};

    // 사용자 정보 업데이트
    if (req.body.username) {
      updates.username = req.body.username;
    }

    if (Object.keys(updates).length > 0) {
      await supabase
        .from('users')
        .update(updates)
        .eq('id', req.user.id);
    }

    // 선호도 업데이트
    if (req.body.preferences) {
      const profileUpdates = {};

      if (req.body.preferences.categories) {
        profileUpdates.preferred_categories = req.body.preferences.categories;
      }

      if (req.body.preferences.keywords) {
        profileUpdates.preferred_keywords = req.body.preferences.keywords;
      }

      await supabase
        .from('user_profiles')
        .update(profileUpdates)
        .eq('user_id', req.user.id);
    }

    res.json({
      success: true,
      message: 'Profile updated successfully'
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: {
        code: 'INTERNAL_ERROR',
        message: 'Failed to update profile'
      }
    });
  }
});

```

### 5.3.2 검색 및 추천 API

```jsx
// routes/search.js
const express = require('express');
const router = express.Router();

// POST /api/v1/search/keywords
router.post('/keywords', authenticate, rateLimiter, async (req, res) => {
  try {
    const { keywords, filters = {} } = req.body;

    // 입력 검증
    if (!keywords || !Array.isArray(keywords) || keywords.length === 0) {
      return res.status(400).json({
        success: false,
        error: {
          code: 'INVALID_REQUEST',
          message: 'Keywords array is required'
        }
      });
    }

    // 캐시 확인
    const cacheKey = `search:${keywords.sort().join(',')}:${JSON.stringify(filters)}`;
    const cached = await cache.get(cacheKey);

    if (cached) {
      return res.json({
        success: true,
        data: {
          videos: cached,
          source: 'cache'
        }
      });
    }

    // 키워드별 검색 및 통합
    const allVideos = [];

    for (const keyword of keywords) {
      // 키워드-영상 매핑에서 검색
      const { data: mappings, error } = await supabase
        .from('keyword_video_mappings')
        .select(`
          *,
          cached_videos (
            id,
            video_id,
            title,
            thumbnail_url,
            channel_title,
            view_count,
            duration,
            ai_analysis
          )
        `)
        .eq('keyword', keyword)
        .order('relevance_score', { ascending: false })
        .limit(20);

      if (error) throw error;

      // 필터 적용
      const filtered = mappings
        .filter(m => m.cached_videos)
        .map(m => ({
          ...m.cached_videos,
          relevance_score: m.relevance_score,
          keyword: keyword
        }))
        .filter(video => {
          if (filters.minViews && video.view_count < filters.minViews) return false;
          if (filters.maxDuration && video.duration > filters.maxDuration) return false;
          if (filters.category && !video.ai_analysis.categories.includes(filters.category)) return false;
          return true;
        });

      allVideos.push(...filtered);
    }

    // 중복 제거 및 정렬
    const uniqueVideos = Array.from(
      new Map(allVideos.map(v => [v.video_id, v])).values()
    ).sort((a, b) => b.relevance_score - a.relevance_score);

    // 개인화 적용
    const personalized = await personalizeResults(uniqueVideos, req.user.id);

    // 캐시 저장
    await cache.set(cacheKey, personalized, 1800); // 30분

    // 검색 로그
    await supabase
      .from('search_sessions')
      .insert({
        user_id: req.user.id,
        search_type: 'keyword',
        search_query: keywords.join(', '),
        results_count: personalized.length,
        results_shown: personalized.slice(0, 20).map(v => v.id)
      });

    res.json({
      success: true,
      data: {
        videos: personalized.slice(0, 50),
        total: personalized.length,
        keywords: keywords
      }
    });
  } catch (error) {
    console.error('Search error:', error);
    res.status(500).json({
      success: false,
      error: {
        code: 'SEARCH_ERROR',
        message: 'Search failed'
      }
    });
  }
});

// POST /api/v1/search/chat (프리미엄 전용)
router.post('/chat', authenticate, requirePremium, async (req, res) => {
  try {
    const { message, conversationId } = req.body;

    if (!message || typeof message !== 'string') {
      return res.status(400).json({
        success: false,
        error: {
          code: 'INVALID_REQUEST',
          message: 'Message is required'
        }
      });
    }

    // MCP를 통한 자연어 처리
    const result = await mcp.processMessage(req.user.id, message, conversationId);

    // 세션 저장
    await supabase
      .from('search_sessions')
      .insert({
        user_id: req.user.id,
        session_id: result.sessionId,
        search_type: 'ai_chat',
        search_query: message,
        conversation_context: result.context,
        results_count: result.videos.length,
        response_time_ms: result.processingTime
      });

    res.json({
      success: true,
      data: {
        message: result.message,
        videos: result.videos,
        suggestions: result.suggestions,
        session_id: result.sessionId,
        keywords: result.extractedKeywords
      }
    });
  } catch (error) {
    console.error('Chat search error:', error);
    res.status(500).json({
      success: false,
      error: {
        code: 'CHAT_ERROR',
        message: 'Chat search failed'
      }
    });
  }
});

// POST /api/v1/search/intelligent-query
router.post('/intelligent-query', authenticate, requirePremium, async (req, res) => {
  try {
    const { query, options = {} } = req.body;

    if (!query || typeof query !== 'string') {
      return res.status(400).json({
        success: false,
        error: {
          code: 'INVALID_QUERY',
          message: 'Query string is required'
        }
      });
    }

    // MCP를 통한 지능형 쿼리 빌드
    const result = await mcp.buildIntelligentQuery(query, options);

    // 확장된 쿼리로 YouTube 검색
    const videos = await Promise.all(
      result.queries.map(async (expandedQuery) => {
        if (expandedQuery.type === 'channel_search') {
          // 채널 영상 API 사용 (3 units)
          return await youtube.getChannelVideos(expandedQuery.channelId);
        } else {
          // 일반 검색 API 사용 (100 units)
          return await youtube.searchShorts(expandedQuery.query, expandedQuery.filters);
        }
      })
    );

    // 결과 병합 및 중복 제거
    const mergedVideos = [...new Map(
      videos.flat().map(v => [v.video_id, v])
    ).values()];

    res.json({
      success: true,
      data: {
        original_query: query,
        expanded_queries: result.queries,
        web_context: result.webContext,
        videos: mergedVideos.slice(0, 50),
        api_units_saved: result.apiUnitsSaved
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: {
        code: 'INTELLIGENT_QUERY_ERROR',
        message: 'Failed to process intelligent query'
      }
    });
  }
});

// GET /api/v1/search/trending
router.get('/trending', optionalAuth, async (req, res) => {
  try {
    const { category, limit = 20 } = req.query;

    // 현재 유효한 트렌드 조회
    let query = supabase
      .from('trending_keywords')
      .select('*')
      .gte('valid_until', new Date().toISOString())
      .order('trend_score', { ascending: false })
      .limit(limit);

    if (category) {
      query = query.eq('category', category);
    }

    const { data: trends, error } = await query;

    if (error) throw error;

    // 트렌드별 영상 조회
    const trendingVideos = [];

    for (const trend of trends) {
      const { data: mappings } = await supabase
        .from('keyword_video_mappings')
        .select(`
          cached_videos (
            id,
            video_id,
            title,
            thumbnail_url,
            channel_title,
            view_count
          )
        `)
        .eq('keyword', trend.keyword)
        .order('relevance_score', { ascending: false })
        .limit(5);

      trendingVideos.push({
        keyword: trend.keyword,
        trend_score: trend.trend_score,
        category: trend.category,
        videos: mappings?.map(m => m.cached_videos).filter(Boolean) || []
      });
    }

    res.json({
      success: true,
      data: {
        trends: trendingVideos,
        updated_at: new Date().toISOString()
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: {
        code: 'TRENDING_ERROR',
        message: 'Failed to fetch trending content'
      }
    });
  }
});

```

### 5.3.3 영상 관련 API

```jsx
// routes/videos.js
const express = require('express');
const router = express.Router();

// GET /api/v1/videos/:videoId
router.get('/:videoId', optionalAuth, async (req, res) => {
  try {
    const { videoId } = req.params;

    const { data: video, error } = await supabase
      .from('cached_videos')
      .select(`
        *,
        video_quality_scores (
          engagement_rate,
          content_quality,
          overall_score
        )
      `)
      .eq('video_id', videoId)
      .single();

    if (error || !video) {
      return res.status(404).json({
        success: false,
        error: {
          code: 'VIDEO_NOT_FOUND',
          message: 'Video not found'
        }
      });
    }

    res.json({
      success: true,
      data: {
        video: {
          id: video.id,
          video_id: video.video_id,
          title: video.title,
          description: video.description,
          thumbnail_url: video.thumbnail_url,
          channel: {
            id: video.channel_id,
            title: video.channel_title
          },
          statistics: {
            view_count: video.view_count,
            like_count: video.like_count,
            comment_count: video.comment_count
          },
          duration: video.duration,
          published_at: video.published_at,
          quality_score: video.video_quality_scores?.[0]?.overall_score,
          ai_analysis: video.ai_analysis,
          url: `https://youtube.com/shorts/${video.video_id}`
        }
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: {
        code: 'INTERNAL_ERROR',
        message: 'Failed to fetch video'
      }
    });
  }
});

// POST /api/v1/videos/:videoId/interactions
router.post('/:videoId/interactions', authenticate, async (req, res) => {
  try {
    const { videoId } = req.params;
    const { type, data = {} } = req.body;

    // 상호작용 타입 검증
    const validTypes = ['view', 'like', 'dislike', 'share', 'save', 'skip'];
    if (!validTypes.includes(type)) {
      return res.status(400).json({
        success: false,
        error: {
          code: 'INVALID_INTERACTION_TYPE',
          message: `Type must be one of: ${validTypes.join(', ')}`
        }
      });
    }

    // 영상 ID 확인
    const { data: video } = await supabase
      .from('cached_videos')
      .select('id')
      .eq('video_id', videoId)
      .single();

    if (!video) {
      return res.status(404).json({
        success: false,
        error: {
          code: 'VIDEO_NOT_FOUND',
          message: 'Video not found'
        }
      });
    }

    // 상호작용 기록
    const interaction = {
      user_id: req.user.id,
      video_id: video.id,
      interaction_type: type,
      session_id: req.headers['x-session-id']
    };

    // 타입별 추가 데이터
    if (type === 'view') {
      interaction.watch_duration = data.watch_duration || 0;
      interaction.total_duration = data.total_duration || 60;
    }

    if (data.source_keyword) {
      interaction.source_keyword = data.source_keyword;
    }

    const { error } = await supabase
      .from('video_interactions')
      .insert(interaction);

    if (error) throw error;

    // 키워드 효과성 업데이트
    if (data.source_keyword) {
      await updateKeywordEffectiveness(data.source_keyword, type);
    }

    res.json({
      success: true,
      message: 'Interaction recorded'
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: {
        code: 'INTERACTION_ERROR',
        message: 'Failed to record interaction'
      }
    });
  }
});

// GET /api/v1/videos/:videoId/related
router.get('/:videoId/related', optionalAuth, async (req, res) => {
  try {
    const { videoId } = req.params;
    const { limit = 20 } = req.query;

    // 원본 영상 정보 조회
    const { data: video } = await supabase
      .from('cached_videos')
      .select('ai_analysis, channel_id')
      .eq('video_id', videoId)
      .single();

    if (!video) {
      return res.status(404).json({
        success: false,
        error: {
          code: 'VIDEO_NOT_FOUND',
          message: 'Video not found'
        }
      });
    }

    // AI 분석 기반 관련 영상 찾기
    const categories = video.ai_analysis.categories || [];
    const keywords = video.ai_analysis.keywords || [];

    // 관련 영상 쿼리
    const { data: relatedVideos } = await supabase
      .from('cached_videos')
      .select('*')
      .neq('video_id', videoId)
      .or(`ai_analysis->'categories' @> '[${categories.map(c => `"${c}"`).join(',')}]', ai_analysis->'keywords' @> '[${keywords.map(k => `"${k}"`).join(',')}]'`)
      .order('view_count', { ascending: false })
      .limit(limit);

    res.json({
      success: true,
      data: {
        videos: relatedVideos || [],
        based_on: {
          categories,
          keywords
        }
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: {
        code: 'RELATED_ERROR',
        message: 'Failed to fetch related videos'
      }
    });
  }
});

```

### 5.3.4 트렌드 API

```jsx
// routes/trends.js
const express = require('express');
const router = express.Router();

// GET /api/v1/trends/realtime
router.get('/realtime', optionalAuth, async (req, res) => {
  try {
    const { limit = 10 } = req.query;

            // Bright Data MCP 최신 데이터
    const realtimeTrends = await trendsService.getRealTimeTrends();

    res.json({
      success: true,
      data: {
        trends: realtimeTrends.slice(0, limit),
                  source: 'bright_data_mcp',
        updated_at: new Date().toISOString()
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: {
        code: 'TRENDS_ERROR',
        message: 'Failed to fetch realtime trends'
      }
    });
  }
});

// GET /api/v1/trends/hourly
router.get('/hourly', authenticate, async (req, res) => {
  try {
    const currentHour = new Date().getHours();
    const dayOfWeek = new Date().getDay();

    // 시간대별 트렌드
    const { data: hourlyTrends } = await supabase
      .from('trending_keywords')
      .select('*')
      .eq('time_slot', getTimeSlot(currentHour))
      .eq('day_of_week', dayOfWeek)
      .gte('valid_until', new Date().toISOString())
      .order('trend_score', { ascending: false })
      .limit(20);

    res.json({
      success: true,
      data: {
        trends: hourlyTrends || [],
        time_context: {
          hour: currentHour,
          time_slot: getTimeSlot(currentHour),
          day_of_week: dayOfWeek
        }
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: {
        code: 'HOURLY_TRENDS_ERROR',
        message: 'Failed to fetch hourly trends'
      }
    });
  }
});

// GET /api/v1/trends/categories
router.get('/categories', authenticate, async (req, res) => {
  try {
    const { data: categoryTrends } = await supabase
      .from('category_trend_summary')
      .select('*')
      .gte('trend_date', new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString())
      .order('trend_date', { ascending: false })
      .order('avg_trend_score', { ascending: false });

    // 카테고리별 그룹화
    const grouped = {};
    categoryTrends?.forEach(trend => {
      if (!grouped[trend.category]) {
        grouped[trend.category] = [];
      }
      grouped[trend.category].push(trend);
    });

    res.json({
      success: true,
      data: {
        categories: grouped,
        period: 'last_7_days'
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: {
        code: 'CATEGORY_TRENDS_ERROR',
        message: 'Failed to fetch category trends'
      }
    });
  }
});

// POST /api/v1/trends/predict (프로 플랜 전용)
router.post('/predict', authenticate, requirePro, async (req, res) => {
  try {
    const { keywords, timeframe = 'week' } = req.body;

    if (!keywords || !Array.isArray(keywords)) {
      return res.status(400).json({
        success: false,
        error: {
          code: 'INVALID_REQUEST',
          message: 'Keywords array is required'
        }
      });
    }

    // MCP를 통한 트렌드 예측
    const predictions = await mcp.predictTrends(keywords, timeframe);

    // 예측 결과 저장
    for (const prediction of predictions) {
      await supabase
        .from('trend_predictions')
        .insert({
          keyword: prediction.keyword,
          prediction_date: new Date(),
          predicted_for_date: prediction.targetDate,
          predicted_score: prediction.score,
          confidence_interval: `[${prediction.lowerBound},${prediction.upperBound}]`,
          confidence_level: prediction.confidence,
          model_version: 'v1.0',
          features_used: prediction.features
        });
    }

    res.json({
      success: true,
      data: {
        predictions,
        timeframe,
        model_version: 'v1.0'
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: {
        code: 'PREDICTION_ERROR',
        message: 'Failed to generate predictions'
      }
    });
  }
});

```

## 5.4 API 문서화

### 5.4.1 OpenAPI 3.0 스펙

```yaml
openapi: 3.0.3
info:
  title: YouTube Shorts Curator API
  description: AI-powered YouTube Shorts curation service API
  version: 1.0.0
  contact:
    email: api@shortscurator.com
  license:
    name: Proprietary
servers:
  - url: https://api.shortscurator.com/v1
    description: Production server
  - url: https://staging-api.shortscurator.com/v1
    description: Staging server
  - url: http://localhost:3000/v1
    description: Development server

security:
  - bearerAuth: []

tags:
  - name: Auth
    description: Authentication endpoints
  - name: Users
    description: User management
  - name: Search
    description: Video search and discovery
  - name: Videos
    description: Video operations
  - name: Trends
    description: Trending content

paths:
  /auth/login:
    post:
      tags:
        - Auth
      summary: User login
      operationId: login
      security: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - email
                - password
              properties:
                email:
                  type: string
                  format: email
                  example: user@example.com
                password:
                  type: string
                  format: password
                  minLength: 8
      responses:
        '200':
          description: Login successful
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/AuthResponse'
        '401':
          $ref: '#/components/responses/Unauthorized'
        '429':
          $ref: '#/components/responses/TooManyRequests'

  /search/chat:
    post:
      tags:
        - Search
      summary: AI-powered chat search (Premium)
      operationId: chatSearch
      security:
        - bearerAuth: []
      x-required-tier: premium
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              required:
                - message
              properties:
                message:
                  type: string
                  example: "퇴근 후 힐링할 수 있는 영상 추천해줘"
                conversationId:
                  type: string
                  format: uuid
      responses:
        '200':
          description: Search results with AI response
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ChatSearchResponse'
        '403':
          $ref: '#/components/responses/Forbidden'

components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT

  schemas:
    Error:
      type: object
      required:
        - code
        - message
      properties:
        code:
          type: string
          example: INTERNAL_ERROR
        message:
          type: string
          example: An unexpected error occurred
        details:
          type: object

    AuthResponse:
      type: object
      properties:
        success:
          type: boolean
        data:
          type: object
          properties:
            access_token:
              type: string
            refresh_token:
              type: string
            token_type:
              type: string
              default: Bearer
            expires_in:
              type: integer
              example: 3600

    Video:
      type: object
      properties:
        id:
          type: string
          format: uuid
        video_id:
          type: string
        title:
          type: string
        thumbnail_url:
          type: string
          format: uri
        channel:
          type: object
          properties:
            id:
              type: string
            title:
              type: string
        statistics:
          type: object
          properties:
            view_count:
              type: integer
            like_count:
              type: integer
        duration:
          type: integer
        quality_score:
          type: number
          format: float
          minimum: 0
          maximum: 1

    ChatSearchResponse:
      type: object
      properties:
        success:
          type: boolean
        data:
          type: object
          properties:
            message:
              type: string
            videos:
              type: array
              items:
                $ref: '#/components/schemas/Video'
            suggestions:
              type: array
              items:
                type: string
            keywords:
              type: array
              items:
                type: string

  responses:
    Unauthorized:
      description: Authentication required
      content:
        application/json:
          schema:
            type: object
            properties:
              success:
                type: boolean
                default: false
              error:
                $ref: '#/components/schemas/Error'

    Forbidden:
      description: Insufficient permissions
      content:
        application/json:
          schema:
            type: object
            properties:
              success:
                type: boolean
                default: false
              error:
                type: object
                properties:
                  code:
                    type: string
                    example: INSUFFICIENT_TIER
                  message:
                    type: string
                    example: This feature requires premium subscription

    TooManyRequests:
      description: Rate limit exceeded
      headers:
        X-RateLimit-Limit:
          schema:
            type: integer
        X-RateLimit-Remaining:
          schema:
            type: integer
        X-RateLimit-Reset:
          schema:
            type: integer
      content:
        application/json:
          schema:
            type: object
            properties:
              success:
                type: boolean
                default: false
              error:
                type: object
                properties:
                  code:
                    type: string
                    example: RATE_LIMIT_EXCEEDED
                  retry_after:
                    type: integer

```

### 5.4.2 Postman 컬렉션

```json
{
  "info": {
    "name": "YouTube Shorts Curator API",
    "schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
  },
  "auth": {
    "type": "bearer",
    "bearer": [
      {
        "key": "token",
        "value": "{{access_token}}",
        "type": "string"
      }
    ]
  },
  "event": [
    {
      "listen": "prerequest",
      "script": {
        "exec": [
          "// 자동 토큰 갱신",
          "const tokenExpiry = pm.environment.get('token_expiry');",
          "const now = new Date().getTime();",
          "",
          "if (!tokenExpiry || now > parseInt(tokenExpiry)) {",
          "    pm.sendRequest({",
          "        url: pm.environment.get('base_url') + '/auth/refresh',",
          "        method: 'POST',",
          "        header: {",
          "            'Content-Type': 'application/json'",
          "        },",
          "        body: {",
          "            mode: 'raw',",
          "            raw: JSON.stringify({",
          "                refresh_token: pm.environment.get('refresh_token')",
          "            })",
          "        }",
          "    }, (err, res) => {",
          "        if (!err && res.code === 200) {",
          "            const response = res.json();",
          "            pm.environment.set('access_token', response.data.access_token);",
          "            pm.environment.set('token_expiry', now + response.data.expires_in * 1000);",
          "        }",
          "    });",
          "}"
        ],
        "type": "text/javascript"
      }
    }
  ],
  "variable": [
    {
      "key": "base_url",
      "value": "https://api.shortscurator.com/v1"
    }
  ],
  "item": [
    {
      "name": "Auth",
      "item": [
        {
          "name": "Login",
          "request": {
            "method": "POST",
            "header": [],
            "body": {
              "mode": "raw",
              "raw": "{\n    \"email\": \"{{email}}\",\n    \"password\": \"{{password}}\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{base_url}}/auth/login",
              "host": ["{{base_url}}"],
              "path": ["auth", "login"]
            }
          },
          "event": [
            {
              "listen": "test",
              "script": {
                "exec": [
                  "if (pm.response.code === 200) {",
                  "    const response = pm.response.json();",
                  "    pm.environment.set('access_token', response.data.access_token);",
                  "    pm.environment.set('refresh_token', response.data.refresh_token);",
                  "    pm.environment.set('token_expiry', ",
                  "        new Date().getTime() + response.data.expires_in * 1000",
                  "    );",
                  "}"
                ],
                "type": "text/javascript"
              }
            }
          ]
        }
      ]
    },
    {
      "name": "Search",
      "item": [
        {
          "name": "Chat Search",
          "request": {
            "method": "POST",
            "header": [],
            "body": {
              "mode": "raw",
              "raw": "{\n    \"message\": \"오늘 날씨 좋은데 기분 좋아지는 영상 추천해줘\"\n}",
              "options": {
                "raw": {
                  "language": "json"
                }
              }
            },
            "url": {
              "raw": "{{base_url}}/search/chat",
              "host": ["{{base_url}}"],
              "path": ["search", "chat"]
            }
          }
        }
      ]
    }
  ]
}

```

### 5.4.3 사용 예제

### cURL 예제

```bash
# 로그인
curl -X POST https://api.shortscurator.com/v1/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"user@example.com","password":"password123"}'

# 키워드 검색
curl -X POST https://api.shortscurator.com/v1/search/keywords \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"keywords":["힐링","ASMR"],"filters":{"minViews":100000}}'

# AI 채팅 검색 (프리미엄)
curl -X POST https://api.shortscurator.com/v1/search/chat \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"message":"퇴근 후 스트레스 해소할 수 있는 재미있는 영상"}'

# 영상 상호작용 기록
curl -X POST https://api.shortscurator.com/v1/videos/VIDEO_ID/interactions \
  -H "Authorization: Bearer YOUR_ACCESS_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"type":"view","data":{"watch_duration":45,"total_duration":60}}'

```

### JavaScript SDK 예제

```jsx
// sdk.js
class ShortsCuratorSDK {
  constructor(config = {}) {
    this.baseURL = config.baseURL || 'https://api.shortscurator.com/v1';
    this.accessToken = config.accessToken;
    this.refreshToken = config.refreshToken;
    this.onTokenRefresh = config.onTokenRefresh;
  }

  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    const headers = {
      'Content-Type': 'application/json',
      ...options.headers
    };

    if (this.accessToken) {
      headers['Authorization'] = `Bearer ${this.accessToken}`;
    }

    try {
      const response = await fetch(url, {
        ...options,
        headers
      });

      if (response.status === 401 && this.refreshToken) {
        await this.refreshAccessToken();
        headers['Authorization'] = `Bearer ${this.accessToken}`;
        return fetch(url, { ...options, headers });
      }

      const data = await response.json();

      if (!response.ok) {
        throw new APIError(data.error?.message || 'API Error', data.error);
      }

      return data;
    } catch (error) {
      throw error;
    }
  }

  // Auth methods
  async login(email, password) {
    const response = await this.request('/auth/login', {
      method: 'POST',
      body: JSON.stringify({ email, password })
    });

    this.accessToken = response.data.access_token;
    this.refreshToken = response.data.refresh_token;

    return response;
  }

  // Search methods
  async searchKeywords(keywords, filters = {}) {
    return this.request('/search/keywords', {
      method: 'POST',
      body: JSON.stringify({ keywords, filters })
    });
  }

  async chatSearch(message, conversationId) {
    return this.request('/search/chat', {
      method: 'POST',
      body: JSON.stringify({ message, conversationId })
    });
  }

  // Video methods
  async getVideo(videoId) {
    return this.request(`/videos/${videoId}`);
  }

  async recordInteraction(videoId, type, data = {}) {
    return this.request(`/videos/${videoId}/interactions`, {
      method: 'POST',
      body: JSON.stringify({ type, data })
    });
  }
}

// 사용 예제
const sdk = new ShortsCuratorSDK({
  accessToken: 'YOUR_ACCESS_TOKEN'
});

// 키워드 검색
const results = await sdk.searchKeywords(['게임', '공략']);

// AI 채팅 검색
const chatResults = await sdk.chatSearch('오늘 점심 뭐 먹을까 고민돼');

// 영상 시청 기록
await sdk.recordInteraction('VIDEO_ID', 'view', {
  watch_duration: 30,
  total_duration: 60
});

```