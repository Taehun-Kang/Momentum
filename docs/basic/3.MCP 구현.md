# MCP (Model Context Protocol) 구현

## 3.1 MCP 개요 및 중요성

### 3.1.1 MCP가 필요한 이유

### 기존 방식의 한계

```yaml
키워드 기반 검색:
  문제점:
    - "피곤해" → 정확한 키워드 매칭 불가
    - 맥락 이해 부족
    - 사용자 의도 파악 실패
  예시:
    - "오늘 기분이 꿀꿀해" → 검색 결과 없음
    - "뭔가 새로운 거" → 너무 추상적

단순 AI 통합:
  문제점:
    - API 호출마다 컨텍스트 손실
    - 도구 사용 불가
    - 실시간 데이터 접근 제한
    - 개인화 어려움

```

### MCP 도입 효과

```yaml
맥락 기반 이해:
  - 자연어 → 구조화된 의도 변환
  - 대화 히스토리 유지
  - 상황별 최적 응답

도구 통합:
  - YouTube API 직접 호출
  - 트렌드 데이터 실시간 접근
  - 사용자 프로필 조회/업데이트
  - 캐시 시스템 활용

지속적 학습:
  - 사용자 피드백 즉시 반영
  - 패턴 인식 및 개선
  - 개인화 정확도 향상

```

### 3.1.2 우리 서비스에서의 역할

```jsx
// MCP 활용 플로우
const MCPFlow = {
  // 1. 사용자 입력 분석
  "퇴근하고 너무 지쳐": {
    extracted: {
      context: "퇴근 후",
      emotion: "피로",
      need: "휴식/힐링"
    }
  },

  // 2. 도구 선택 및 실행
  tools_used: [
    "get_user_preferences",      // 사용자 선호도 조회
    "get_trending_keywords",     // 현재 트렌드 확인
    "search_youtube_shorts",     // 영상 검색
    "filter_by_context"         // 맥락 필터링
  ],

  // 3. 개인화된 결과
  result: {
    keywords: ["퇴근후힐링", "ASMR", "귀여운동물", "짧은명상"],
    videos: ["맞춤형 큐레이션 리스트"],
    next_suggestions: ["더 활기찬 걸로", "오늘은 웃긴 영상"]
  }
};

```

### 3.1.3 기대 효과

```yaml
정량적 효과:
  검색 정확도: 65% → 90%
  사용자 만족도: 3.5 → 4.5/5.0
  평균 세션 시간: 10분 → 20분
  프리미엄 전환율: 5% → 15%

정성적 효과:
  - "진짜 내 마음을 읽는 것 같아요"
  - "다른 앱과는 차원이 달라요"
  - "매번 딱 맞는 영상을 찾아줘요"

```

## 3.2 MCP 서버 구현

### 3.2.1 서버 아키텍처

```jsx
// mcp-server.js
import { Server } from '@modelcontextprotocol/sdk/server/index.js';
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';
import { YouTubeService } from './services/youtube-service.js';
import { TrendsService } from './services/trends-service.js';
import { UserService } from './services/user-service.js';
import { CacheService } from './services/cache-service.js';

class YouTubeCuratorMCP {
  constructor() {
    this.server = new Server(
      {
        name: 'youtube-curator-mcp',
        version: '1.0.0',
        capabilities: {
          tools: {},
          resources: {},
          prompts: {}
        }
      },
      {
        logger: console
      }
    );

    // 서비스 초기화
    this.youtube = new YouTubeService();
    this.trends = new TrendsService();
    this.users = new UserService();
    this.cache = new CacheService();

    this.setupTools();
    this.setupResources();
    this.setupPrompts();
  }

  async start() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    console.log('MCP Server started successfully');
  }
}

```

### 3.2.2 도구(Tools) 정의

```jsx
setupTools() {
  // 1. 키워드 추출 도구
  this.server.setRequestHandler('tools/list', async () => ({
    tools: [
      {
        name: 'extract_keywords',
        description: '사용자 입력에서 YouTube 검색용 키워드를 추출합니다',
        inputSchema: {
          type: 'object',
          properties: {
            message: {
              type: 'string',
              description: '사용자의 자연어 입력'
            },
            context: {
              type: 'object',
              properties: {
                time: { type: 'string' },
                previousKeywords: { type: 'array', items: { type: 'string' } },
                userMood: { type: 'string' }
              }
            }
          },
          required: ['message']
        }
      },

      // 2. YouTube 검색 도구
      {
        name: 'search_youtube_shorts',
        description: 'YouTube Shorts를 검색하고 필터링합니다',
        inputSchema: {
          type: 'object',
          properties: {
            keywords: {
              type: 'array',
              items: { type: 'string' },
              description: '검색할 키워드 목록'
            },
            filters: {
              type: 'object',
              properties: {
                minViews: { type: 'number', default: 100000 },
                maxDuration: { type: 'number', default: 60 },
                language: { type: 'string', default: 'ko' }
              }
            }
          },
          required: ['keywords']
        }
      },

      // 3. 트렌드 분석 도구
      {
        name: 'analyze_trends',
        description: '현재 트렌드를 분석하고 관련 키워드를 제공합니다',
        inputSchema: {
          type: 'object',
          properties: {
            category: {
              type: 'string',
              enum: ['general', 'music', 'gaming', 'food', 'lifestyle']
            },
            timeRange: {
              type: 'string',
              enum: ['realtime', 'today', 'week'],
              default: 'realtime'
            }
          }
        }
      },

      // 4. 사용자 프로필 도구
      {
        name: 'get_user_profile',
        description: '사용자의 선호도와 시청 패턴을 조회합니다',
        inputSchema: {
          type: 'object',
          properties: {
            userId: { type: 'string' },
            includeHistory: { type: 'boolean', default: false }
          },
          required: ['userId']
        }
      },

      // 5. 개인화 추천 도구
      {
        name: 'personalize_results',
        description: '검색 결과를 사용자 맞춤형으로 재정렬합니다',
        inputSchema: {
          type: 'object',
          properties: {
            videos: { type: 'array' },
            userProfile: { type: 'object' },
            context: { type: 'object' }
          },
          required: ['videos', 'userProfile']
        }
      },

      // 6. 대화 응답 생성 도구
      {
        name: 'generate_response',
        description: '자연스러운 대화형 응답을 생성합니다',
        inputSchema: {
          type: 'object',
          properties: {
            keywords: { type: 'array', items: { type: 'string' } },
            videoCount: { type: 'number' },
            context: { type: 'object' }
          },
          required: ['keywords']
        }
      },

      // 7. Bright Data 웹 검색 도구
      {
        name: 'search_web_trends',
        description: 'Bright Data MCP를 통해 실시간 웹 트렌드를 검색합니다',
        inputSchema: {
          type: 'object',
          properties: {
            query: { type: 'string', description: '검색 쿼리' },
            country: { type: 'string', default: 'KR' },
            language: { type: 'string', default: 'ko' },
            sources: { 
              type: 'array', 
              items: { type: 'string' },
              default: ['google_trends', 'youtube_trending', 'social_media']
            }
          },
          required: ['query']
        }
      },

      // 8. 트렌드 분석 도구 (Bright Data)
      {
        name: 'analyze_trend_details',
        description: 'Bright Data MCP를 통해 특정 키워드의 상세 트렌드를 분석합니다',
        inputSchema: {
          type: 'object',
          properties: {
            keyword: { type: 'string' },
            metrics: { 
              type: 'array',
              items: { type: 'string' },
              default: ['search_volume', 'growth_rate', 'demographics']
            },
            timeframe: { type: 'string', default: '7d' }
          },
          required: ['keyword']
        }
      },

      // 9. Supabase 쿼리 실행 도구
      {
        name: 'execute_database_query',
        description: 'Supabase MCP를 통해 데이터베이스 쿼리를 실행합니다',
        inputSchema: {
          type: 'object',
          properties: {
            query: { type: 'string', description: 'SQL 쿼리' },
            params: { type: 'array', items: { type: 'any' }, default: [] }
          },
          required: ['query']
        }
      },

      // 10. 사용자 분석 인사이트 도구
      {
        name: 'generate_user_insights',
        description: 'Supabase MCP를 통해 사용자 행동 분석 인사이트를 생성합니다',
        inputSchema: {
          type: 'object',
          properties: {
            userId: { type: 'string' },
            analysisType: { 
              type: 'string',
              enum: ['viewing_patterns', 'preferences', 'engagement'],
              default: 'viewing_patterns'
            },
            timeRange: { type: 'string', default: '7d' }
          },
          required: ['userId']
        }
      },

      // 11. 지능형 쿼리 빌더 도구
      {
        name: 'build_intelligent_query',
        description: 'Bright Data MCP를 활용하여 사용자 쿼리를 지능적으로 확장하고 최적화합니다',
        inputSchema: {
          type: 'object',
          properties: {
            userQuery: { type: 'string', description: '사용자의 원본 검색어' },
            options: {
              type: 'object',
              properties: {
                includeChannels: { type: 'boolean', default: true },
                includeTimeFilters: { type: 'boolean', default: true },
                includeTrends: { type: 'boolean', default: true },
                filters: {
                  type: 'object',
                  properties: {
                    minViews: { type: 'number' },
                    hdOnly: { type: 'boolean' },
                    withCaptions: { type: 'boolean' },
                    categoryId: { type: 'string' }
                  }
                }
              }
            }
          },
          required: ['userQuery']
        }
      },

      // 12. 채널 영상 프리페치 도구
      {
        name: 'prefetch_channel_videos',
        description: '인기 채널의 최신 영상을 미리 캐싱하여 API 사용량을 절감합니다',
        inputSchema: {
          type: 'object',
          properties: {
            channelIds: { 
              type: 'array', 
              items: { type: 'string' },
              description: '프리페치할 채널 ID 목록'
            },
            category: {
              type: 'string',
              enum: ['gaming', 'news', 'music', 'entertainment', 'food'],
              description: '카테고리별 인기 채널 자동 선택'
            }
          }
        }
      }
    ]
  }));

  // 도구 실행 핸들러
  this.server.setRequestHandler('tools/call', async (request) => {
    const { name, arguments: args } = request.params;

    switch (name) {
      case 'extract_keywords':
        return await this.extractKeywords(args);

      case 'search_youtube_shorts':
        return await this.searchYouTubeShorts(args);

      case 'analyze_trends':
        return await this.analyzeTrends(args);

      case 'get_user_profile':
        return await this.getUserProfile(args);

      case 'personalize_results':
        return await this.personalizeResults(args);

      case 'generate_response':
        return await this.generateResponse(args);

      // Bright Data MCP 도구들
      case 'search_web_trends':
        return await this.searchWebTrends(args);

      case 'analyze_trend_details':
        return await this.analyzeTrendDetails(args);

      // Supabase MCP 도구들
      case 'execute_database_query':
        return await this.executeDatabaseQuery(args);

      case 'generate_user_insights':
        return await this.generateUserInsights(args);

      // 지능형 쿼리 빌더
      case 'build_intelligent_query':
        return await this.buildIntelligentQuery(args);

      // 채널 프리페치
      case 'prefetch_channel_videos':
        return await this.prefetchChannelVideos(args);

      default:
        throw new Error(`Unknown tool: ${name}`);
    }
  });
}

```

### 3.2.3 프로토콜 구현

```jsx
// 도구 구현 예시
async extractKeywords({ message, context = {} }) {
  try {
    // 1. 패턴 매칭으로 빠른 추출 시도
    const quickKeywords = this.quickExtraction(message);
    if (quickKeywords.length > 0) {
      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            keywords: quickKeywords,
            confidence: 0.8,
            method: 'pattern_matching'
          })
        }]
      };
    }

    // 2. 맥락 분석
    const contextAnalysis = {
      timeOfDay: this.getTimeContext(),
      dayOfWeek: new Date().getDay(),
      userHistory: context.previousKeywords || [],
      currentTrends: await this.trends.getCurrentTrends()
    };

    // 3. 의도 분석
    const intent = this.analyzeIntent(message);

    // 4. 키워드 생성
    const keywords = this.generateKeywords(intent, contextAnalysis);

    return {
      content: [{
        type: 'text',
        text: JSON.stringify({
          keywords,
          confidence: 0.95,
          method: 'contextual_analysis',
          intent,
          context: contextAnalysis
        })
      }]
    };
  } catch (error) {
    return {
      content: [{
        type: 'text',
        text: JSON.stringify({
          error: error.message,
          fallback: ['인기영상', '추천영상']
        })
      }]
    };
  }
}

async searchYouTubeShorts({ keywords, filters = {} }) {
  try {
    // 1. 캐시 확인
    const cacheKey = `search:${keywords.join(',')}:${JSON.stringify(filters)}`;
    const cached = await this.cache.get(cacheKey);
    if (cached) {
      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            videos: cached,
            source: 'cache'
          })
        }]
      };
    }

    // 2. API 할당량 확인
    const quotaAvailable = await this.checkQuota('search_youtube_shorts');
    if (!quotaAvailable) {
      // 폴백: 유사 캐시 검색
      const similar = await this.findSimilarCache(keywords);
      return {
        content: [{
          type: 'text',
          text: JSON.stringify({
            videos: similar,
            source: 'similar_cache',
            message: 'API 할당량 제한으로 유사한 결과를 제공합니다'
          })
        }]
      };
    }

    // 3. YouTube 검색 실행
    const searchResults = [];
    for (const keyword of keywords) {
      const results = await this.youtube.searchShorts(keyword, {
        maxResults: 20,
        ...filters
      });
      searchResults.push(...results);
    }

    // 4. 중복 제거 및 정렬
    const uniqueVideos = this.deduplicateVideos(searchResults);
    const sortedVideos = this.sortByRelevance(uniqueVideos, keywords);

    // 5. 캐시 저장
    await this.cache.set(cacheKey, sortedVideos, 3600); // 1시간

    return {
      content: [{
        type: 'text',
        text: JSON.stringify({
          videos: sortedVideos.slice(0, 50),
          source: 'youtube_api',
          keywords_used: keywords
        })
      }]
    };
  } catch (error) {
    return {
      content: [{
        type: 'text',
        text: JSON.stringify({
          error: error.message,
          videos: []
        })
      }]
    };
  }
}

// Bright Data MCP 도구 구현
async searchWebTrends({ query, country = 'KR', language = 'ko', sources = [] }) {
  try {
    // Bright Data MCP 클라이언트 사용
    const brightDataResult = await this.brightData.callTool('web_search', {
      query,
      country,
      language,
      filter: {
        time_range: 'past_day',
        source_type: sources.length > 0 ? sources : ['google_trends', 'youtube_trending', 'social_media']
      }
    });

    // 결과 처리 및 구조화
    const trends = await this.processBrightDataResults(brightDataResult);

    return {
      content: [{
        type: 'text',
        text: JSON.stringify({
          trends,
          source: 'bright_data_mcp',
          timestamp: new Date()
        })
      }]
    };
  } catch (error) {
    console.error('Bright Data MCP error:', error);
    return {
      content: [{
        type: 'text',
        text: JSON.stringify({
          error: error.message,
          fallback: await this.getFallbackTrends()
        })
      }]
    };
  }
}

async analyzeTrendDetails({ keyword, metrics = [], timeframe = '7d' }) {
  try {
    const analysis = await this.brightData.callTool('analyze_trend', {
      keyword,
      metrics: metrics.length > 0 ? metrics : ['search_volume', 'growth_rate', 'demographics'],
      timeframe,
      region: 'KR'
    });

    // Supabase에 분석 결과 저장
    await this.saveTrendAnalysis(keyword, analysis);

    return {
      content: [{
        type: 'text',
        text: JSON.stringify({
          keyword,
          analysis,
          saved: true,
          timestamp: new Date()
        })
      }]
    };
  } catch (error) {
    return {
      content: [{
        type: 'text',
        text: JSON.stringify({
          error: error.message,
          keyword
        })
      }]
    };
  }
}

// Supabase MCP 도구 구현
async executeDatabaseQuery({ query, params = [] }) {
  try {
    // 보안 검증
    if (!this.validateQuery(query)) {
      throw new Error('Unsafe query detected');
    }

    const result = await this.supabase.callTool('execute_sql', {
      query,
      params
    });

    return {
      content: [{
        type: 'text',
        text: JSON.stringify({
          result: JSON.parse(result.content[0].text),
          rowCount: result.rowCount,
          success: true
        })
      }]
    };
  } catch (error) {
    return {
      content: [{
        type: 'text',
        text: JSON.stringify({
          error: error.message,
          query
        })
      }]
    };
  }
}

async generateUserInsights({ userId, analysisType = 'viewing_patterns', timeRange = '7d' }) {
  try {
    let query;
    const params = [userId];

    switch (analysisType) {
      case 'viewing_patterns':
        query = `
          WITH user_stats AS (
            SELECT 
              DATE(vi.created_at) as view_date,
              EXTRACT(HOUR FROM vi.created_at) as view_hour,
              cv.ai_analysis->>'categories' as category,
              COUNT(*) as view_count,
              AVG(vi.watch_duration) as avg_watch_time,
              AVG(vi.completion_rate) as avg_completion
            FROM video_interactions vi
            JOIN cached_videos cv ON vi.video_id = cv.id
            WHERE vi.user_id = $1
              AND vi.created_at > NOW() - INTERVAL '${timeRange}'
            GROUP BY view_date, view_hour, category
          )
          SELECT 
            view_date,
            view_hour,
            category,
            view_count,
            avg_watch_time,
            avg_completion,
            RANK() OVER (PARTITION BY view_date ORDER BY view_count DESC) as daily_rank
          FROM user_stats
          ORDER BY view_date DESC, view_count DESC;
        `;
        break;

      case 'preferences':
        query = `
          SELECT 
            up.preferred_categories,
            up.preferred_keywords,
            up.time_preferences,
            up.profile_confidence,
            COUNT(DISTINCT vi.video_id) as total_videos_watched,
            AVG(vi.completion_rate) as avg_completion_rate
          FROM user_profiles up
          LEFT JOIN video_interactions vi ON up.user_id = vi.user_id
          WHERE up.user_id = $1
          GROUP BY up.id;
        `;
        break;

      case 'engagement':
        query = `
          WITH engagement_metrics AS (
            SELECT 
              vi.interaction_type,
              COUNT(*) as count,
              AVG(vi.watch_duration) as avg_duration
            FROM video_interactions vi
            WHERE vi.user_id = $1
              AND vi.created_at > NOW() - INTERVAL '${timeRange}'
            GROUP BY vi.interaction_type
          )
          SELECT * FROM engagement_metrics
          ORDER BY count DESC;
        `;
        break;
    }

    const result = await this.supabase.callTool('execute_sql', { query, params });
    const data = JSON.parse(result.content[0].text);

    // AI를 통한 인사이트 생성
    const insights = await this.generateAIInsights(data, analysisType);

    return {
      content: [{
        type: 'text',
        text: JSON.stringify({
          userId,
          analysisType,
          data,
          insights,
          timestamp: new Date()
        })
      }]
    };
  } catch (error) {
    return {
      content: [{
        type: 'text',
        text: JSON.stringify({
          error: error.message,
          userId,
          analysisType
        })
      }]
    };
  }
}

// 지능형 쿼리 빌더 도구 구현
async buildIntelligentQuery({ userQuery, options = {} }) {
  try {
    const queryBuilder = new IntelligentQueryBuilder();
    
    // Bright Data MCP를 통한 컨텍스트 수집
    const context = await this.gatherQueryContext(userQuery);
    
    // 다양한 쿼리 전략 생성
    const queryStrategies = [];
    
    // 1. 엔티티 기반 쿼리 (예: LCK → 팀명, 선수명)
    if (context.entities.length > 0) {
      queryStrategies.push({
        type: 'entity_based',
        query: `${userQuery} ${context.entities.join(' ')}`,
        priority: 'high',
        reason: '관련 인물/조직명 포함'
      });
    }
    
    // 2. 시간 기반 쿼리
    if (context.timeContext) {
      const timeQuery = this.buildTimeFilteredQuery(userQuery, context.timeContext);
      queryStrategies.push({
        type: 'time_filtered',
        query: timeQuery.query,
        filters: timeQuery.filters,
        priority: 'medium',
        reason: timeQuery.reason
      });
    }
    
    // 3. 채널 타겟팅 쿼리
    if (context.suggestedChannels.length > 0) {
      for (const channel of context.suggestedChannels) {
        queryStrategies.push({
          type: 'channel_specific',
          channelId: channel.id,
          channelName: channel.name,
          method: 'videos.list', // API 비용 절감
          priority: 'high',
          reason: `${channel.name} 채널의 최신 영상`,
          cost: 5 // videos.list (1) + parts (2*2)
        });
      }
    }
    
    // 4. 트렌드 기반 쿼리
    if (context.trendingTopics.length > 0) {
      queryStrategies.push({
        type: 'trend_based',
        query: `${userQuery} ${context.trendingTopics.join(' ')}`,
        priority: 'medium',
        reason: '현재 트렌드 반영'
      });
    }
    
    // 5. 필터 조합 쿼리
    const filters = this.buildSmartFilters(userQuery, context);
    if (Object.keys(filters).length > 0) {
      queryStrategies.push({
        type: 'filtered_search',
        query: userQuery,
        filters: filters,
        priority: 'medium',
        reason: '스마트 필터 적용'
      });
    }
    
    return {
      content: [{
        type: 'text',
        text: JSON.stringify({
          originalQuery: userQuery,
          strategies: queryStrategies,
          context: context,
          estimatedApiCost: this.calculateApiCost(queryStrategies),
          recommendations: this.generateQueryRecommendations(context)
        })
      }]
    };
  } catch (error) {
    return {
      content: [{
        type: 'text',
        text: JSON.stringify({
          error: error.message,
          fallbackQuery: userQuery
        })
      }]
    };
  }
}

async gatherQueryContext(userQuery) {
  // Bright Data MCP로 실시간 컨텍스트 수집
  const webSearch = await this.brightData.callTool('search_web_trends', {
    query: userQuery,
    country: 'KR',
    language: 'ko',
    sources: ['google_trends', 'youtube', 'news', 'social_media']
  });
  
  const searchData = JSON.parse(webSearch.content[0].text);
  
  const context = {
    entities: [],
    timeContext: null,
    suggestedChannels: [],
    trendingTopics: [],
    relatedQueries: []
  };
  
  // 카테고리별 채널 매핑
  const channelMap = {
    'lck': ['UCCwbMDOOgC4Y8If0sYlLQAg', 'UC0b8Zw2a7c8uF2eVYjXiNcQ'],
    '뉴스': ['UChlgI3UHCOnwUGzWzbJ3H5w', 'UCF4Wxdo3inmxP-Y59wXDsFw'],
    '음악': ['UC3IZKseVpdzPSBaWxBxundA', 'UCEf_Bc-KVd7onSeifS3py9g']
  };
  
  // 쿼리 분석 및 채널 매칭
  for (const [keyword, channelIds] of Object.entries(channelMap)) {
    if (userQuery.toLowerCase().includes(keyword)) {
      const channels = await this.getChannelInfo(channelIds);
      context.suggestedChannels.push(...channels);
    }
  }
  
  // 엔티티 추출 (NER)
  context.entities = this.extractEntities(searchData);
  
  // 시간 컨텍스트 분석
  context.timeContext = this.analyzeTimeContext(userQuery);
  
  // 트렌딩 토픽 수집
  context.trendingTopics = searchData.trending_keywords || [];
  
  return context;
}

buildTimeFilteredQuery(baseQuery, timeContext) {
  const now = new Date();
  let filters = {};
  let reason = '';
  
  switch (timeContext.type) {
    case 'today':
      filters.publishedAfter = new Date(now.setHours(0, 0, 0, 0)).toISOString();
      reason = '오늘 업로드된 영상';
      break;
    case 'this_week':
      filters.publishedAfter = new Date(now - 7 * 24 * 60 * 60 * 1000).toISOString();
      reason = '이번 주 인기 영상';
      break;
    case 'recent':
      filters.publishedAfter = new Date(now - 24 * 60 * 60 * 1000).toISOString();
      filters.order = 'date';
      reason = '24시간 내 최신 영상';
      break;
  }
  
  return {
    query: baseQuery,
    filters,
    reason
  };
}

buildSmartFilters(query, context) {
  const filters = {};
  
  // 조회수 필터 (인기도 기반)
  if (query.includes('인기') || query.includes('화제')) {
    filters.order = 'viewCount';
    filters.publishedAfter = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString();
  }
  
  // HD 화질 필터
  if (query.includes('고화질') || query.includes('HD')) {
    filters.videoDefinition = 'high';
  }
  
  // 자막 필터
  if (query.includes('자막') || query.includes('한글')) {
    filters.videoCaption = 'closedCaption';
  }
  
  // Shorts 필터
  filters.videoDuration = 'short';
  
  // 언어 필터
  filters.relevanceLanguage = 'ko';
  
  return filters;
}

// 채널 영상 프리페치 도구
async prefetchChannelVideos({ channelIds = [], category = null }) {
  try {
    const prefetchResults = [];
    
    // 카테고리별 인기 채널
    const popularChannels = {
      gaming: ['UCCwbMDOOgC4Y8If0sYlLQAg', 'UC0b8Zw2a7c8uF2eVYjXiNcQ'],
      news: ['UChlgI3UHCOnwUGzWzbJ3H5w', 'UCF4Wxdo3inmxP-Y59wXDsFw'],
      music: ['UC3IZKseVpdzPSBaWxBxundA', 'UCEf_Bc-KVd7onSeifS3py9g'],
      entertainment: ['UCiEEF51uRAeZeCo8CJFhGWw', 'UCfD2RhqXt7w6eLCH6G1BDeQ']
    };
    
    // 채널 ID 결정
    let targetChannels = channelIds;
    if (category && popularChannels[category]) {
      targetChannels = [...targetChannels, ...popularChannels[category]];
    }
    
    // 중복 제거
    targetChannels = [...new Set(targetChannels)];
    
    // 배치 처리 (API 제한 고려)
    for (let i = 0; i < targetChannels.length; i += 5) {
      const batch = targetChannels.slice(i, i + 5);
      
      const batchResults = await Promise.all(
        batch.map(async (channelId) => {
          try {
            // 캐시 확인
            const cacheKey = `channel:${channelId}:latest`;
            const cached = await this.checkCache(cacheKey);
            
            if (cached) {
              return {
                channelId,
                source: 'cache',
                videos: cached.videos,
                cached: true
              };
            }
            
            // YouTube videos.list API 호출 (저렴한 비용)
            const videos = await this.youtube.videos.list({
              part: 'snippet,contentDetails,statistics',
              channelId: channelId,
              maxResults: 20,
              order: 'date',
              type: 'video',
              videoDuration: 'short'
            });
            
            // 캐시 저장
            await this.saveToCache(cacheKey, {
              videos: videos.data.items,
              channelId,
              timestamp: new Date()
            }, 14400); // 4시간 캐시
            
            return {
              channelId,
              source: 'api',
              videos: videos.data.items,
              cached: false
            };
            
          } catch (error) {
            return {
              channelId,
              error: error.message,
              cached: false
            };
          }
        })
      );
      
      prefetchResults.push(...batchResults);
      
      // API rate limiting 대응
      if (i + 5 < targetChannels.length) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }
    
    return {
      content: [{
        type: 'text',
        text: JSON.stringify({
          totalChannels: targetChannels.length,
          successful: prefetchResults.filter(r => !r.error).length,
          cached: prefetchResults.filter(r => r.cached).length,
          results: prefetchResults,
          timestamp: new Date()
        })
      }]
    };
  } catch (error) {
    return {
      content: [{
        type: 'text',
        text: JSON.stringify({
          error: error.message,
          channelIds
        })
      }]
    };
  }
}

```

## 3.3 MCP 활용 영역

### 3.3.1 자연어 대화 처리

```jsx
class ConversationHandler {
  constructor(mcpClient) {
    this.mcp = mcpClient;
    this.sessions = new Map();
  }

  async processMessage(userId, message) {
    // 세션 관리
    let session = this.sessions.get(userId);
    if (!session) {
      session = {
        id: generateId(),
        userId,
        messages: [],
        context: {},
        startedAt: Date.now()
      };
      this.sessions.set(userId, session);
    }

    // 메시지 추가
    session.messages.push({
      role: 'user',
      content: message,
      timestamp: Date.now()
    });

    // MCP 도구 체인 실행
    const toolChain = [
      // 1. 키워드 추출
      {
        tool: 'extract_keywords',
        args: {
          message,
          context: {
            previousKeywords: session.context.recentKeywords || [],
            userMood: session.context.mood
          }
        }
      }
    ];

    const keywordResult = await this.mcp.callTool(toolChain[0].tool, toolChain[0].args);
    const { keywords, intent } = JSON.parse(keywordResult.content[0].text);

    // 2. 사용자 프로필 조회
    toolChain.push({
      tool: 'get_user_profile',
      args: { userId, includeHistory: true }
    });

    const profileResult = await this.mcp.callTool('get_user_profile', { userId });
    const userProfile = JSON.parse(profileResult.content[0].text);

    // 3. 트렌드 분석 (필요시)
    if (intent.needsTrends) {
      toolChain.push({
        tool: 'analyze_trends',
        args: {
          category: intent.category || 'general',
          timeRange: 'realtime'
        }
      });
    }

    // 4. YouTube 검색
    toolChain.push({
      tool: 'search_youtube_shorts',
      args: {
        keywords,
        filters: {
          minViews: userProfile.preferences.minViews || 100000
        }
      }
    });

    const searchResult = await this.mcp.callTool('search_youtube_shorts', { keywords });
    const { videos } = JSON.parse(searchResult.content[0].text);

    // 5. 개인화
    toolChain.push({
      tool: 'personalize_results',
      args: {
        videos,
        userProfile,
        context: session.context
      }
    });

    const personalizedResult = await this.mcp.callTool('personalize_results', {
      videos,
      userProfile,
      context: session.context
    });
    const personalizedVideos = JSON.parse(personalizedResult.content[0].text);

    // 6. 응답 생성
    toolChain.push({
      tool: 'generate_response',
      args: {
        keywords,
        videoCount: personalizedVideos.length,
        context: { intent, mood: session.context.mood }
      }
    });

    const responseResult = await this.mcp.callTool('generate_response', {
      keywords,
      videoCount: personalizedVideos.length
    });
    const response = JSON.parse(responseResult.content[0].text);

    // 세션 업데이트
    session.messages.push({
      role: 'assistant',
      content: response.message,
      timestamp: Date.now()
    });

    session.context = {
      ...session.context,
      recentKeywords: keywords,
      lastIntent: intent,
      toolChain
    };

    return {
      message: response.message,
      videos: personalizedVideos,
      suggestions: response.suggestions,
      sessionId: session.id
    };
  }
}

```

### 3.3.2 키워드 추출 및 분석

```jsx
class KeywordAnalyzer {
  constructor() {
    this.patterns = this.loadPatterns();
    this.synonyms = this.loadSynonyms();
  }

  analyzeIntent(message) {
    const intent = {
      primary: null,
      secondary: [],
      mood: null,
      timeContext: null,
      needsTrends: false,
      category: null
    };

    // 감정 분석
    const moodPatterns = {
      tired: /피곤|지쳐|힘들|졸려|피로/,
      happy: /기분.*좋|신나|행복|즐거/,
      sad: /우울|슬프|힘들어|눈물/,
      bored: /심심|지루|할.*없/,
      excited: /설레|기대|떨려|신나/
    };

    for (const [mood, pattern] of Object.entries(moodPatterns)) {
      if (pattern.test(message)) {
        intent.mood = mood;
        break;
      }
    }

    // 시간 맥락
    const timePatterns = {
      morning: /아침|출근|모닝|기상/,
      lunch: /점심|런치|낮/,
      evening: /저녁|퇴근|밤/,
      night: /새벽|자기.*전|수면/
    };

    for (const [time, pattern] of Object.entries(timePatterns)) {
      if (pattern.test(message)) {
        intent.timeContext = time;
        break;
      }
    }

    // 카테고리 추출
    const categoryPatterns = {
      music: /음악|노래|댄스|춤|케이팝|kpop/i,
      food: /먹|요리|음식|레시피|맛집/,
      gaming: /게임|플레이|공략/,
      comedy: /웃|재미|개그|코미디/,
      lifestyle: /브이로그|일상|루틴/,
      asmr: /asmr|소리|수면|힐링/i
    };

    for (const [category, pattern] of Object.entries(categoryPatterns)) {
      if (pattern.test(message)) {
        intent.category = category;
        break;
      }
    }

    // 트렌드 필요 여부
    if (/최신|요즘|트렌드|인기|핫한/.test(message)) {
      intent.needsTrends = true;
    }

    return intent;
  }

  generateKeywords(intent, context) {
    const keywords = new Set();

    // 1. 무드 기반 키워드
    const moodKeywords = {
      tired: ['힐링', 'ASMR', '휴식', '수면', '명상'],
      happy: ['신나는', '댄스', '파티', '축하'],
      sad: ['위로', '감동', '따뜻한', '음악'],
      bored: ['재미있는', '웃긴', '신기한', '놀라운'],
      excited: ['도전', '스릴', '신나는', '에너지']
    };

    if (intent.mood && moodKeywords[intent.mood]) {
      moodKeywords[intent.mood].forEach(k => keywords.add(k));
    }

    // 2. 시간대별 키워드
    const timeKeywords = {
      morning: ['모닝루틴', '출근길', '아침운동', '커피'],
      lunch: ['점심메뉴', '맛집', '간단요리'],
      evening: ['퇴근후', '저녁루틴', '휴식'],
      night: ['수면음악', 'ASMR', '꿀잠', '백색소음']
    };

    if (intent.timeContext && timeKeywords[intent.timeContext]) {
      timeKeywords[intent.timeContext].forEach(k => keywords.add(k));
    }

    // 3. 카테고리 키워드
    if (intent.category) {
      const categoryBase = {
        music: ['뮤직', '음악', '플레이리스트'],
        food: ['먹방', '요리', '레시피'],
        gaming: ['게임', '플레이', '공략'],
        comedy: ['웃긴영상', '코미디', '개그'],
        lifestyle: ['브이로그', '일상', '루틴'],
        asmr: ['ASMR', '백색소음', '수면유도']
      };

      if (categoryBase[intent.category]) {
        categoryBase[intent.category].forEach(k => keywords.add(k));
      }
    }

    // 4. 현재 트렌드 반영
    if (intent.needsTrends && context.currentTrends) {
      context.currentTrends.slice(0, 3).forEach(trend => {
        keywords.add(trend.keyword);
      });
    }

    // 5. 사용자 히스토리 반영
    if (context.userHistory && context.userHistory.length > 0) {
      // 최근 성공적인 키워드 재사용
      const successfulKeywords = context.userHistory
        .filter(h => h.satisfaction > 0.7)
        .map(h => h.keyword);

      successfulKeywords.slice(0, 2).forEach(k => keywords.add(k));
    }

    return Array.from(keywords).slice(0, 5);
  }
}

```

### 3.3.3 개인화 추천 시스템

```jsx
class PersonalizationEngine {
  constructor(mcpClient) {
    this.mcp = mcpClient;
  }

  async personalizeResults(videos, userProfile, context) {
    // 1. 점수 계산
    const scoredVideos = videos.map(video => {
      let score = 0;

      // 카테고리 매칭 (30%)
      if (userProfile.preferredCategories.includes(video.category)) {
        score += 0.3;
      }

      // 키워드 매칭 (25%)
      const keywordMatch = this.calculateKeywordMatch(
        video.keywords,
        userProfile.preferredKeywords
      );
      score += keywordMatch * 0.25;

      // 시청 시간대 매칭 (15%)
      const timeMatch = this.calculateTimeMatch(
        video,
        userProfile.timePreferences,
        context.currentHour
      );
      score += timeMatch * 0.15;

      // 인기도 (15%)
      const popularity = Math.min(video.viewCount / 1000000, 1);
      score += popularity * 0.15;

      // 신선도 (10%)
      const freshness = this.calculateFreshness(video.publishedAt);
      score += freshness * 0.1;

      // 다양성 보너스 (5%)
      const diversity = this.calculateDiversity(video, context.recentVideos);
      score += diversity * 0.05;

      return { ...video, personalizationScore: score };
    });

    // 2. 정렬 및 다양성 확보
    const sorted = scoredVideos.sort((a, b) =>
      b.personalizationScore - a.personalizationScore
    );

    // 3. 다양성을 위한 재배치
    const diversified = this.ensureDiversity(sorted);

    return diversified;
  }

  calculateKeywordMatch(videoKeywords, userKeywords) {
    const intersection = videoKeywords.filter(k =>
      userKeywords.includes(k)
    ).length;

    return intersection / Math.max(videoKeywords.length, 1);
  }

  calculateTimeMatch(video, timePreferences, currentHour) {
    const timeSlot = this.getTimeSlot(currentHour);
    const slotPreferences = timePreferences[timeSlot] || [];

    return slotPreferences.some(pref =>
      video.keywords.includes(pref)
    ) ? 1 : 0;
  }

  calculateFreshness(publishedAt) {
    const daysOld = (Date.now() - new Date(publishedAt)) / (1000 * 60 * 60 * 24);

    if (daysOld < 1) return 1;
    if (daysOld < 7) return 0.8;
    if (daysOld < 30) return 0.5;
    return 0.2;
  }

  ensureDiversity(videos) {
    const result = [];
    const usedCategories = new Set();
    const usedChannels = new Set();

    // 첫 10개는 점수 순
    result.push(...videos.slice(0, 10));

    // 나머지는 다양성 고려
    for (const video of videos.slice(10)) {
      // 같은 카테고리가 3개 이상이면 스킵
      const categoryCount = result.filter(v =>
        v.category === video.category
      ).length;
      if (categoryCount >= 3) continue;

      // 같은 채널이 2개 이상이면 스킵
      const channelCount = result.filter(v =>
        v.channelId === video.channelId
      ).length;
      if (channelCount >= 2) continue;

      result.push(video);

      if (result.length >= 50) break;
    }

    return result;
  }
}

```

### 3.3.4 트렌드 분석 및 예측

```jsx
class TrendAnalyzer {
  constructor() {
    this.brightData = new BrightDataMCPClient();
    this.supabase = new SupabaseMCPClient();
    this.serpApi = new SerpApiClient();
  }

  async analyzeTrends(category, timeRange) {
    // 1. 다중 소스 데이터 수집 (Bright Data MCP 우선)
    const sources = await Promise.all([
      this.getBrightDataTrends(category, timeRange),
      this.getSerpApiTrends(category, timeRange),
      this.getInternalTrends(category, timeRange)
    ]);

    // 2. 데이터 통합 및 가중치 적용
    const integratedTrends = this.integrateTrendData(sources);

    // 3. Supabase MCP를 통한 트렌드 저장 및 분석
    await this.saveTrendsToSupabase(integratedTrends);

    // 4. 트렌드 예측
    const predictions = await this.predictTrends(integratedTrends);

    // 5. 카테고리별 분류
    const categorized = this.categorizeTrends(integratedTrends);

    return {
      current: integratedTrends.slice(0, 20),
      predicted: predictions,
      byCategory: categorized,
      metadata: {
        lastUpdated: new Date(),
        sources: ['bright_data_mcp', 'serpapi', 'internal'],
        accuracy: await this.calculateAccuracy()
      }
    };
  }

  async getBrightDataTrends(category, timeRange) {
    try {
      // Bright Data MCP를 통한 실시간 트렌드 수집
      const result = await this.brightData.callTool('search_web_trends', {
        query: `youtube shorts trends ${category} korea`,
        country: 'KR',
        language: 'ko',
        sources: ['google_trends', 'youtube_trending', 'naver_trends']
      });

      const trends = JSON.parse(result.content[0].text).trends;

      // 각 트렌드에 대한 상세 분석
      const detailedTrends = await Promise.all(
        trends.slice(0, 10).map(async (trend) => {
          const analysis = await this.brightData.callTool('analyze_trend_details', {
            keyword: trend.keyword,
            metrics: ['search_volume', 'growth_rate', 'demographics', 'related_topics'],
            timeframe: timeRange
          });

          return {
            ...trend,
            ...JSON.parse(analysis.content[0].text).analysis
          };
        })
      );

      return {
        source: 'bright_data',
        weight: 0.5, // 가장 높은 가중치
        trends: detailedTrends
      };
    } catch (error) {
      console.error('Bright Data trends failed:', error);
      return { source: 'bright_data', weight: 0, trends: [] };
    }
  }

  async getSerpApiTrends(category, timeRange) {
    try {
      // SerpAPI를 통한 보조 트렌드 수집
      const googleTrends = await this.serpApi.getGoogleTrends();
      const youtubeTrends = await this.serpApi.getYouTubeTrending();

      return {
        source: 'serpapi',
        weight: 0.3,
        trends: [...googleTrends, ...youtubeTrends]
      };
    } catch (error) {
      console.error('SerpAPI trends failed:', error);
      return { source: 'serpapi', weight: 0, trends: [] };
    }
  }

  async saveTrendsToSupabase(trends) {
    // Supabase MCP를 통한 트렌드 데이터 저장
    const query = `
      INSERT INTO trend_analysis_batch (
        batch_id,
        trends,
        analyzed_at,
        source_weights
      ) VALUES ($1, $2, $3, $4)
      ON CONFLICT (batch_id) DO UPDATE
      SET trends = EXCLUDED.trends,
          updated_at = NOW();
    `;

    const batchId = `batch_${Date.now()}`;
    const params = [
      batchId,
      JSON.stringify(trends),
      new Date(),
      JSON.stringify({
        bright_data: 0.5,
        serpapi: 0.3,
        internal: 0.2
      })
    ];

    await this.supabase.callTool('execute_database_query', { query, params });

    // 개별 트렌드 저장
    for (const trend of trends) {
      await this.saveTrendDetails(trend);
    }
  }

  async saveTrendDetails(trend) {
    const query = `
      INSERT INTO trend_keywords (
        keyword,
        trend_score,
        search_volume,
        growth_rate,
        category,
        demographics,
        source,
        valid_until
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
      ON CONFLICT (keyword, DATE(created_at))
      DO UPDATE SET
        trend_score = EXCLUDED.trend_score,
        search_volume = EXCLUDED.search_volume,
        growth_rate = EXCLUDED.growth_rate,
        updated_at = NOW();
    `;

    const params = [
      trend.keyword,
      trend.trend_score || 0,
      trend.search_volume || 0,
      trend.growth_rate || 0,
      trend.category,
      JSON.stringify(trend.demographics || {}),
      trend.source,
      new Date(Date.now() + 4 * 60 * 60 * 1000) // 4시간 후
    ];

    await this.supabase.callTool('execute_database_query', { query, params });
  }

  async predictTrends(currentTrends) {
    // Supabase MCP를 통한 과거 데이터 조회
    const historicalQuery = `
      SELECT 
        keyword,
        DATE(analyzed_at) as date,
        AVG(trend_score) as avg_score,
        AVG(growth_rate) as avg_growth
      FROM trend_keywords
      WHERE analyzed_at >= NOW() - INTERVAL '30 days'
      GROUP BY keyword, date
      ORDER BY keyword, date;
    `;

    const historicalData = await this.supabase.callTool('execute_database_query', {
      query: historicalQuery
    });

    // AI를 통한 트렌드 예측
    const predictions = await this.generatePredictions(
      currentTrends,
      JSON.parse(historicalData.content[0].text).result
    );

    return predictions;
  }

  integrateTrendData(sources) {
    const integratedMap = new Map();

    // 소스별 가중치 적용 및 통합
    for (const source of sources) {
      for (const trend of source.trends) {
        const key = trend.keyword.toLowerCase();
        
        if (integratedMap.has(key)) {
          const existing = integratedMap.get(key);
          existing.score += trend.trend_score * source.weight;
          existing.sources.push(source.source);
        } else {
          integratedMap.set(key, {
            keyword: trend.keyword,
            score: trend.trend_score * source.weight,
            sources: [source.source],
            ...trend
          });
        }
      }
    }

    // 정렬 및 정규화
    return Array.from(integratedMap.values())
      .sort((a, b) => b.score - a.score)
      .map((trend, index) => ({
        ...trend,
        rank: index + 1,
        normalized_score: trend.score / (sources.reduce((sum, s) => sum + s.weight, 0))
      }));
  }
}

```

## 3.4 Claude API 통합

### 3.4.1 API 연동 방법

```jsx
// claude-integration.js
class ClaudeIntegration {
  constructor(mcpServer) {
    this.mcp = mcpServer;
    this.claude = new Anthropic({
      apiKey: process.env.CLAUDE_API_KEY
    });

    this.systemPrompt = this.buildSystemPrompt();
  }

  buildSystemPrompt() {
    return `You are an AI assistant integrated with a YouTube Shorts curation MCP server.

Your role:
1. Understand user's context and emotions from their natural language input
2. Use MCP tools to find the perfect YouTube Shorts
3. Provide personalized recommendations with empathy
4. Learn from user feedback to improve future recommendations

Available MCP tools:
- extract_keywords: Extract search keywords from user input
- search_youtube_shorts: Search YouTube Shorts with filters
- analyze_trends: Get current trending topics
- get_user_profile: Retrieve user preferences
- personalize_results: Personalize video recommendations
- generate_response: Create natural conversation responses

Context information:
- Current time: {current_time}
- User location: Korea
- Language: Korean (respond in Korean)
- Service: YouTube Shorts 큐레이션

Always:
- Be conversational and friendly
- Understand the emotional context
- Use appropriate MCP tools
- Provide 5-10 video recommendations
- Suggest follow-up questions`;
  }

  async processWithClaude(userMessage, userId) {
    try {
      // MCP 도구 정의를 Claude에 전달
      const tools = await this.mcp.getAvailableTools();

      const response = await this.claude.messages.create({
        model: 'claude-3-opus-20240229',
        max_tokens: 1000,
        temperature: 0.7,
        system: this.systemPrompt.replace('{current_time}', new Date().toLocaleString('ko-KR')),
        messages: [
          {
            role: 'user',
            content: userMessage
          }
        ],
        tools: tools.map(tool => ({
          name: tool.name,
          description: tool.description,
          input_schema: tool.inputSchema
        }))
      });

      // Claude의 도구 호출 처리
      if (response.stop_reason === 'tool_use') {
        const toolUses = response.content.filter(c => c.type === 'tool_use');
        const results = [];

        for (const toolUse of toolUses) {
          const result = await this.mcp.callTool(
            toolUse.name,
            toolUse.input
          );
          results.push(result);
        }

        // 도구 결과를 포함하여 다시 Claude에 전달
        const followUp = await this.claude.messages.create({
          model: 'claude-3-opus-20240229',
          max_tokens: 500,
          messages: [
            {
              role: 'user',
              content: userMessage
            },
            {
              role: 'assistant',
              content: response.content
            },
            {
              role: 'user',
              content: `Tool results: ${JSON.stringify(results)}`
            }
          ]
        });

        return followUp.content[0].text;
      }

      return response.content[0].text;
    } catch (error) {
      console.error('Claude API error:', error);
      throw error;
    }
  }
}

```

### 3.4.2 프롬프트 엔지니어링

```jsx
class PromptOptimizer {
  constructor() {
    this.templates = this.loadTemplates();
    this.examples = this.loadExamples();
  }

  buildContextualPrompt(userMessage, context) {
    const template = this.selectTemplate(context);

    return `
${template.system}

User Context:
- Time: ${context.currentTime}
- Previous searches: ${context.recentSearches.join(', ')}
- Mood indicators: ${this.extractMoodIndicators(userMessage)}
- Preferred categories: ${context.userPreferences.categories.join(', ')}

Examples of good responses:
${this.examples.slice(0, 3).map(ex =>
  `User: ${ex.input}\nAssistant: ${ex.output}`
).join('\n\n')}

Current user message: "${userMessage}"

Instructions:
1. First, understand the user's emotional state and needs
2. Extract 3-5 specific keywords that match their current situation
3. Consider time of day and user history
4. Provide a warm, empathetic response
5. Always end with 2-3 follow-up suggestions`;
  }

  optimizeForToken(prompt) {
    // 토큰 수 최적화
    const essentials = {
      role: this.extractEssentialRole(prompt),
      context: this.compressContext(prompt),
      examples: this.selectBestExamples(prompt, 2),
      instructions: this.prioritizeInstructions(prompt)
    };

    return this.reconstructPrompt(essentials);
  }
}

```

### 3.4.3 비용 최적화 전략

```jsx
class CostOptimizer {
  constructor() {
    this.dailyBudget = 50; // $50
    this.modelCosts = {
      'claude-3-opus-20240229': { input: 15, output: 75 },      // per 1M tokens
      'claude-3-sonnet-20240229': { input: 3, output: 15 },
      'claude-3-haiku-20240307': { input: 0.25, output: 1.25 }
    };

    this.usage = {
      daily: 0,
      requests: []
    };
  }

  async selectOptimalModel(request) {
    const complexity = this.assessComplexity(request);
    const budgetRemaining = this.dailyBudget - this.usage.daily;

    // 복잡도와 예산에 따른 모델 선택
    if (complexity.score < 0.3 && budgetRemaining > 30) {
      return 'claude-3-haiku-20240307';
    } else if (complexity.score < 0.7 && budgetRemaining > 10) {
      return 'claude-3-sonnet-20240229';
    } else if (budgetRemaining > 5) {
      return 'claude-3-opus-20240229';
    } else {
      // 예산 초과 시 로컬 처리
      throw new Error('Daily budget exceeded');
    }
  }

  assessComplexity(request) {
    const factors = {
      messageLength: request.message.length / 1000,          // 0-1
      contextSize: Object.keys(request.context).length / 10, // 0-1
      requiresMultiTurn: request.multiTurn ? 1 : 0,         // 0-1
      needsCreativity: this.assessCreativity(request) ? 1 : 0
    };

    const weights = {
      messageLength: 0.2,
      contextSize: 0.3,
      requiresMultiTurn: 0.3,
      needsCreativity: 0.2
    };

    const score = Object.entries(factors).reduce((sum, [key, value]) =>
      sum + (value * weights[key]), 0
    );

    return { score, factors };
  }

  implementCaching() {
    // 응답 캐싱으로 비용 절감
    const cache = new Map();

    return {
      get: (key) => {
        const cached = cache.get(key);
        if (cached && Date.now() - cached.timestamp < 3600000) {
          return cached.response;
        }
        return null;
      },

      set: (key, response) => {
        cache.set(key, {
          response,
          timestamp: Date.now()
        });

        // 캐시 크기 제한
        if (cache.size > 1000) {
          const oldestKey = Array.from(cache.entries())
            .sort((a, b) => a[1].timestamp - b[1].timestamp)[0][0];
          cache.delete(oldestKey);
        }
      }
    };
  }
}

```

## 3.5 MCP 성능 최적화

### 3.5.1 캐싱 전략

```jsx
class MCPCacheManager {
  constructor() {
    this.caches = {
      keywords: new LRUCache({ max: 1000, ttl: 3600000 }),     // 1시간
      searches: new LRUCache({ max: 500, ttl: 1800000 }),      // 30분
      profiles: new LRUCache({ max: 200, ttl: 7200000 }),      // 2시간
      trends: new LRUCache({ max: 100, ttl: 14400000 })        // 4시간
    };

    this.hitRates = {
      keywords: { hits: 0, misses: 0 },
      searches: { hits: 0, misses: 0 },
      profiles: { hits: 0, misses: 0 },
      trends: { hits: 0, misses: 0 }
    };
  }

  async get(type, key) {
    const cache = this.caches[type];
    const value = cache.get(key);

    if (value) {
      this.hitRates[type].hits++;
      return value;
    }

    this.hitRates[type].misses++;
    return null;
  }

  async set(type, key, value, ttl) {
    const cache = this.caches[type];
    cache.set(key, value, { ttl: ttl || cache.ttl });
  }

  getCacheStats() {
    const stats = {};

    for (const [type, rates] of Object.entries(this.hitRates)) {
      const total = rates.hits + rates.misses;
      stats[type] = {
        hitRate: total > 0 ? (rates.hits / total) : 0,
        size: this.caches[type].size,
        ...rates
      };
    }

    return stats;
  }

  // 예측적 캐싱
  async predictiveCache() {
    // 시간대별 인기 키워드 미리 캐싱
    const hour = new Date().getHours();
    const timeSlot = this.getTimeSlot(hour);

    const predictedKeywords = await this.getPredictedKeywords(timeSlot);

    for (const keyword of predictedKeywords) {
      // 미리 검색 수행
      const result = await this.searchWithoutCache(keyword);
      await this.set('searches', keyword, result);
    }
  }
}

```

### 3.5.2 배치 처리

```jsx
class BatchProcessor {
  constructor(mcpServer) {
    this.mcp = mcpServer;
    this.queue = [];
    this.processing = false;
    this.batchSize = 10;
    this.interval = 100; // ms
  }

  async addToQueue(operation) {
    this.queue.push({
      id: generateId(),
      operation,
      timestamp: Date.now(),
      deferred: this.createDeferred()
    });

    if (!this.processing) {
      this.startProcessing();
    }

    return operation.deferred.promise;
  }

  async startProcessing() {
    this.processing = true;

    while (this.queue.length > 0) {
      const batch = this.queue.splice(0, this.batchSize);

      // 동일한 타입의 작업 그룹화
      const grouped = this.groupOperations(batch);

      // 병렬 처리
      const results = await Promise.all(
        Object.entries(grouped).map(([type, ops]) =>
          this.processBatch(type, ops)
        )
      );

      // 결과 분배
      results.flat().forEach((result, index) => {
        batch[index].deferred.resolve(result);
      });

      // 다음 배치까지 대기
      await new Promise(resolve => setTimeout(resolve, this.interval));
    }

    this.processing = false;
  }

  groupOperations(batch) {
    const grouped = {};

    batch.forEach(item => {
      const type = item.operation.type;
      if (!grouped[type]) {
        grouped[type] = [];
      }
      grouped[type].push(item);
    });

    return grouped;
  }

  async processBatch(type, operations) {
    switch (type) {
      case 'keyword_extraction':
        return this.batchExtractKeywords(operations);

      case 'search':
        return this.batchSearch(operations);

      case 'profile_lookup':
        return this.batchProfileLookup(operations);

      default:
        return operations.map(op => this.processSingle(op));
    }
  }
}

```

### 3.5.3 비동기 처리

```jsx
class AsyncMCPHandler {
  constructor(mcpServer) {
    this.mcp = mcpServer;
    this.workers = this.initializeWorkers();
  }

  initializeWorkers() {
    const numWorkers = 4;
    const workers = [];

    for (let i = 0; i < numWorkers; i++) {
      workers.push({
        id: i,
        busy: false,
        queue: []
      });
    }

    return workers;
  }

  async executeAsync(toolName, args, priority = 'normal') {
    // 우선순위 큐에 추가
    const task = {
      id: generateId(),
      tool: toolName,
      args,
      priority,
      timestamp: Date.now()
    };

    // 가용한 워커 찾기
    const worker = this.findAvailableWorker();

    if (worker) {
      return this.executeOnWorker(worker, task);
    } else {
      // 큐에 추가하고 대기
      return this.queueTask(task);
    }
  }

  async executeOnWorker(worker, task) {
    worker.busy = true;

    try {
      const result = await this.mcp.callTool(task.tool, task.args);

      // 성공 시 대기 중인 작업 처리
      if (worker.queue.length > 0) {
        const nextTask = worker.queue.shift();
        this.executeOnWorker(worker, nextTask);
      } else {
        worker.busy = false;
      }

      return result;
    } catch (error) {
      worker.busy = false;
      throw error;
    }
  }

  // 스트리밍 응답 지원
  async *streamResponse(toolName, args) {
    const streamableTools = ['generate_response', 'search_youtube_shorts'];

    if (!streamableTools.includes(toolName)) {
      yield await this.executeAsync(toolName, args);
      return;
    }

    // 청크 단위로 결과 전송
    const chunkSize = 5;
    const results = await this.mcp.callTool(toolName, args);
    const items = JSON.parse(results.content[0].text).videos || [];

    for (let i = 0; i < items.length; i += chunkSize) {
      yield items.slice(i, i + chunkSize);

      // 네트워크 지연 시뮬레이션 방지
      await new Promise(resolve => setImmediate(resolve));
    }
  }
}

```