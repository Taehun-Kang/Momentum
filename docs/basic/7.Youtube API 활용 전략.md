# YouTube API 활용 전략 (YouTube API Strategy)

## 7.1 API 할당량 관리

### 7.1.1 일일 10,000 units 분배

**API 비용 구조:**
- search.list: 100 units per call
- videos.list: 1 unit per call (part=id)
- videos.list: +2 units per part (snippet, contentDetails, statistics 등)

**최적화 전략:**
- search.list 1회(100 units) + videos.list 50회(50~150 units) = 150~250 units
- 일일 약 40~66회 검색 가능

```jsx
// quota-distribution.js
class QuotaDistribution {
  constructor() {
    // 개선된 할당량 분배 전략 (2단계 필터링 고려)
    this.distribution = {
      popular_keywords: {
        units: 2500,
        percentage: 25,
        description: '인기 키워드 캐싱 (7-30일 캐싱)',
        priority: 1,
        schedule: 'daily at 03:00',
        strategy: '상위 50개 키워드 사전 캐싱'
      },
      realtime_trends: {
        units: 2000,
        percentage: 20,
        description: '실시간 트렌드 키워드 (4시간 캐싱)',
        priority: 2,
        schedule: 'every 4 hours',
        strategy: 'Bright Data MCP + YouTube 트렌드 혼합'
      },
      premium_users: {
        units: 3500,
        percentage: 35,
        description: '프리미엄 유저 실시간 검색',
        priority: 3,
        schedule: 'on demand',
        strategy: 'AI 대화형 검색 + 개인화'
      },
      emergency_reserve: {
        units: 2000,
        percentage: 20,
        description: '예비 할당량 (피크 시간, 캐시 미스)',
        priority: 4,
        schedule: 'as needed',
        strategy: '80% 사용 시 경고, 90% 시 캐시 전용 모드'
      }
    };

    this.dailyLimit = 10000;
    this.usage = this.initializeUsage();
  }

  initializeUsage() {
    const usage = {};
    Object.keys(this.distribution).forEach(category => {
      usage[category] = {
        used: 0,
        available: this.distribution[category].units,
        lastReset: new Date().setHours(0, 0, 0, 0)
      };
    });
    return usage;
  }

  // 할당량 요청
  async requestQuota(category, units, options = {}) {
    const categoryConfig = this.distribution[category];
    if (!categoryConfig) {
      throw new Error(`Invalid quota category: ${category}`);
    }

    // 할당량 확인
    const available = this.getAvailableQuota(category);

    if (available >= units) {
      // 정상 할당
      this.usage[category].used += units;

      await this.logQuotaUsage(category, units, 'success', options);
      return { approved: true, units, category };
    }

    // 할당량 부족 - 대체 전략
    const fallback = await this.handleQuotaShortage(category, units, options);
    return fallback;
  }

  async handleQuotaShortage(category, units, options) {
    // 1. 긴급 버퍼에서 차용 시도
    if (category !== 'emergency_buffer') {
      const bufferAvailable = this.getAvailableQuota('emergency_buffer');

      if (bufferAvailable >= units) {
        this.usage.emergency_buffer.used += units;

        await this.logQuotaUsage('emergency_buffer', units, 'borrowed', {
          ...options,
          borrowedFor: category
        });

        return {
          approved: true,
          units,
          category: 'emergency_buffer',
          borrowed: true
        };
      }
    }

    // 2. 다른 카테고리에서 재할당 (우선순위 기반)
    const reallocation = await this.attemptReallocation(category, units);
    if (reallocation.success) {
      return reallocation;
    }

    // 3. 할당 실패
    await this.logQuotaUsage(category, units, 'failed', options);

    return {
      approved: false,
      units: 0,
      category,
      reason: 'quota_exceeded',
      suggestion: this.getSuggestion(category)
    };
  }

  async attemptReallocation(targetCategory, units) {
    const targetPriority = this.distribution[targetCategory].priority;

    // 낮은 우선순위 카테고리에서 재할당 시도
    for (const [category, config] of Object.entries(this.distribution)) {
      if (config.priority > targetPriority) {
        const available = this.getAvailableQuota(category);

        if (available >= units * 0.5) { // 50% 이상 여유가 있을 때
          const reallocated = Math.min(units, Math.floor(available * 0.3));

          this.usage[category].available -= reallocated;
          this.usage[targetCategory].available += reallocated;

          await this.logQuotaUsage(category, reallocated, 'reallocated', {
            to: targetCategory
          });

          return {
            success: true,
            approved: true,
            units: reallocated,
            category: targetCategory,
            reallocated: true,
            from: category
          };
        }
      }
    }

    return { success: false };
  }

  getAvailableQuota(category) {
    const usage = this.usage[category];
    return usage.available - usage.used;
  }

  getTotalUsed() {
    return Object.values(this.usage).reduce((sum, cat) => sum + cat.used, 0);
  }

  getSuggestion(category) {
    const suggestions = {
      popular_keywords: '캐시된 검색 결과를 사용하거나 다음 갱신 주기를 기다려주세요.',
      trending_keywords: '4시간 전 트렌드 데이터를 사용합니다.',
      user_search_patterns: '일반 트렌드 키워드를 대신 제공합니다.',
      premium_realtime: '캐시된 유사 검색 결과를 제공합니다.',
      emergency_buffer: '모든 할당량이 소진되었습니다. 내일 다시 시도해주세요.'
    };

    return suggestions[category] || '대체 검색 방법을 사용합니다.';
  }

  async logQuotaUsage(category, units, status, metadata = {}) {
    const log = {
      timestamp: new Date(),
      category,
      units,
      status,
      totalUsed: this.getTotalUsed(),
      remaining: this.dailyLimit - this.getTotalUsed(),
      metadata
    };

    // 데이터베이스에 로그 저장
    await supabase
      .from('quota_logs')
      .insert(log);

    // 실시간 모니터링
    if (status === 'failed' || this.getTotalUsed() > this.dailyLimit * 0.8) {
      await this.sendAlert(log);
    }
  }
}

```

### 7.1.2 할당량 모니터링

```jsx
// quota-monitor.js
class QuotaMonitor {
  constructor(quotaDistribution) {
    this.quota = quotaDistribution;
    this.alerts = new Map();
    this.metrics = {
      hourly: new Map(),
      daily: new Map(),
      categoryStats: new Map()
    };

    this.startMonitoring();
  }

  startMonitoring() {
    // 실시간 모니터링 (1분마다)
    setInterval(() => this.checkQuotaStatus(), 60000);

    // 시간별 집계 (매시간)
    setInterval(() => this.aggregateHourlyStats(), 3600000);

    // 일일 리포트 (매일 23:50)
    this.scheduleDailyReport();
  }

  async checkQuotaStatus() {
    const status = {
      timestamp: new Date(),
      total: {
        limit: this.quota.dailyLimit,
        used: this.quota.getTotalUsed(),
        remaining: this.quota.dailyLimit - this.quota.getTotalUsed(),
        percentage: (this.quota.getTotalUsed() / this.quota.dailyLimit) * 100
      },
      categories: {}
    };

    // 카테고리별 상태
    for (const [category, config] of Object.entries(this.quota.distribution)) {
      const usage = this.quota.usage[category];
      status.categories[category] = {
        limit: config.units,
        used: usage.used,
        available: usage.available - usage.used,
        percentage: (usage.used / config.units) * 100
      };
    }

    // 경고 확인
    this.checkAlerts(status);

    // 메트릭 저장
    this.updateMetrics(status);

    return status;
  }

  checkAlerts(status) {
    // 전체 할당량 경고
    if (status.total.percentage >= 90 && !this.alerts.has('total_90')) {
      this.sendAlert('critical', '전체 API 할당량 90% 초과', status.total);
      this.alerts.set('total_90', true);
    } else if (status.total.percentage >= 80 && !this.alerts.has('total_80')) {
      this.sendAlert('warning', '전체 API 할당량 80% 초과', status.total);
      this.alerts.set('total_80', true);
    }

    // 카테고리별 경고
    for (const [category, stats] of Object.entries(status.categories)) {
      if (stats.percentage >= 95) {
        const alertKey = `${category}_95`;
        if (!this.alerts.has(alertKey)) {
          this.sendAlert('critical', `${category} 할당량 95% 초과`, stats);
          this.alerts.set(alertKey, true);
        }
      }
    }

    // 비정상 사용 패턴 감지
    this.detectAnomalies(status);
  }

  async detectAnomalies(status) {
    const currentHour = new Date().getHours();
    const expectedUsage = this.getExpectedUsage(currentHour);

    // 예상 사용량 대비 150% 초과 시
    if (status.total.used > expectedUsage * 1.5) {
      await this.sendAlert('warning', '비정상적인 API 사용량 감지', {
        expected: expectedUsage,
        actual: status.total.used,
        ratio: (status.total.used / expectedUsage).toFixed(2)
      });
    }
  }

  getExpectedUsage(hour) {
    // 과거 데이터 기반 시간별 예상 사용량
    const historicalUsage = {
      0: 200, 1: 150, 2: 100, 3: 100, 4: 150, 5: 200,
      6: 300, 7: 500, 8: 700, 9: 900, 10: 1000, 11: 1100,
      12: 1200, 13: 1100, 14: 1000, 15: 900, 16: 800, 17: 900,
      18: 1100, 19: 1300, 20: 1400, 21: 1300, 22: 1000, 23: 600
    };

    // 누적 예상 사용량 계산
    let total = 0;
    for (let h = 0; h <= hour; h++) {
      total += historicalUsage[h] || 0;
    }

    return total;
  }

  async sendAlert(level, message, data) {
    const alert = {
      level,
      message,
      data,
      timestamp: new Date()
    };

    // 슬랙 웹훅
    if (process.env.SLACK_WEBHOOK_URL) {
      await fetch(process.env.SLACK_WEBHOOK_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          text: `:warning: ${message}`,
          attachments: [{
            color: level === 'critical' ? 'danger' : 'warning',
            fields: Object.entries(data).map(([key, value]) => ({
              title: key,
              value: String(value),
              short: true
            }))
          }]
        })
      });
    }

    // 이메일 알림 (critical만)
    if (level === 'critical') {
      await this.sendEmailAlert(alert);
    }

    // 로그 저장
    await supabase
      .from('quota_alerts')
      .insert(alert);
  }

  updateMetrics(status) {
    const hour = new Date().getHours();

    // 시간별 메트릭
    if (!this.metrics.hourly.has(hour)) {
      this.metrics.hourly.set(hour, []);
    }
    this.metrics.hourly.get(hour).push(status);

    // 카테고리별 통계
    for (const [category, stats] of Object.entries(status.categories)) {
      if (!this.metrics.categoryStats.has(category)) {
        this.metrics.categoryStats.set(category, {
          totalUsed: 0,
          peakUsage: 0,
          requests: 0
        });
      }

      const catStats = this.metrics.categoryStats.get(category);
      catStats.totalUsed = stats.used;
      catStats.peakUsage = Math.max(catStats.peakUsage, stats.used);
      catStats.requests++;
    }
  }

  async generateDailyReport() {
    const report = {
      date: new Date().toISOString().split('T')[0],
      summary: {
        totalUsed: this.quota.getTotalUsed(),
        totalLimit: this.quota.dailyLimit,
        efficiency: (this.quota.getTotalUsed() / this.quota.dailyLimit * 100).toFixed(2) + '%'
      },
      categoryBreakdown: {},
      hourlyPattern: {},
      recommendations: []
    };

    // 카테고리별 분석
    for (const [category, stats] of this.metrics.categoryStats) {
      const config = this.quota.distribution[category];
      report.categoryBreakdown[category] = {
        allocated: config.units,
        used: stats.totalUsed,
        efficiency: (stats.totalUsed / config.units * 100).toFixed(2) + '%',
        peakUsage: stats.peakUsage
      };
    }

    // 시간별 패턴 분석
    for (const [hour, dataPoints] of this.metrics.hourly) {
      const avgUsage = dataPoints.reduce((sum, dp) => sum + dp.total.used, 0) / dataPoints.length;
      report.hourlyPattern[hour] = Math.round(avgUsage);
    }

    // 최적화 추천사항
    report.recommendations = this.generateRecommendations(report);

    // 리포트 저장
    await supabase
      .from('quota_reports')
      .insert(report);

    return report;
  }

  generateRecommendations(report) {
    const recommendations = [];

    // 1. 사용률이 낮은 카테고리 재할당 제안
    for (const [category, stats] of Object.entries(report.categoryBreakdown)) {
      if (parseFloat(stats.efficiency) < 50) {
        recommendations.push({
          type: 'reallocation',
          category,
          message: `${category}의 사용률이 ${stats.efficiency}로 낮습니다. 할당량을 줄이고 다른 카테고리로 재할당을 고려하세요.`,
          suggestedUnits: Math.ceil(stats.used * 1.2)
        });
      }
    }

    // 2. 피크 시간대 최적화
    const peakHours = Object.entries(report.hourlyPattern)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 3)
      .map(([hour]) => hour);

    recommendations.push({
      type: 'peak_optimization',
      message: `피크 시간대(${peakHours.join(', ')}시)에 캐싱을 강화하여 API 사용을 줄일 수 있습니다.`,
      peakHours
    });

    // 3. 전체 사용률 기반 제안
    const totalEfficiency = parseFloat(report.summary.efficiency);
    if (totalEfficiency > 95) {
      recommendations.push({
        type: 'capacity',
        message: '일일 할당량의 95% 이상을 사용 중입니다. 캐싱 전략 개선이나 할당량 증가를 고려하세요.'
      });
    } else if (totalEfficiency < 70) {
      recommendations.push({
        type: 'underutilization',
        message: '할당량 사용률이 낮습니다. 더 많은 기능을 활성화하거나 캐시 만료 시간을 단축할 수 있습니다.'
      });
    }

    return recommendations;
  }
}

```

### 7.1.3 초과 시 대응 방안

```jsx
// quota-fallback-strategy.js
class QuotaFallbackStrategy {
  constructor(quotaManager, cacheManager) {
    this.quota = quotaManager;
    this.cache = cacheManager;
    this.strategies = this.initializeStrategies();
  }

  initializeStrategies() {
    return {
      keyword_search: [
        this.checkCache.bind(this),
        this.findSimilarCache.bind(this),
        this.useStaleCache.bind(this),
        this.provideTrendingFallback.bind(this),
        this.returnMinimalResults.bind(this)
      ],
      ai_chat: [
        this.checkRecentConversations.bind(this),
        this.simplifyRequest.bind(this),
        this.useLocalPatternMatching.bind(this),
        this.suggestAlternatives.bind(this)
      ],
      trending: [
        this.useLastKnownTrends.bind(this),
        this.aggregateHistoricalTrends.bind(this),
        this.provideCategoryDefaults.bind(this)
      ]
    };
  }

  async handleQuotaExceeded(request) {
    const { type, data, user } = request;
    const strategies = this.strategies[type] || this.strategies.keyword_search;

    // 전략을 순서대로 시도
    for (const strategy of strategies) {
      try {
        const result = await strategy(request);
        if (result.success) {
          // 사용자에게 폴백 사용 알림
          result.notification = this.getFallbackNotification(result.strategy);

          // 폴백 사용 로그
          await this.logFallbackUsage(request, result);

          return result;
        }
      } catch (error) {
        console.error(`Fallback strategy failed:`, error);
      }
    }

    // 모든 전략 실패
    return this.getFailureResponse(request);
  }

  // 전략 1: 캐시 확인
  async checkCache(request) {
    const { data } = request;
    const cacheKey = this.generateCacheKey(data);
    const cached = await this.cache.get(cacheKey);

    if (cached && !this.isExpired(cached)) {
      return {
        success: true,
        strategy: 'cache_hit',
        data: cached.data,
        source: 'cache',
        age: Date.now() - cached.timestamp
      };
    }

    return { success: false };
  }

  // 전략 2: 유사 캐시 검색
  async findSimilarCache(request) {
    const { data } = request;
    const keywords = data.keywords || [data.query];

    // 각 키워드에 대해 유사도 계산
    const similarResults = [];

    for (const keyword of keywords) {
      const similar = await this.findSimilarKeywords(keyword);

      for (const simKeyword of similar) {
        const cached = await this.cache.get(`search:${simKeyword}`);
        if (cached && !this.isExpired(cached)) {
          similarResults.push({
            keyword: simKeyword,
            similarity: this.calculateSimilarity(keyword, simKeyword),
            data: cached.data
          });
        }
      }
    }

    if (similarResults.length > 0) {
      // 유사도 순으로 정렬
      similarResults.sort((a, b) => b.similarity - a.similarity);

      return {
        success: true,
        strategy: 'similar_cache',
        data: this.mergeSimilarResults(similarResults),
        source: 'similar',
        matchedKeywords: similarResults.map(r => r.keyword)
      };
    }

    return { success: false };
  }

  // 전략 3: 만료된 캐시 사용
  async useStaleCache(request) {
    const { data } = request;
    const cacheKey = this.generateCacheKey(data);
    const cached = await this.cache.get(cacheKey, { includeExpired: true });

    if (cached) {
      const age = Date.now() - cached.timestamp;
      const maxStaleAge = 24 * 60 * 60 * 1000; // 24시간

      if (age < maxStaleAge) {
        return {
          success: true,
          strategy: 'stale_cache',
          data: cached.data,
          source: 'expired_cache',
          age,
          expired: true
        };
      }
    }

    return { success: false };
  }

  // 전략 4: 트렌딩 콘텐츠 제공
  async provideTrendingFallback(request) {
    const trendingCache = await this.cache.get('trending:general:latest');

    if (trendingCache && trendingCache.data) {
      // 요청과 관련된 트렌딩 콘텐츠 필터링
      const filtered = this.filterRelevantTrending(trendingCache.data, request.data);

      if (filtered.length > 0) {
        return {
          success: true,
          strategy: 'trending_fallback',
          data: filtered,
          source: 'trending',
          relevance: 'partial'
        };
      }
    }

    return { success: false };
  }

  // 전략 5: 최소 결과 제공
  async returnMinimalResults(request) {
    // 가장 인기 있는 기본 콘텐츠 제공
    const defaults = await this.getDefaultContent(request.data.category);

    return {
      success: true,
      strategy: 'minimal_results',
      data: defaults,
      source: 'defaults',
      relevance: 'low'
    };
  }

  // AI 채팅 전용 전략
  async simplifyRequest(request) {
    const { data } = request;
    const simplified = this.simplifyQuery(data.message);

    // 단순화된 쿼리로 캐시 검색
    const cacheKey = `chat:simplified:${simplified}`;
    const cached = await this.cache.get(cacheKey);

    if (cached) {
      return {
        success: true,
        strategy: 'simplified_query',
        data: cached.data,
        source: 'simplified',
        originalQuery: data.message,
        simplifiedQuery: simplified
      };
    }

    return { success: false };
  }

  async useLocalPatternMatching(request) {
    const { data } = request;
    const patterns = {
      greeting: /안녕|하이|반가워/,
      recommendation: /추천|보여줘|찾아줘/,
      mood: {
        happy: /기분.*좋|신나|즐거/,
        sad: /슬프|우울|힘들/,
        tired: /피곤|지쳐|졸려/
      },
      time: {
        morning: /아침|출근|모닝/,
        evening: /저녁|퇴근|밤/
      },
      category: {
        music: /음악|노래|뮤직/,
        food: /음식|먹방|요리/,
        game: /게임|플레이/
      }
    };

    // 패턴 매칭으로 의도 파악
    const intent = this.matchPatterns(data.message, patterns);

    if (intent.matched) {
      // 의도에 맞는 기본 응답 생성
      const response = await this.generatePatternResponse(intent);

      return {
        success: true,
        strategy: 'pattern_matching',
        data: response,
        source: 'local',
        matchedPatterns: intent.patterns
      };
    }

    return { success: false };
  }

  // 유틸리티 메서드
  calculateSimilarity(str1, str2) {
    // Levenshtein distance 기반 유사도
    const matrix = [];
    const len1 = str1.length;
    const len2 = str2.length;

    for (let i = 0; i <= len2; i++) {
      matrix[i] = [i];
    }

    for (let j = 0; j <= len1; j++) {
      matrix[0][j] = j;
    }

    for (let i = 1; i <= len2; i++) {
      for (let j = 1; j <= len1; j++) {
        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j] + 1
          );
        }
      }
    }

    const distance = matrix[len2][len1];
    const maxLength = Math.max(len1, len2);

    return 1 - (distance / maxLength);
  }

  getFallbackNotification(strategy) {
    const notifications = {
      cache_hit: null, // 캐시 히트는 알림 불필요
      similar_cache: '유사한 검색 결과를 제공합니다.',
      stale_cache: '최신 정보가 아닐 수 있습니다.',
      trending_fallback: '현재 인기 있는 콘텐츠를 보여드립니다.',
      minimal_results: 'API 제한으로 기본 콘텐츠를 제공합니다.',
      simplified_query: '검색어를 단순화하여 결과를 찾았습니다.',
      pattern_matching: 'AI 대화 기능이 제한되어 기본 응답을 제공합니다.'
    };

    return notifications[strategy];
  }

  async logFallbackUsage(request, result) {
    await supabase
      .from('fallback_logs')
      .insert({
        request_type: request.type,
        user_id: request.user?.id,
        strategy_used: result.strategy,
        success: result.success,
        timestamp: new Date(),
        metadata: {
          request_data: request.data,
          result_summary: {
            itemCount: result.data?.length,
            source: result.source,
            relevance: result.relevance
          }
        }
      });
  }
}

```

## 7.2 검색 최적화

### 7.2.1 쿼리 최적화

```jsx
// search-optimizer.js
class SearchOptimizer {
  constructor() {
    this.queryCache = new Map();
    this.stopWords = this.loadStopWords();
    this.synonyms = this.loadSynonyms();
  }

  optimizeQuery(query, options = {}) {
    // 1. 정규화
    let optimized = this.normalizeQuery(query);

    // 2. 불용어 제거
    optimized = this.removeStopWords(optimized);

    // 3. 동의어 확장
    if (options.expandSynonyms) {
      optimized = this.expandWithSynonyms(optimized);
    }

    // 4. 카테고리 힌트 추가
    optimized = this.addCategoryHints(optimized);

    // 5. 시간 관련 키워드 처리
    optimized = this.processTimeKeywords(optimized);

    // 6. 쿼리 길이 최적화
    optimized = this.optimizeLength(optimized);

    return optimized;
  }

  normalizeQuery(query) {
    return query
      .toLowerCase()
      .replace(/[^\w\s가-힣]/g, ' ') // 특수문자 제거
      .replace(/\s+/g, ' ') // 연속 공백 제거
      .trim();
  }

  removeStopWords(query) {
    const words = query.split(' ');
    const filtered = words.filter(word =>
      !this.stopWords.has(word) && word.length > 1
    );

    return filtered.join(' ');
  }

  loadStopWords() {
    return new Set([
      // 한국어 불용어
      '의', '가', '이', '은', '들', '는', '좀', '잘', '걍', '과',
      '도', '를', '으로', '자', '에', '와', '한', '하다',
      // 영어 불용어
      'the', 'is', 'at', 'which', 'on', 'a', 'an', 'as', 'are',
      'been', 'by', 'for', 'from', 'has', 'have', 'in', 'of', 'to'
    ]);
  }

  expandWithSynonyms(query) {
    const words = query.split(' ');
    const expanded = new Set(words);

    words.forEach(word => {
      const synonyms = this.synonyms.get(word);
      if (synonyms) {
        synonyms.forEach(syn => expanded.add(syn));
      }
    });

    return Array.from(expanded).join(' ');
  }

  loadSynonyms() {
    const synonyms = new Map();

    // 일반 동의어
    synonyms.set('웃긴', ['재미있는', '코미디', '유머']);
    synonyms.set('맛있는', ['먹방', '음식', '요리']);
    synonyms.set('게임', ['플레이', '겜', '게이밍']);
    synonyms.set('음악', ['노래', '뮤직', '뮤비']);

    // 감정 동의어
    synonyms.set('슬픈', ['우울한', '감성적인', '눈물']);
    synonyms.set('신나는', ['흥겨운', '즐거운', '파티']);
    synonyms.set('무서운', ['공포', '호러', '스릴러']);

    // 시간 동의어
    synonyms.set('아침', ['모닝', '출근', '기상']);
    synonyms.set('저녁', ['밤', '퇴근', '야간']);

    return synonyms;
  }

  addCategoryHints(query) {
    const categoryKeywords = {
      music: ['음악', '노래', '뮤직', '댄스', '춤'],
      gaming: ['게임', '플레이', '공략', '리뷰'],
      food: ['음식', '먹방', '요리', '레시피', '맛집'],
      comedy: ['웃긴', '개그', '코미디', '재미'],
      lifestyle: ['일상', '브이로그', '루틴', 'vlog'],
      education: ['강의', '공부', '튜토리얼', '설명']
    };

    const words = query.split(' ');
    const detectedCategories = new Set();

    for (const [category, keywords] of Object.entries(categoryKeywords)) {
      if (keywords.some(keyword => words.includes(keyword))) {
        detectedCategories.add(category);
      }
    }

    // 카테고리가 감지되면 관련 키워드 추가
    if (detectedCategories.size > 0) {
      const categories = Array.from(detectedCategories);
      return `${query} ${categories.join(' ')}`;
    }

    return query;
  }

  processTimeKeywords(query) {
    const now = new Date();
    const hour = now.getHours();

    const timeContextMap = {
      '지금': this.getCurrentTimeContext(hour),
      '오늘': this.getDayContext(now.getDay()),
      '요즘': 'trending 2024',
      '최신': 'latest new',
      '이번주': 'this week'
    };

    let processed = query;

    for (const [keyword, context] of Object.entries(timeContextMap)) {
      if (processed.includes(keyword)) {
        processed = processed.replace(keyword, context);
      }
    }

    return processed;
  }

  getCurrentTimeContext(hour) {
    if (hour >= 6 && hour < 10) return 'morning 아침';
    if (hour >= 10 && hour < 12) return 'brunch 브런치';
    if (hour >= 12 && hour < 14) return 'lunch 점심';
    if (hour >= 14 && hour < 17) return 'afternoon 오후';
    if (hour >= 17 && hour < 20) return 'evening 저녁';
    if (hour >= 20 && hour < 24) return 'night 밤';
    return 'late night 새벽';
  }

  optimizeLength(query) {
    const words = query.split(' ');

    // YouTube API는 쿼리가 너무 길면 성능 저하
    if (words.length > 10) {
      // TF-IDF 기반으로 중요 단어만 선택
      const important = this.selectImportantWords(words);
      return important.slice(0, 8).join(' ');
    }

    return query;
  }

  // 배치 쿼리 최적화
  batchOptimize(queries) {
    const optimized = new Map();
    const similar = new Map();

    // 각 쿼리 최적화
    queries.forEach(query => {
      const opt = this.optimizeQuery(query);
      optimized.set(query, opt);
    });

    // 유사 쿼리 그룹화
    const values = Array.from(optimized.values());
    values.forEach((opt1, i) => {
      const group = [opt1];

      values.forEach((opt2, j) => {
        if (i !== j && this.areSimilar(opt1, opt2)) {
          group.push(opt2);
        }
      });

      if (group.length > 1) {
        similar.set(opt1, group);
      }
    });

    return { optimized, similar };
  }

  areSimilar(query1, query2) {
    const words1 = new Set(query1.split(' '));
    const words2 = new Set(query2.split(' '));

    const intersection = new Set([...words1].filter(x => words2.has(x)));
    const union = new Set([...words1, ...words2]);

    // Jaccard similarity
    const similarity = intersection.size / union.size;

    return similarity > 0.6;
  }
}

```

### 7.2.2 필터링 전략

```jsx
// video-filter.js
class VideoFilter {
  constructor() {
    this.qualityThresholds = {
      viewCount: 100000,
      likeRatio: 0.9,
      duration: { min: 15, max: 60 },
      age: 365 * 24 * 60 * 60 * 1000 // 1년
    };
  }

  // 2단계 필터링 워크플로우
  async performTwoStepFiltering(searchResults) {
    // 1단계: search.list 결과에서 videoId 추출
    const videoIds = searchResults.items.map(item => item.id.videoId);
    
    // 2단계: videos.list로 상세 정보 조회 (필수!)
    const detailedVideos = await this.getDetailedVideoInfo(videoIds);
    
    // 3단계: 재생 가능 여부 및 Shorts 확인
    const playableVideos = this.filterPlayableVideos(detailedVideos);
    
    // 4단계: 추가 필터링
    return this.filterVideos(playableVideos);
  }

  async getDetailedVideoInfo(videoIds) {
    // 배치로 처리 (최대 50개씩)
    const batchSize = 50;
    const batches = [];
    
    for (let i = 0; i < videoIds.length; i += batchSize) {
      batches.push(videoIds.slice(i, i + batchSize));
    }
    
    const results = await Promise.all(
      batches.map(batch => 
        this.youtube.videos.list({
          part: 'snippet,contentDetails,status,statistics',
          id: batch.join(','),
          hl: 'ko'
        })
      )
    );
    
    return results.flatMap(r => r.data.items);
  }

  filterPlayableVideos(videos) {
    return videos.filter(video => {
      // 1. 임베드 가능 여부 확인 (중요!)
      if (!video.status.embeddable) {
        console.log(`Video ${video.id} is not embeddable`);
        return false;
      }
      
      // 2. 공개 상태 확인
      if (video.status.privacyStatus !== 'public') {
        console.log(`Video ${video.id} is not public`);
        return false;
      }
      
      // 3. 라이선스 확인
      if (video.status.license === 'creativeCommon' && 
          video.contentDetails.licensedContent) {
        console.log(`Video ${video.id} has license restrictions`);
        return false;
      }
      
      // 4. 지역 제한 확인
      const restrictions = video.contentDetails.regionRestriction;
      if (restrictions) {
        if (restrictions.blocked?.includes('KR') ||
            (restrictions.allowed && !restrictions.allowed.includes('KR'))) {
          console.log(`Video ${video.id} is blocked in KR`);
          return false;
        }
      }
      
      // 5. Shorts 길이 확인 (60초 이하)
      const duration = this.parseDuration(video.contentDetails.duration);
      if (duration > 60) {
        console.log(`Video ${video.id} is longer than 60s: ${duration}s`);
        return false;
      }
      
      return true;
    });
  }

  async filterVideos(videos, options = {}) {
    let filtered = [...videos];

    // 1. 기본 품질 필터
    filtered = this.applyQualityFilter(filtered, options);

    // 2. Shorts 검증 (이미 filterPlayableVideos에서 기본 검증 완료)
    filtered = await this.verifyShortsFormat(filtered);

    // 3. 컨텐츠 적합성
    filtered = this.checkContentSuitability(filtered, options);

    // 4. 중복 제거
    filtered = this.removeDuplicates(filtered);

    // 5. 사용자 선호도 필터
    if (options.userPreferences) {
      filtered = this.applyUserPreferences(filtered, options.userPreferences);
    }

    return filtered;
  }

  applyQualityFilter(videos, options) {
    const thresholds = { ...this.qualityThresholds, ...options.thresholds };

    return videos.filter(video => {
      // 조회수 필터
      if (video.statistics.viewCount < thresholds.viewCount) {
        return false;
      }

      // 좋아요 비율 (좋아요가 있는 경우만)
      if (video.statistics.likeCount > 0) {
        const totalEngagement = video.statistics.likeCount +
                              (video.statistics.dislikeCount || 0);
        const likeRatio = video.statistics.likeCount / totalEngagement;

        if (likeRatio < thresholds.likeRatio) {
          return false;
        }
      }

      // 길이 필터
      const duration = this.parseDuration(video.contentDetails.duration);
      if (duration < thresholds.duration.min ||
          duration > thresholds.duration.max) {
        return false;
      }

      // 업로드 날짜 (너무 오래된 영상 제외)
      const publishedAt = new Date(video.snippet.publishedAt);
      const age = Date.now() - publishedAt.getTime();
      if (age > thresholds.age) {
        return false;
      }

      return true;
    });
  }

  async verifyShortsFormat(videos) {
    const verified = [];

    for (const video of videos) {
      // Shorts 특징 확인
      const isShorts = await this.checkShortsCharacteristics(video);

      if (isShorts) {
        verified.push({
          ...video,
          isVerifiedShorts: true
        });
      }
    }

    return verified;
  }

  checkShortsCharacteristics(video) {
    // 1. 제목에 #Shorts 포함
    if (video.snippet.title.toLowerCase().includes('#shorts')) {
      return true;
    }

    // 2. 세로 형식 (9:16 비율) 확인
    if (video.snippet.thumbnails) {
      const thumbnail = video.snippet.thumbnails.high ||
                       video.snippet.thumbnails.medium;
      if (thumbnail && thumbnail.height > thumbnail.width) {
        return true;
      }
    }

    // 3. 길이가 60초 이하
    const duration = this.parseDuration(video.contentDetails.duration);
    if (duration <= 60) {
      return true;
    }

    return false;
  }

  checkContentSuitability(videos, options) {
    const blockedKeywords = [
      // 부적절한 콘텐츠 키워드
      '19금', '성인', '후방주의', '혐오', '폭력',
      // 스팸성 키워드
      '구독하세요', '좋아요눌러', '알림설정'
    ];

    return videos.filter(video => {
      const text = `${video.snippet.title} ${video.snippet.description}`.toLowerCase();

      // 차단 키워드 확인
      const hasBlockedContent = blockedKeywords.some(keyword =>
        text.includes(keyword)
      );

      if (hasBlockedContent && !options.allowBlockedContent) {
        return false;
      }

      // 연령 제한 확인
      if (video.contentDetails.contentRating?.ytRating === 'ytAgeRestricted' &&
          !options.includeAgeRestricted) {
        return false;
      }

      return true;
    });
  }

  removeDuplicates(videos) {
    const seen = new Map();
    const unique = [];

    for (const video of videos) {
      // 채널별로 최대 2개까지만 허용
      const channelCount = seen.get(video.snippet.channelId) || 0;

      if (channelCount < 2) {
        unique.push(video);
        seen.set(video.snippet.channelId, channelCount + 1);
      }
    }

    return unique;
  }

  checkRegionRestrictions(videos, userRegion = 'KR') {
    return videos.filter(video => {
      const restrictions = video.contentDetails.regionRestriction;

      if (!restrictions) {
        return true; // 제한 없음
      }

      // 차단 목록에 있는지 확인
      if (restrictions.blocked && restrictions.blocked.includes(userRegion)) {
        return false;
      }

      // 허용 목록이 있고 포함되지 않은 경우
      if (restrictions.allowed && !restrictions.allowed.includes(userRegion)) {
        return false;
      }

      return true;
    });
  }

  applyUserPreferences(videos, preferences) {
    return videos.map(video => {
      let score = video.relevanceScore || 1.0;

      // 선호 카테고리 가중치
      if (preferences.categories?.includes(video.snippet.categoryId)) {
        score *= 1.5;
      }

      // 선호 채널 가중치
      if (preferences.channels?.includes(video.snippet.channelId)) {
        score *= 2.0;
      }

      // 차단 채널 필터
      if (preferences.blockedChannels?.includes(video.snippet.channelId)) {
        score = 0;
      }

      // 언어 선호도
      if (preferences.languages) {
        const videoLang = video.snippet.defaultLanguage ||
                         video.snippet.defaultAudioLanguage || 'ko';
        if (!preferences.languages.includes(videoLang)) {
          score *= 0.5;
        }
      }

      return {
        ...video,
        personalizedScore: score
      };
    }).filter(video => video.personalizedScore > 0)
      .sort((a, b) => b.personalizedScore - a.personalizedScore);
  }

  parseDuration(isoDuration) {
    const match = isoDuration.match(/PT(?:(\d+)M)?(?:(\d+)S)?/);
    if (!match) return 0;

    const minutes = parseInt(match[1] || 0);
    const seconds = parseInt(match[2] || 0);

    return minutes * 60 + seconds;
  }
}

```

### 7.2.3 결과 캐싱

```jsx
// result-cache-manager.js
class ResultCacheManager {
  constructor(redis, supabase) {
    this.redis = redis;
    this.supabase = supabase;
    this.cacheLevels = {
      L1: { ttl: 300, storage: 'memory' },      // 5분 - 메모리
      L2: { ttl: 3600, storage: 'redis' },      // 1시간 - Redis
      L3: { ttl: 86400, storage: 'database' }   // 24시간 - DB
    };
  }

  async get(key, options = {}) {
    // L1: 메모리 캐시 확인
    const memoryCache = this.getFromMemory(key);
    if (memoryCache && !options.skipL1) {
      this.recordHit('L1');
      return memoryCache;
    }

    // L2: Redis 캐시 확인
    const redisCache = await this.getFromRedis(key);
    if (redisCache && !options.skipL2) {
      this.recordHit('L2');
      // L1에도 저장
      this.setToMemory(key, redisCache);
      return redisCache;
    }

    // L3: 데이터베이스 캐시 확인
    const dbCache = await this.getFromDatabase(key);
    if (dbCache && !options.skipL3) {
      this.recordHit('L3');
      // L1, L2에도 저장
      await this.propagateToUpperLevels(key, dbCache);
      return dbCache;
    }

    this.recordMiss();
    return null;
  }

  async set(key, value, options = {}) {
    const ttl = options.ttl || this.calculateOptimalTTL(key, value);

    // 모든 레벨에 저장
    await Promise.all([
      this.setToMemory(key, value, Math.min(ttl, this.cacheLevels.L1.ttl)),
      this.setToRedis(key, value, Math.min(ttl, this.cacheLevels.L2.ttl)),
      this.setToDatabase(key, value, ttl)
    ]);

    // 캐시 통계 업데이트
    await this.updateCacheStats(key, value);
  }

  // 메모리 캐시 (LRU)
  memoryCache = new Map();
  memoryCacheSize = 1000;

  getFromMemory(key) {
    const cached = this.memoryCache.get(key);
    if (cached && cached.expires > Date.now()) {
      // LRU: 최근 사용으로 이동
      this.memoryCache.delete(key);
      this.memoryCache.set(key, cached);
      return cached.data;
    }
    return null;
  }

  setToMemory(key, value, ttl = 300) {
    // 크기 제한 확인
    if (this.memoryCache.size >= this.memoryCacheSize) {
      // 가장 오래된 항목 제거 (LRU)
      const firstKey = this.memoryCache.keys().next().value;
      this.memoryCache.delete(firstKey);
    }

    this.memoryCache.set(key, {
      data: value,
      expires: Date.now() + (ttl * 1000),
      size: this.calculateSize(value)
    });
  }

  // Redis 캐시
  async getFromRedis(key) {
    try {
      const cached = await this.redis.get(`cache:${key}`);
      if (cached) {
        return JSON.parse(cached);
      }
    } catch (error) {
      console.error('Redis get error:', error);
    }
    return null;
  }

  async setToRedis(key, value, ttl = 3600) {
    try {
      await this.redis.setex(
        `cache:${key}`,
        ttl,
        JSON.stringify(value)
      );
    } catch (error) {
      console.error('Redis set error:', error);
    }
  }

  // 데이터베이스 캐시
  async getFromDatabase(key) {
    try {
      const { data } = await this.supabase
        .from('search_cache')
        .select('*')
        .eq('cache_key', key)
        .gt('expires_at', new Date().toISOString())
        .single();

      if (data) {
        // 히트 카운트 증가
        await this.supabase
          .from('search_cache')
          .update({ hit_count: data.hit_count + 1 })
          .eq('id', data.id);

        return data.cached_data;
      }
    } catch (error) {
      console.error('Database get error:', error);
    }
    return null;
  }

  async setToDatabase(key, value, ttl = 86400) {
    try {
      await this.supabase
        .from('search_cache')
        .upsert({
          cache_key: key,
          cached_data: value,
          expires_at: new Date(Date.now() + ttl * 1000).toISOString(),
          created_at: new Date().toISOString(),
          hit_count: 0,
          size_bytes: this.calculateSize(value)
        });
    } catch (error) {
      console.error('Database set error:', error);
    }
  }

  // TTL 최적화
  calculateOptimalTTL(key, value) {
    // 키 타입별 기본 TTL
    const keyPatterns = {
      'trending:': 14400,     // 4시간
      'search:': 3600,        // 1시간
      'video:': 86400,        // 24시간
      'user:': 7200,          // 2시간
      'chat:': 1800           // 30분
    };

    for (const [pattern, ttl] of Object.entries(keyPatterns)) {
      if (key.startsWith(pattern)) {
        // 결과 크기에 따라 조정
        const sizeMultiplier = value.length > 50 ? 0.5 : 1;
        return Math.floor(ttl * sizeMultiplier);
      }
    }

    return 3600; // 기본 1시간
  }

  // 캐시 워밍
  async warmCache(keys) {
    const results = await Promise.allSettled(
      keys.map(async key => {
        const cached = await this.get(key);
        if (!cached) {
          // 캐시 미스 시 데이터 생성 및 캐싱
          const data = await this.generateData(key);
          if (data) {
            await this.set(key, data);
          }
        }
        return { key, cached: !!cached };
      })
    );

    const stats = {
      total: keys.length,
      hits: results.filter(r => r.value?.cached).length,
      misses: results.filter(r => !r.value?.cached).length,
      errors: results.filter(r => r.status === 'rejected').length
    };

    return stats;
  }

  // 캐시 무효화
  async invalidate(pattern) {
    const invalidated = {
      memory: 0,
      redis: 0,
      database: 0
    };

    // 메모리 캐시 무효화
    for (const [key] of this.memoryCache) {
      if (key.includes(pattern)) {
        this.memoryCache.delete(key);
        invalidated.memory++;
      }
    }

    // Redis 캐시 무효화
    const redisKeys = await this.redis.keys(`cache:*${pattern}*`);
    if (redisKeys.length > 0) {
      await this.redis.del(...redisKeys);
      invalidated.redis = redisKeys.length;
    }

    // 데이터베이스 캐시 무효화
    const { count } = await this.supabase
      .from('search_cache')
      .delete()
      .like('cache_key', `%${pattern}%`);

    invalidated.database = count || 0;

    return invalidated;
  }

  // 캐시 통계
  async getCacheStats() {
    const stats = {
      levels: {
        L1: {
          size: this.memoryCache.size,
          maxSize: this.memoryCacheSize,
          hitRate: this.calculateHitRate('L1')
        },
        L2: {
          size: await this.redis.dbsize(),
          hitRate: this.calculateHitRate('L2')
        },
        L3: {
          size: await this.getDatabaseCacheSize(),
          hitRate: this.calculateHitRate('L3')
        }
      },
      overall: {
        hitRate: this.calculateOverallHitRate(),
        avgResponseTime: this.getAverageResponseTime()
      }
    };

    return stats;
  }

  // 스마트 프리페칭
  async prefetchRelated(key, data) {
    // 관련 키워드 추출
    const relatedKeys = this.extractRelatedKeys(key, data);

    // 백그라운드에서 프리페치
    setImmediate(async () => {
      for (const relatedKey of relatedKeys) {
        const exists = await this.get(relatedKey, { skipL3: true });
        if (!exists) {
          // 관련 데이터 생성 및 캐싱
          const relatedData = await this.generateData(relatedKey);
          if (relatedData) {
            await this.set(relatedKey, relatedData, { ttl: 1800 }); // 30분
          }
        }
      }
    });
  }

  calculateSize(value) {
    return Buffer.byteLength(JSON.stringify(value), 'utf8');
  }
}

```

### 7.2.4 지능형 쿼리 빌더 with Bright Data MCP

```javascript
// intelligent-query-builder.js
import { BrightDataMCPClient } from './brightdata-mcp-client.js';
import { SupabaseMCPService } from './supabase-mcp-client.js';

class IntelligentQueryBuilder {
  constructor() {
    this.brightData = new BrightDataMCPClient();
    this.supabase = new SupabaseMCPService();
    this.channelCache = new Map();
    this.queryTemplates = this.initQueryTemplates();
    
    // 카테고리별 유명 채널 사전 정의
    this.popularChannels = {
      gaming: {
        'faker': { id: 'UC0b8Zw2a7c8uF2eVYjXiNcQ', name: 'T1 Faker' },
        'lck': { id: 'UCCwbMDOOgC4Y8If0sYlLQAg', name: 'LCK Korea' },
        'lol': { id: 'UC8C7zWjKY0SdrHjJwMMM_8g', name: 'LoL Esports' }
      },
      news: {
        'mbc': { id: 'UCF4Wxdo3inmxP-Y59wXDsFw', name: 'MBC News' },
        'sbs': { id: 'UCkinYTS9IHqOEwR1Sze2JTw', name: 'SBS News' },
        'jtbc': { id: 'UCsU-I-vHLiaMfV_ceaYz5rQ', name: 'JTBC News' },
        'ytn': { id: 'UChlgI3UHCOnwUGzWzbJ3H5w', name: 'YTN' }
      },
      music: {
        'hybe': { id: 'UC3IZKseVpdzPSBaWxBxundA', name: 'HYBE LABELS' },
        'sm': { id: 'UCEf_Bc-KVd7onSeifS3py9g', name: 'SMTOWN' },
        'jyp': { id: 'UCaO6TYtlC8U5ttz62hTrZgg', name: 'JYP Entertainment' },
        'kbs': { id: 'UC5BMQOsAB8hKUyHu9KI6yig', name: 'KBS World' }
      },
      entertainment: {
        'netflix': { id: 'UCiEEF51uRAeZeCo8CJFhGWw', name: 'Netflix Korea' },
        'tvn': { id: 'UCfD2RhqXt7w6eLCH6G1BDeQ', name: 'tvN' },
        'mnet': { id: 'UCbD8EppRX3ZwJSou-TVo90A', name: 'Mnet K-POP' }
      },
      food: {
        'paik': { id: 'UCyn-K7rZLXjGl7VXGweIlcA', name: '백종원 PAIK JONG WON' },
        'korean_englishman': { id: 'UCyEd6QBSgat5kkC6svyjudA', name: 'Korean Englishman' },
        'maangchi': { id: 'UC8gFadPgK2r1ndqLI04Xvvw', name: 'Maangchi' }
      }
    };
  }

  async buildEnhancedQuery(userQuery, options = {}) {
    const context = await this.gatherContext(userQuery);
    const queries = [];

    // 1. 기본 검색 쿼리
    const baseQuery = await this.buildBaseQuery(userQuery, context);
    queries.push({
      type: 'search',
      query: baseQuery,
      method: 'search.list',
      cost: 100
    });

    // 2. 채널별 최적화 쿼리
    if (context.channels.length > 0) {
      const channelQueries = await this.buildChannelQueries(context.channels, userQuery);
      queries.push(...channelQueries);
    }

    // 3. 시간 기반 쿼리
    if (context.timeContext) {
      const timeQuery = this.buildTimeBasedQuery(baseQuery, context.timeContext);
      queries.push({
        type: 'time_based',
        query: timeQuery,
        method: 'search.list',
        cost: 100
      });
    }

    // 4. 필터링 쿼리
    if (options.filters) {
      const filteredQuery = this.applyFilters(baseQuery, options.filters);
      queries.push({
        type: 'filtered',
        query: filteredQuery,
        method: 'search.list',
        cost: 100
      });
    }

    return {
      queries,
      context,
      estimatedCost: queries.reduce((sum, q) => sum + q.cost, 0),
      recommendations: await this.generateRecommendations(context)
    };
  }

  async gatherContext(userQuery) {
    // Bright Data MCP를 통한 실시간 컨텍스트 수집
    const searchResult = await this.brightData.callTool('search_web_trends', {
      query: userQuery,
      country: 'KR',
      language: 'ko',
      sources: ['google_trends', 'youtube_trending', 'news', 'social_media']
    });

    const context = {
      keywords: [],
      entities: [],
      channels: [],
      timeContext: null,
      trends: [],
      relatedTopics: []
    };

    // 웹 검색 결과 분석
    const webData = JSON.parse(searchResult.content[0].text);
    
    // 예시: LCK 검색 시
    if (userQuery.toLowerCase().includes('lck') || userQuery.includes('롤챔스')) {
      // 최근 경기 정보 수집
      const lckContext = await this.brightData.callTool('search_web_trends', {
        query: 'LCK 최근 경기 결과 하이라이트',
        country: 'KR',
        language: 'ko',
        time_range: 'past_week'
      });

      const lckData = JSON.parse(lckContext.content[0].text);
      
      // 선수명, 팀명 추출
      context.entities = await this.extractEntities(lckData);
      // 예: ['T1', 'Gen.G', 'Faker', 'Zeus', 'Keria']
      
      // 관련 채널 추가
      context.channels = [
        this.popularChannels.gaming.lck,
        this.popularChannels.gaming.faker,
        { id: 'UCJ6ESJBWx8LNhGbW5zYNgwQ', name: 'T1 Esports' }
      ];

      // 시간 컨텍스트 (최근 경기 날짜)
      context.timeContext = {
        type: 'recent',
        date: this.extractRecentMatchDate(lckData),
        range: 'past_week'
      };
    }

    // 뉴스 관련 쿼리
    if (userQuery.includes('뉴스') || userQuery.includes('news')) {
      context.channels.push(
        ...Object.values(this.popularChannels.news)
      );
      
      // 실시간 이슈 키워드 추가
      const newsKeywords = await this.getRealtimeNewsKeywords();
      context.keywords.push(...newsKeywords);
    }

    // 음악 관련 쿼리
    if (userQuery.includes('음악') || userQuery.includes('뮤직') || userQuery.includes('music')) {
      // 현재 차트 정보 수집
      const musicTrends = await this.brightData.callTool('search_web_trends', {
        query: '한국 음악 차트 멜론 최신곡',
        country: 'KR',
        language: 'ko'
      });

      const chartData = JSON.parse(musicTrends.content[0].text);
      context.trends = this.extractMusicTrends(chartData);
      context.channels.push(...Object.values(this.popularChannels.music));
    }

    return context;
  }

  async buildChannelQueries(channels, baseQuery) {
    const channelQueries = [];

    for (const channel of channels) {
      // 채널별 videos.list 사용 (API 비용 절감)
      channelQueries.push({
        type: 'channel_videos',
        channelId: channel.id,
        channelName: channel.name,
        method: 'videos.list',
        params: {
          channelId: channel.id,
          order: 'date',
          maxResults: 10,
          type: 'video',
          videoDuration: 'short'  // Shorts 필터
        },
                  cost: 1  // videos.list 기본 비용 (추가 part별 +2)
      });

      // 채널 내 검색 (키워드가 있는 경우)
      if (baseQuery && baseQuery.length > 0) {
        channelQueries.push({
          type: 'channel_search',
          query: `${baseQuery} channel:${channel.id}`,
          channelName: channel.name,
          method: 'search.list',
          cost: 100
        });
      }
    }

    return channelQueries;
  }

  buildTimeBasedQuery(baseQuery, timeContext) {
    const now = new Date();
    let publishedAfter, publishedBefore;

    switch (timeContext.type) {
      case 'recent':
        publishedAfter = new Date(now - 7 * 24 * 60 * 60 * 1000); // 최근 1주일
        break;
      case 'today':
        publishedAfter = new Date(now.setHours(0, 0, 0, 0));
        break;
      case 'specific_date':
        publishedAfter = new Date(timeContext.date);
        publishedBefore = new Date(timeContext.date);
        publishedBefore.setDate(publishedBefore.getDate() + 1);
        break;
      case 'trending':
        publishedAfter = new Date(now - 24 * 60 * 60 * 1000); // 24시간
        break;
    }

    return {
      q: baseQuery,
      publishedAfter: publishedAfter?.toISOString(),
      publishedBefore: publishedBefore?.toISOString(),
      order: 'date',
      relevanceLanguage: 'ko'
    };
  }

  applyFilters(baseQuery, filters) {
    const filteredQuery = { ...baseQuery };

    // 조회수 필터
    if (filters.minViews) {
      // YouTube API는 직접적인 조회수 필터를 지원하지 않으므로
      // 정렬 방식 변경으로 대체
      filteredQuery.order = 'viewCount';
    }

    // HD 영상만
    if (filters.hdOnly) {
      filteredQuery.videoDefinition = 'high';
    }

    // 자막 있는 영상만
    if (filters.withCaptions) {
      filteredQuery.videoCaption = 'closedCaption';
    }

    // 특정 카테고리
    if (filters.categoryId) {
      filteredQuery.videoCategoryId = filters.categoryId;
    }

    return filteredQuery;
  }

  async generateRecommendations(context) {
    const recommendations = [];

    // 1. 트렌딩 키워드 기반 추천
    if (context.trends.length > 0) {
      recommendations.push({
        type: 'trending',
        message: `현재 인기 키워드: ${context.trends.slice(0, 3).join(', ')}`,
        keywords: context.trends
      });
    }

    // 2. 채널 기반 추천
    if (context.channels.length > 0) {
      recommendations.push({
        type: 'channels',
        message: `추천 채널: ${context.channels.map(c => c.name).join(', ')}`,
        channels: context.channels
      });
    }

    // 3. 시간 기반 추천
    if (context.timeContext) {
      recommendations.push({
        type: 'time',
        message: this.getTimeRecommendation(context.timeContext),
        timeFilter: context.timeContext
      });
    }

    return recommendations;
  }

  async prefetchPopularChannels() {
    // 인기 채널의 최신 영상을 미리 캐싱
    const prefetchTasks = [];

    for (const category of Object.values(this.popularChannels)) {
      for (const channel of Object.values(category)) {
        prefetchTasks.push(this.cacheChannelVideos(channel));
      }
    }

    // 병렬로 실행하되 API 제한 고려
    const results = await this.batchExecute(prefetchTasks, 5); // 5개씩 배치 실행
    
    return {
      totalChannels: prefetchTasks.length,
      cached: results.filter(r => r.success).length,
      failed: results.filter(r => !r.success).length
    };
  }

  async cacheChannelVideos(channel) {
    try {
      const cacheKey = `channel:${channel.id}:latest`;
      
      // 이미 캐시되어 있는지 확인
      const cached = await this.supabase.executeQuery(
        'SELECT * FROM channel_cache WHERE channel_id = $1 AND created_at > NOW() - INTERVAL \'4 hours\'',
        [channel.id]
      );

      if (cached.length > 0) {
        return { success: true, channel: channel.name, source: 'cache' };
      }

      // YouTube API 호출 (videos.list는 비용이 적음)
      const videos = await this.youtube.videos.list({
        part: 'snippet,contentDetails,statistics',
        channelId: channel.id,
        maxResults: 20,
        order: 'date',
        type: 'video',
        videoDuration: 'short'
      });

      // 캐시 저장
      await this.supabase.executeQuery(
        `INSERT INTO channel_cache (channel_id, channel_name, videos, created_at)
         VALUES ($1, $2, $3, NOW())
         ON CONFLICT (channel_id) DO UPDATE SET videos = $3, created_at = NOW()`,
        [channel.id, channel.name, JSON.stringify(videos.data.items)]
      );

      return { success: true, channel: channel.name, source: 'api' };

    } catch (error) {
      console.error(`Failed to cache channel ${channel.name}:`, error);
      return { success: false, channel: channel.name, error: error.message };
    }
  }

  // 예시: 쿼리 생성 결과
  generateQueryExamples() {
    return {
      // 사용자 입력: "최신 LCK 하이라이트"
      lckExample: {
        input: "최신 LCK 하이라이트",
        output: {
          queries: [
            {
              type: 'search',
              query: 'LCK 하이라이트 T1 Gen.G 2024',
              method: 'search.list',
              cost: 100
            },
            {
              type: 'channel_videos',
              channelId: 'UCCwbMDOOgC4Y8If0sYlLQAg',
              channelName: 'LCK Korea',
              method: 'videos.list',
              cost: 5  // videos.list (1) + parts (2*2)
            },
            {
              type: 'time_based',
              query: {
                q: 'LCK highlights',
                publishedAfter: '2024-01-15T00:00:00Z',
                order: 'date'
              },
              method: 'search.list',
              cost: 100
            }
          ],
          context: {
            entities: ['T1', 'Gen.G', 'Faker', 'Zeus'],
            channels: [
              { id: 'UCCwbMDOOgC4Y8If0sYlLQAg', name: 'LCK Korea' }
            ],
            timeContext: { type: 'recent', range: 'past_week' }
          }
        }
      },

      // 사용자 입력: "오늘 뉴스"
      newsExample: {
        input: "오늘 뉴스",
        output: {
          queries: [
            {
              type: 'channel_search',
              query: '속보 breaking news',
              channelName: 'YTN',
              method: 'search.list',
              cost: 100
            },
            {
              type: 'channel_videos',
              channelId: 'UChlgI3UHCOnwUGzWzbJ3H5w',
              channelName: 'YTN',
              method: 'videos.list',
              params: {
                order: 'date',
                publishedAfter: new Date().toISOString().split('T')[0]
              },
              cost: 5  // videos.list (1) + parts (2*2)
            }
          ]
        }
      }
    };
  }

  // 유틸리티 메서드들
  async extractEntities(webData) {
    // 실제로는 NLP 처리가 필요하지만, 간단한 패턴 매칭으로 구현
    const entities = [];
    const text = webData.results.map(r => r.snippet).join(' ');
    
    // 팀명 패턴
    const teamPattern = /(T1|Gen\.G|DK|KT|LSB|HLE|BRO|NS|KDF|DRX)/gi;
    const teams = text.match(teamPattern) || [];
    
    // 선수명 패턴 (예시)
    const playerPattern = /(Faker|Zeus|Oner|Gumayusi|Keria|Chovy|Peanut|Deft)/gi;
    const players = text.match(playerPattern) || [];
    
    return [...new Set([...teams, ...players])];
  }

  getTimeRecommendation(timeContext) {
    switch (timeContext.type) {
      case 'recent':
        return '최근 1주일 내 인기 영상을 보여드립니다';
      case 'today':
        return '오늘 올라온 최신 영상을 보여드립니다';
      case 'trending':
        return '24시간 내 급상승 영상을 보여드립니다';
      default:
        return '관련 영상을 시간순으로 정렬했습니다';
    }
  }

  async batchExecute(tasks, batchSize) {
    const results = [];
    
    for (let i = 0; i < tasks.length; i += batchSize) {
      const batch = tasks.slice(i, i + batchSize);
      const batchResults = await Promise.allSettled(batch);
      
      results.push(...batchResults.map(r => 
        r.status === 'fulfilled' ? r.value : { success: false, error: r.reason }
      ));
      
      // API rate limiting을 위한 딜레이
      if (i + batchSize < tasks.length) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }
    
    return results;
  }
}
```

## 7.3 영상 데이터 처리

### 7.3.1 메타데이터 추출

```jsx
// metadata-extractor.js
class MetadataExtractor {
  constructor() {
    this.extractors = {
      basic: this.extractBasicMetadata.bind(this),
      statistics: this.extractStatistics.bind(this),
      content: this.extractContentMetadata.bind(this),
      channel: this.extractChannelMetadata.bind(this),
      engagement: this.calculateEngagement.bind(this),
      quality: this.assessQuality.bind(this)
    };
  }

  async extractFullMetadata(videoData) {
    const metadata = {};

    // 병렬로 모든 추출기 실행
    const results = await Promise.allSettled(
      Object.entries(this.extractors).map(async ([key, extractor]) => {
        return { key, data: await extractor(videoData) };
      })
    );

    // 결과 병합
    results.forEach(result => {
      if (result.status === 'fulfilled') {
        metadata[result.value.key] = result.value.data;
      }
    });

    // AI 분석 추가
    metadata.ai = await this.performAIAnalysis(metadata);

    return metadata;
  }

  extractBasicMetadata(video) {
    return {
      videoId: video.id,
      title: this.cleanTitle(video.snippet.title),
      description: this.extractKeyInfo(video.snippet.description),
      publishedAt: video.snippet.publishedAt,
      channelId: video.snippet.channelId,
      channelTitle: video.snippet.channelTitle,
      thumbnails: this.selectBestThumbnail(video.snippet.thumbnails),
      tags: video.snippet.tags || [],
      categoryId: video.snippet.categoryId,
      defaultLanguage: video.snippet.defaultLanguage ||
                      video.snippet.defaultAudioLanguage || 'ko'
    };
  }

  cleanTitle(title) {
    // 이모지와 특수문자는 유지하되 스팸성 패턴 제거
    return title
      .replace(/\[.*?\]/g, '') // [광고] 등 제거
      .replace(/\(.*?광고.*?\)/g, '') // (광고포함) 등 제거
      .replace(/^\s*\d+\.\s*/, '') // 번호 매기기 제거
      .trim();
  }

  extractKeyInfo(description) {
    if (!description) return '';

    // 설명의 첫 3줄만 추출 (보통 핵심 내용)
    const lines = description.split('\n').slice(0, 3);
    const keyInfo = lines.join(' ').trim();

    // URL 제거
    return keyInfo.replace(/https?:\/\/[^\s]+/g, '').trim();
  }

  selectBestThumbnail(thumbnails) {
    // 우선순위: maxres > standard > high > medium > default
    const priority = ['maxres', 'standard', 'high', 'medium', 'default'];

    for (const size of priority) {
      if (thumbnails[size]) {
        return {
          url: thumbnails[size].url,
          width: thumbnails[size].width,
          height: thumbnails[size].height,
          size
        };
      }
    }

    return null;
  }

  extractStatistics(video) {
    const stats = video.statistics || {};

    return {
      viewCount: parseInt(stats.viewCount || 0),
      likeCount: parseInt(stats.likeCount || 0),
      dislikeCount: parseInt(stats.dislikeCount || 0),
      favoriteCount: parseInt(stats.favoriteCount || 0),
      commentCount: parseInt(stats.commentCount || 0),
      // 계산된 메트릭
      likeRatio: this.calculateLikeRatio(stats),
      engagementRate: this.calculateEngagementRate(stats),
      virality: this.calculateVirality(stats, video.snippet.publishedAt)
    };
  }

  calculateLikeRatio(stats) {
    const likes = parseInt(stats.likeCount || 0);
    const dislikes = parseInt(stats.dislikeCount || 0);
    const total = likes + dislikes;

    return total > 0 ? (likes / total) : null;
  }

  calculateEngagementRate(stats) {
    const views = parseInt(stats.viewCount || 0);
    if (views === 0) return 0;

    const engagements =
      parseInt(stats.likeCount || 0) +
      parseInt(stats.dislikeCount || 0) +
      parseInt(stats.commentCount || 0);

    return (engagements / views) * 100;
  }

  calculateVirality(stats, publishedAt) {
    const views = parseInt(stats.viewCount || 0);
    const daysSincePublish =
      (Date.now() - new Date(publishedAt).getTime()) / (1000 * 60 * 60 * 24);

    if (daysSincePublish === 0) return views;

    // 일일 평균 조회수
    const dailyViews = views / daysSincePublish;

    // 바이럴 점수 (로그 스케일)
    return Math.log10(dailyViews + 1) * 10;
  }

  extractContentMetadata(video) {
    const content = video.contentDetails || {};

    return {
      duration: this.parseDuration(content.duration),
      dimension: content.dimension, // 2d, 3d
      definition: content.definition, // hd, sd
      caption: content.caption === 'true',
      licensedContent: content.licensedContent || false,
      projection: content.projection, // rectangular, 360
      hasCustomThumbnail: content.hasCustomThumbnail,
      regionRestriction: content.regionRestriction || null,
      contentRating: content.contentRating || {}
    };
  }

  parseDuration(isoDuration) {
    if (!isoDuration) return 0;

    const match = isoDuration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
    if (!match) return 0;

    const hours = parseInt(match[1] || 0);
    const minutes = parseInt(match[2] || 0);
    const seconds = parseInt(match[3] || 0);

    return hours * 3600 + minutes * 60 + seconds;
  }

  async extractChannelMetadata(video) {
    // 채널 정보는 별도 API 호출이 필요할 수 있음
    // 여기서는 캐시된 정보 사용
    const channelCache = await this.getChannelInfo(video.snippet.channelId);

    if (channelCache) {
      return {
        subscriberCount: channelCache.subscriberCount,
        videoCount: channelCache.videoCount,
        viewCount: channelCache.viewCount,
        verified: channelCache.verified,
        category: channelCache.category
      };
    }

    return {
      channelId: video.snippet.channelId,
      channelTitle: video.snippet.channelTitle
    };
  }

  calculateEngagement(video) {
    const stats = video.statistics || {};
    const views = parseInt(stats.viewCount || 0);

    if (views === 0) return { score: 0, level: 'none' };

    // 다양한 참여 지표
    const metrics = {
      likeRate: (parseInt(stats.likeCount || 0) / views) * 100,
      commentRate: (parseInt(stats.commentCount || 0) / views) * 100,
      shareability: this.estimateShareability(video),
      retention: this.estimateRetention(video)
    };

    // 가중 평균 점수
    const score =
      metrics.likeRate * 0.4 +
      metrics.commentRate * 0.3 +
      metrics.shareability * 0.2 +
      metrics.retention * 0.1;

    // 참여도 레벨
    let level;
    if (score > 10) level = 'viral';
    else if (score > 5) level = 'high';
    else if (score > 2) level = 'medium';
    else if (score > 0.5) level = 'low';
    else level = 'minimal';

    return { score, level, metrics };
  }

  assessQuality(video) {
    const factors = {
      // 콘텐츠 품질 지표
      hasDescription: video.snippet.description?.length > 50 ? 1 : 0,
      hasTags: video.snippet.tags?.length > 3 ? 1 : 0,
      hasCustomThumbnail: video.contentDetails?.hasCustomThumbnail ? 1 : 0,
      isHD: video.contentDetails?.definition === 'hd' ? 1 : 0,

      // 채널 품질 지표
      channelVerified: video.channel?.verified ? 1 : 0,
      channelMaturity: this.assessChannelMaturity(video.channel),

      // 참여도 품질
      goodLikeRatio: video.statistics?.likeRatio > 0.9 ? 1 : 0,
      highEngagement: video.engagement?.level === 'high' ? 1 : 0
    };

    // 품질 점수 계산 (0-1)
    const score = Object.values(factors).reduce((a, b) => a + b, 0) /
                  Object.keys(factors).length;

    return {
      score,
      factors,
      grade: this.getQualityGrade(score)
    };
  }

  getQualityGrade(score) {
    if (score >= 0.8) return 'A';
    if (score >= 0.6) return 'B';
    if (score >= 0.4) return 'C';
    if (score >= 0.2) return 'D';
    return 'F';
  }

  async performAIAnalysis(metadata) {
    // AI를 통한 추가 분석
    const analysis = {
      categories: [],
      keywords: [],
      emotions: [],
      topics: [],
      appropriateness: 'safe'
    };

    // 제목과 설명에서 카테고리 추론
    const text = `${metadata.basic.title} ${metadata.basic.description}`;
    analysis.categories = this.inferCategories(text);

    // 핵심 키워드 추출
    analysis.keywords = this.extractKeywords(text, metadata.basic.tags);

    // 감정 분석
    analysis.emotions = this.analyzeEmotions(text);

    // 주제 분류
    analysis.topics = this.classifyTopics(text, analysis.categories);

    return analysis;
  }
}

```

### 7.3.2 품질 필터링

```jsx
// quality-filter.js
class QualityFilter {
  constructor() {
    this.weights = {
      technical: 0.2,
      content: 0.3,
      engagement: 0.3,
      channel: 0.2
    };

    this.thresholds = {
      minimum: 0.5,
      recommended: 0.7,
      premium: 0.85
    };
  }

  async evaluateVideoQuality(video, options = {}) {
    const scores = {
      technical: await this.evaluateTechnicalQuality(video),
      content: await this.evaluateContentQuality(video),
      engagement: await this.evaluateEngagementQuality(video),
      channel: await this.evaluateChannelQuality(video)
    };

    // 가중 평균 계산
    const overallScore = Object.entries(scores).reduce((total, [key, score]) => {
      return total + (score * this.weights[key]);
    }, 0);

    // 품질 등급 결정
    const grade = this.determineGrade(overallScore);

    // 필터링 결정
    const passed = overallScore >= (options.threshold || this.thresholds.minimum);

    return {
      passed,
      score: overallScore,
      grade,
      details: scores,
      recommendations: this.getRecommendations(scores)
    };
  }

  async evaluateTechnicalQuality(video) {
    const factors = {
      resolution: 0,
      audioQuality: 0,
      stability: 0,
      format: 0
    };

    // 해상도 평가
    if (video.contentDetails?.definition === 'hd') {
      factors.resolution = 1.0;
    } else {
      factors.resolution = 0.5;
    }

    // Shorts 형식 확인
    const duration = video.metadata?.content?.duration || 0;
    const aspectRatio = this.getAspectRatio(video);

    if (duration <= 60 && aspectRatio === '9:16') {
      factors.format = 1.0;
    } else if (duration <= 60) {
      factors.format = 0.7;
    } else {
      factors.format = 0.3;
    }

    // 안정성 (업로드 이후 문제 없음)
    const daysSinceUpload =
      (Date.now() - new Date(video.snippet.publishedAt).getTime()) /
      (1000 * 60 * 60 * 24);

    if (daysSinceUpload > 7 && video.statistics.viewCount > 1000) {
      factors.stability = 1.0;
    } else {
      factors.stability = 0.7;
    }

    // 오디오는 별도 분석 필요 (여기서는 추정)
    factors.audioQuality = video.contentDetails?.caption ? 0.9 : 0.7;

    return Object.values(factors).reduce((a, b) => a + b, 0) /
           Object.keys(factors).length;
  }

  async evaluateContentQuality(video) {
    const factors = {
      titleQuality: 0,
      descriptionQuality: 0,
      tagsQuality: 0,
      thumbnailQuality: 0,
      originalityScore: 0
    };

    // 제목 품질
    factors.titleQuality = this.evaluateTitle(video.snippet.title);

    // 설명 품질
    factors.descriptionQuality = this.evaluateDescription(video.snippet.description);

    // 태그 품질
    factors.tagsQuality = video.snippet.tags && video.snippet.tags.length > 5 ?
                         Math.min(video.snippet.tags.length / 10, 1) : 0.3;

    // 썸네일 품질
    factors.thumbnailQuality = video.contentDetails?.hasCustomThumbnail ? 1.0 : 0.5;

    // 독창성 점수 (중복 콘텐츠 체크)
    factors.originalityScore = await this.checkOriginality(video);

    return Object.values(factors).reduce((a, b) => a + b, 0) /
           Object.keys(factors).length;
  }

  evaluateTitle(title) {
    let score = 0.5; // 기본 점수

    // 긍정 요소
    if (title.length >= 10 && title.length <= 60) score += 0.2;
    if (/[가-힣]/.test(title)) score += 0.1; // 한글 포함
    if (/[A-Z]/.test(title)) score += 0.1; // 대문자 사용

    // 부정 요소
    if (/클릭|구독|좋아요/.test(title)) score -= 0.2; // 클릭베이트
    if (/!!!|￥￥￥/.test(title)) score -= 0.1; // 과도한 강조
    if (title === title.toUpperCase()) score -= 0.2; // 전체 대문자

    return Math.max(0, Math.min(1, score));
  }

  evaluateDescription(description) {
    if (!description) return 0.2;

    let score = 0.5;

    // 긍정 요소
    if (description.length >= 50) score += 0.2;
    if (description.length >= 200) score += 0.1;
    if (description.includes('\n')) score += 0.1; // 구조화됨

    // 부정 요소
    const linkCount = (description.match(/https?:\/\//g) || []).length;
    if (linkCount > 5) score -= 0.2; // 과도한 링크

    return Math.max(0, Math.min(1, score));
  }

  async evaluateEngagementQuality(video) {
    const stats = video.statistics || {};
    const views = parseInt(stats.viewCount || 0);

    if (views === 0) return 0;

    const factors = {
      likeRatio: 0,
      engagementRate: 0,
      viralPotential: 0,
      communityInteraction: 0
    };

    // 좋아요 비율
    const likes = parseInt(stats.likeCount || 0);
    const dislikes = parseInt(stats.dislikeCount || 0);
    if (likes + dislikes > 0) {
      factors.likeRatio = likes / (likes + dislikes);
    }

    // 참여율
    const engagements = likes + dislikes + parseInt(stats.commentCount || 0);
    factors.engagementRate = Math.min((engagements / views) * 100, 1);

    // 바이럴 잠재력
    const ageInDays =
      (Date.now() - new Date(video.snippet.publishedAt).getTime()) /
      (1000 * 60 * 60 * 24);

    if (ageInDays < 7 && views > 100000) {
      factors.viralPotential = 1.0;
    } else if (ageInDays < 30 && views > 50000) {
      factors.viralPotential = 0.7;
    } else {
      factors.viralPotential = Math.min(views / 100000, 0.5);
    }

    // 커뮤니티 상호작용
    const commentRate = parseInt(stats.commentCount || 0) / views;
    factors.communityInteraction = Math.min(commentRate * 1000, 1);

    return Object.values(factors).reduce((a, b) => a + b, 0) /
           Object.keys(factors).length;
  }

  async evaluateChannelQuality(video) {
    // 채널 정보 조회 (캐시 활용)
    const channelInfo = await this.getChannelInfo(video.snippet.channelId);

    if (!channelInfo) return 0.5; // 정보 없으면 중간 점수

    const factors = {
      subscriberCount: 0,
      consistency: 0,
      authority: 0,
      trustworthiness: 0
    };

    // 구독자 수 (로그 스케일)
    const subs = channelInfo.subscriberCount || 0;
    factors.subscriberCount = Math.min(Math.log10(subs + 1) / 7, 1); // 10M = 1.0

    // 업로드 일관성
    const uploadsPerMonth = channelInfo.videoCount /
      (channelInfo.channelAge || 1);
    factors.consistency = Math.min(uploadsPerMonth / 30, 1);

    // 권위성 (인증 여부)
    factors.authority = channelInfo.verified ? 1.0 : 0.5;

    // 신뢰도 (신고/차단 이력)
    factors.trustworthiness = channelInfo.trustScore || 0.8;

    return Object.values(factors).reduce((a, b) => a + b, 0) /
           Object.keys(factors).length;
  }

  determineGrade(score) {
    if (score >= this.thresholds.premium) return 'S';
    if (score >= this.thresholds.recommended) return 'A';
    if (score >= 0.6) return 'B';
    if (score >= this.thresholds.minimum) return 'C';
    return 'D';
  }

  getRecommendations(scores) {
    const recommendations = [];

    // 각 영역별 개선 제안
    if (scores.technical < 0.7) {
      recommendations.push({
        area: 'technical',
        message: '영상 품질을 개선하면 더 좋은 평가를 받을 수 있습니다.',
        priority: 'medium'
      });
    }

    if (scores.content < 0.7) {
      recommendations.push({
        area: 'content',
        message: '제목, 설명, 태그를 최적화하여 발견성을 높이세요.',
        priority: 'high'
      });
    }

    if (scores.engagement < 0.5) {
      recommendations.push({
        area: 'engagement',
        message: '시청자 참여를 유도하는 콘텐츠를 제작해보세요.',
        priority: 'high'
      });
    }

    return recommendations;
  }

  // 대량 필터링 최적화
  async batchFilter(videos, options = {}) {
    const batchSize = 50;
    const results = [];

    // 배치 처리
    for (let i = 0; i < videos.length; i += batchSize) {
      const batch = videos.slice(i, i + batchSize);

      const batchResults = await Promise.all(
        batch.map(video => this.evaluateVideoQuality(video, options))
      );

      results.push(...batchResults);
    }

    // 통과한 영상만 반환
    const filtered = videos.filter((video, index) =>
      results[index].passed
    );

    // 점수 순으로 정렬
    filtered.sort((a, b) => {
      const scoreA = results[videos.indexOf(a)].score;
      const scoreB = results[videos.indexOf(b)].score;
      return scoreB - scoreA;
    });

    return {
      videos: filtered,
      stats: {
        total: videos.length,
        passed: filtered.length,
        avgScore: results.reduce((sum, r) => sum + r.score, 0) / results.length,
        gradeDistribution: this.getGradeDistribution(results)
      }
    };
  }
}

```

### 7.3.3 Shorts 판별 로직

```jsx
// shorts-detector.js
class ShortsDetector {
  constructor() {
    this.criteria = {
      duration: { max: 60, weight: 0.3 },
      aspectRatio: { expected: 9/16, tolerance: 0.1, weight: 0.2 },
      title: { patterns: ['#shorts', '#short', '쇼츠'], weight: 0.2 },
      format: { vertical: true, weight: 0.2 },
      platform: { shortsShelf: true, weight: 0.1 }
    };
  }

  async detectShorts(video) {
    const checks = {
      duration: this.checkDuration(video),
      aspectRatio: await this.checkAspectRatio(video),
      title: this.checkTitle(video),
      format: await this.checkFormat(video),
      platform: this.checkPlatformSignals(video),
      url: this.checkURL(video)
    };

    // 가중 점수 계산
    const score = Object.entries(checks).reduce((total, [key, result]) => {
      const weight = this.criteria[key]?.weight || 0.1;
      return total + (result.isShorts ? weight : 0);
    }, 0);

    // 상세 분석
    const analysis = {
      isShorts: score >= 0.6,
      confidence: score,
      checks,
      shortsType: this.determineShortsType(checks, video)
    };

    return analysis;
  }

  checkDuration(video) {
    const duration = video.contentDetails?.duration;
    if (!duration) return { isShorts: false, reason: 'no_duration' };

    const seconds = this.parseDuration(duration);
    const isShorts = seconds > 0 && seconds <= this.criteria.duration.max;

    return {
      isShorts,
      value: seconds,
      reason: isShorts ? 'valid_duration' : 'too_long'
    };
  }

  async checkAspectRatio(video) {
    const thumbnail = video.snippet?.thumbnails?.high ||
                     video.snippet?.thumbnails?.medium;

    if (!thumbnail) return { isShorts: false, reason: 'no_thumbnail' };

    // 썸네일 비율로 추정
    const ratio = thumbnail.width / thumbnail.height;
    const expectedRatio = this.criteria.aspectRatio.expected;
    const tolerance = this.criteria.aspectRatio.tolerance;

    const isVertical = Math.abs(ratio - expectedRatio) <= tolerance;

    return {
      isShorts: isVertical,
      value: ratio,
      reason: isVertical ? 'vertical_format' : 'horizontal_format'
    };
  }

  checkTitle(video) {
    const title = video.snippet?.title?.toLowerCase() || '';
    const patterns = this.criteria.title.patterns;

    const hasPattern = patterns.some(pattern =>
      title.includes(pattern.toLowerCase())
    );

    return {
      isShorts: hasPattern,
      matchedPattern: patterns.find(p => title.includes(p.toLowerCase())),
      reason: hasPattern ? 'title_indicator' : 'no_title_indicator'
    };
  }

  async checkFormat(video) {
    // 추가 형식 검증 (필요시 API 호출)
    const metadata = video.contentDetails || {};

    // YouTube는 Shorts를 특별한 방식으로 인코딩
    const indicators = {
      hasEndScreen: metadata.hasEndScreen === false,
      projection: metadata.projection === 'rectangular',
      dimension: metadata.dimension === '2d'
    };

    const isLikelyShorts = Object.values(indicators).filter(Boolean).length >= 2;

    return {
      isShorts: isLikelyShorts,
      indicators,
      reason: 'format_analysis'
    };
  }

  checkPlatformSignals(video) {
    // YouTube 플랫폼 특정 신호
    const signals = {
      // Shorts 선반에 표시되는지 (메타데이터에서 확인 가능한 경우)
      inShortsShelf: video.shortsMetadata?.inShelf || false,

      // 특별한 재생 수 패턴 (Shorts는 일반적으로 빠르게 조회수 증가)
      rapidGrowth: this.checkRapidGrowth(video),

      // 모바일 최적화 신호
      mobileOptimized: true // 대부분의 Shorts는 모바일 최적화
    };

    const signalCount = Object.values(signals).filter(Boolean).length;

    return {
      isShorts: signalCount >= 2,
      signals,
      reason: 'platform_signals'
    };
  }

  checkURL(video) {
    // URL 패턴 확인
    const videoId = video.id || video.snippet?.videoId;
    const possibleURLs = [
      `https://youtube.com/shorts/${videoId}`,
      `https://www.youtube.com/shorts/${videoId}`,
      `https://youtu.be/${videoId}`
    ];

    // 실제로는 리다이렉션 확인이 필요하지만, 여기서는 패턴만 확인
    const shortsURLPattern = /youtube\.com\/shorts\//;

    return {
      isShorts: true, // URL 생성 가능
      possibleURLs,
      reason: 'url_compatible'
    };
  }

  checkRapidGrowth(video) {
    const views = parseInt(video.statistics?.viewCount || 0);
    const publishedAt = new Date(video.snippet?.publishedAt);
    const ageInHours = (Date.now() - publishedAt) / (1000 * 60 * 60);

    if (ageInHours < 24 && views > 10000) return true;
    if (ageInHours < 168 && views > 100000) return true; // 1주일

    return false;
  }

  determineShortsType(checks, video) {
    // Shorts 유형 분류
    if (!checks.duration.isShorts) return 'not_shorts';

    if (checks.title.isShorts && checks.aspectRatio.isShorts) {
      return 'official_shorts'; // 공식 Shorts
    }

    if (checks.duration.value <= 60 && checks.aspectRatio.isShorts) {
      return 'vertical_short_video'; // 세로 짧은 영상
    }

    if (checks.duration.value <= 60) {
      return 'short_video'; // 짧은 영상 (가로일 수 있음)
    }

    return 'uncertain';
  }

  // 배치 검증
  async batchDetect(videos) {
    const results = await Promise.all(
      videos.map(video => this.detectShorts(video))
    );

    const stats = {
      total: videos.length,
      confirmed: results.filter(r => r.isShorts && r.confidence > 0.8).length,
      likely: results.filter(r => r.isShorts && r.confidence > 0.6).length,
      notShorts: results.filter(r => !r.isShorts).length,

      byType: {}
    };

    // 유형별 통계
    results.forEach(result => {
      const type = result.shortsType;
      stats.byType[type] = (stats.byType[type] || 0) + 1;
    });

    return {
      videos: videos.map((video, index) => ({
        ...video,
        shortsAnalysis: results[index]
      })),
      stats
    };
  }

  parseDuration(isoDuration) {
    const match = isoDuration.match(/PT(?:(\d+)M)?(?:(\d+)S)?/);
    if (!match) return 0;

    const minutes = parseInt(match[1] || 0);
    const seconds = parseInt(match[2] || 0);

    return minutes * 60 + seconds;
  }

  // Shorts URL 생성
  generateShortsURL(videoId) {
    return `https://youtube.com/shorts/${videoId}`;
  }

  // 일반 URL을 Shorts URL로 변환
  convertToShortsURL(url) {
    const patterns = [
      /youtube\.com\/watch\?v=([a-zA-Z0-9_-]+)/,
      /youtu\.be\/([a-zA-Z0-9_-]+)/,
      /youtube\.com\/embed\/([a-zA-Z0-9_-]+)/
    ];

    for (const pattern of patterns) {
      const match = url.match(pattern);
      if (match) {
        return this.generateShortsURL(match[1]);
      }
    }

    return url; // 변환 불가능하면 원본 반환
  }
}

```