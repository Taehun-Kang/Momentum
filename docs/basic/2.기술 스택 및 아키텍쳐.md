# 기술 스택 및 아키텍처 (Technical Stack & Architecture)

## 2.1 전체 시스템 아키텍처

### 2.1.1 시스템 구성도

```
┌─────────────────────────────────────────────────────────────────────────┐
│                            Client Layer                                  │
├─────────────────────────┬────────────────────┬─────────────────────────┤
│   Web App (SPA)         │   Mobile Web       │   Native App            │
│   - Vanilla JS          │   - PWA            │   - Capacitor           │
│   - Component 기반      │   - Responsive     │   - iOS/Android         │
└───────────┬─────────────┴────────────────────┴───────────┬─────────────┘
            │                                               │
            │              HTTPS / WebSocket                │
            ▼                                               ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                          API Gateway Layer                               │
│                        (Railway - Node.js)                               │
├─────────────┬──────────────┬──────────────┬──────────────┬────────────┤
│   Auth API  │  Search API  │  Trend API   │   MCP API    │  Admin API │
└─────────────┴──────────────┴──────────────┴──────────────┴────────────┘
            │                                               │
            ▼                                               ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                         Service Layer                                    │
├─────────────┬──────────────┬──────────────┬──────────────┬────────────┤
│   MCP       │   YouTube    │   Trending   │   Caching    │  Analytics │
│   Server    │   Service    │   Service    │   Service    │  Service   │
│             │              │ (Bright Data)│   (Redis)    │            │
└─────────────┴──────────────┴──────────────┴──────────────┴────────────┘
            │                                               │
            ▼                                               ▼
┌─────────────────────────────────────────────────────────────────────────┐
│                         Data Layer                                       │
├─────────────────────┬────────────────────┬─────────────────────────────┤
│    Supabase         │    Redis Cache     │    External APIs            │
│  - PostgreSQL       │  - Session         │  - YouTube Data API         │
│  - Auth             │  - API Cache       │  - Claude API               │
│  - Realtime         │  - Trending        │  - Google Trends            │
└─────────────────────┴────────────────────┴─────────────────────────────┘

```

### 2.1.2 데이터 플로우

### 1. 일반 검색 플로우 (캐시 히트)

```
User Request → API Gateway → Cache Check → Redis Hit (85%)
                                              ↓
                                         Return Cached Data

총 응답 시간: <100ms

```

### 2. AI 대화형 검색 플로우 (프리미엄)

```
User Input → API Gateway → MCP Server → Claude API
    ↓                          ↓              ↓
"오늘 비와서        Context Analysis    키워드 추출
우울해"                  ↓              ["비오는날",
                   Mood: 우울           "감성음악",
                   Weather: 비          "힐링영상"]
                   Intent: 위로              ↓
                                      YouTube Service
                                            ↓
                                      Video Curation
                                            ↓
                                      Personalization
                                            ↓
                                      Return Results

총 응답 시간: <2초 (목표: <1초)

```

### 3. 트렌드 업데이트 플로우

```
Cron Job (4시간마다) → Trending Service
                              ↓
                    ┌─────────┴─────────┐
                    ▼                   ▼
             Bright Data MCP     Internal Analytics
                    ↓                   ↓
           Web Search Trends    User Search Patterns
                    ↓                   ↓
                    └─────────┬─────────┘
                              ▼
                        Merge & Rank
                              ↓
                     Update Redis Cache
                              ↓
                    Pre-fetch YouTube Videos
                              ↓
                     Store in Supabase

```

### 2.1.3 통신 프로토콜

### RESTful API

```yaml
기본 엔드포인트:
  - Base URL: https://api.youtubeshortsai.com/v1
  - Content-Type: application/json
  - Authentication: Bearer {JWT_TOKEN}

주요 엔드포인트:
  - POST /auth/login
  - POST /auth/register
  - GET /search/keywords/{keyword}
  - POST /search/chat (프리미엄)
  - GET /trending/now
  - GET /trending/category/{category}
  - POST /videos/interaction

```

### WebSocket (실시간 기능)

```yaml
용도:
  - AI 채팅 실시간 응답
  - 트렌드 실시간 업데이트
  - 사용자 활동 스트리밍

연결:
  - URL: wss://api.youtubeshortsai.com/ws
  - Protocol: Socket.io
  - Heartbeat: 30초

메시지 포맷:
  {
    "event": "chat.message",
    "data": {
      "conversationId": "uuid",
      "message": "content",
      "timestamp": "2025-06-03T10:00:00Z"
    }
  }

```

## 2.2 프론트엔드 기술 스택

### 2.2.1 Vanilla JavaScript SPA 구조

### 선택 이유

```yaml
장점:
  - 프레임워크 오버헤드 없음
  - 빠른 초기 로딩 (< 1초)
  - 완전한 컨트롤
  - 작은 번들 사이즈 (<100KB)

트레이드오프:
  - 수동 상태 관리 필요
  - 라우팅 직접 구현
  - 컴포넌트 시스템 구축

```

### 프로젝트 구조

```
frontend/
├── index.html              # 메인 HTML (SPA 진입점)
├── manifest.json           # PWA 매니페스트
├── sw.js                   # Service Worker
├── css/
│   ├── main.css           # 글로벌 스타일
│   ├── components.css     # 컴포넌트 스타일
│   ├── utilities.css      # 유틸리티 클래스
│   └── responsive.css     # 반응형 스타일
├── js/
│   ├── app.js             # 메인 앱 초기화
│   ├── router.js          # SPA 라우터
│   ├── state.js           # 전역 상태 관리
│   ├── api/
│   │   ├── client.js      # API 클라이언트
│   │   ├── auth.js        # 인증 API
│   │   ├── search.js      # 검색 API
│   │   └── trending.js    # 트렌드 API
│   ├── components/
│   │   ├── BaseComponent.js    # 컴포넌트 베이스
│   │   ├── VideoCard.js        # 영상 카드
│   │   ├── ChatInterface.js    # AI 채팅
│   │   ├── TrendingSection.js  # 트렌드 섹션
│   │   └── InfiniteScroll.js   # 무한 스크롤
│   ├── services/
│   │   ├── mcp.js         # MCP 통신
│   │   ├── cache.js       # 로컬 캐싱
│   │   └── analytics.js   # 분석 추적
│   └── utils/
│       ├── dom.js         # DOM 유틸
│       ├── debounce.js    # 성능 유틸
│       └── format.js      # 포맷팅 유틸
└── assets/
    ├── icons/             # 아이콘 세트
    ├── images/            # 정적 이미지
    └── fonts/             # 웹폰트

```

### 핵심 모듈 구현

**1. SPA 라우터**

```jsx
// router.js
class Router {
  constructor() {
    this.routes = new Map();
    this.currentRoute = null;
    this.init();
  }

  init() {
    window.addEventListener('popstate', () => this.handleRoute());
    document.addEventListener('click', (e) => {
      if (e.target.matches('[data-link]')) {
        e.preventDefault();
        this.navigate(e.target.href);
      }
    });
  }

  register(path, component) {
    this.routes.set(path, component);
  }

  navigate(url) {
    history.pushState(null, null, url);
    this.handleRoute();
  }

  async handleRoute() {
    const path = window.location.pathname;
    const route = this.routes.get(path) || this.routes.get('/404');

    if (this.currentRoute?.unmount) {
      this.currentRoute.unmount();
    }

    this.currentRoute = new route();
    const html = await this.currentRoute.render();
    document.querySelector('#app').innerHTML = html;

    if (this.currentRoute.afterRender) {
      this.currentRoute.afterRender();
    }
  }
}

```

**2. 상태 관리**

```jsx
// state.js
class StateManager {
  constructor() {
    this.state = {};
    this.subscribers = new Map();
  }

  subscribe(key, callback) {
    if (!this.subscribers.has(key)) {
      this.subscribers.set(key, new Set());
    }
    this.subscribers.get(key).add(callback);

    return () => {
      this.subscribers.get(key).delete(callback);
    };
  }

  setState(key, value) {
    const oldValue = this.state[key];
    this.state[key] = value;

    if (this.subscribers.has(key)) {
      this.subscribers.get(key).forEach(callback => {
        callback(value, oldValue);
      });
    }
  }

  getState(key) {
    return this.state[key];
  }
}

export const store = new StateManager();

```

### 2.2.2 컴포넌트 설계

### 컴포넌트 베이스 클래스

```jsx
// core/core.js
export class Component {
  constructor(payload = {}) {
    const {
      tagName = 'div',
      props = {},
      state = {}
    } = payload;
    
    this.el = document.createElement(tagName);
    this.props = props;
    this.state = state;
    this.render();
  }
  
  render() {
    // 하위 클래스에서 구현
  }
}

// Router 시스템
export function createRouter(routes) {
  return function () {
    window.addEventListener('popstate', () => {
      routeRender(routes);
    });
    routeRender(routes);
  }
}

// Store 패턴
export class Store {
  constructor(state) {
    this.state = {};
    this.observers = {};
    
    for (const key in state) {
      Object.defineProperty(this.state, key, {
        get: () => state[key],
        set: (val) => {
          state[key] = val;
          if (Array.isArray(this.observers[key])) {
            this.observers[key].forEach(observer => observer(val));
          }
        }
      });
    }
  }
  
  subscribe(key, cb) {
    Array.isArray(this.observers[key])
      ? this.observers[key].push(cb)
      : this.observers[key] = [cb];
  }
}

```

### 핵심 컴포넌트 예시

**1. 비디오 카드 컴포넌트**

```jsx
// components/VideoCard.js
import { Component } from '../core/core';

export default class VideoCard extends Component {
  constructor(props) {
    super({
      props,
      tagName: 'article'
    });
  }
  
  render() {
    const { video } = this.props;
    
    this.el.className = 'video-card';
    this.el.innerHTML = /* html */ `
      <div class="card">
        <img class="thumbnail"
             src="${video.thumbnail}"
             alt="${video.title}"
             loading="lazy">
        <div class="info">
          <h3 class="title">${video.title}</h3>
          <p class="channel">${video.channel}</p>
          <p class="views">${this.formatViews(video.viewCount)} views</p>
        </div>
      </div>
    `;
    
    // 이벤트 리스너 추가
    this.el.addEventListener('click', () => {
      window.location.hash = `#/video?id=${video.id}`;
    });
  }
  
  formatViews(views) {
    if (views > 1000000) return `${(views / 1000000).toFixed(1)}M`;
    if (views > 1000) return `${(views / 1000).toFixed(1)}K`;
    return views.toString();
  }
}

/* CSS는 별도 파일로 관리 */
// css/components/video-card.css
/*
.video-card {
  width: 100%;
  cursor: pointer;
  transition: transform 0.2s;
}

.video-card:hover {
  transform: translateY(-4px);
}

.video-card .card {
  border-radius: 12px;
  overflow: hidden;
  background: var(--card-bg);
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.video-card .thumbnail {
  width: 100%;
  aspect-ratio: 9/16;
  object-fit: cover;
}

.video-card .info {
  padding: 12px;
}

.video-card .title {
  font-size: 14px;
  font-weight: 600;
  line-height: 1.4;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
}

.video-card .channel {
  font-size: 13px;
  color: var(--text-secondary);
  margin-top: 4px;
}

.video-card .views {
  font-size: 12px;
  color: var(--text-secondary);
  margin-top: 2px;
}
*/

```

**2. AI 채팅 인터페이스**

```jsx
// components/ChatInterface.js
import { Component } from '../core/core';
import { youtubeStore } from '../store/youtube';

export default class ChatInterface extends Component {
  constructor() {
    super({
      tagName: 'div',
      state: {
        messages: [],
        suggestions: [],
        isTyping: false
      }
    });
    this.conversationId = null;
  }

  render() {
    this.el.className = 'chat-interface';
    this.el.innerHTML = /* html */ `
      <div class="messages" id="messages">
        ${this.state.messages.map(msg => `
          <div class="message ${msg.sender}-message">
            ${msg.text}
          </div>
        `).join('')}
        ${this.state.isTyping ? `
          <div class="typing-indicator">
            <span class="dot"></span>
            <span class="dot"></span>
            <span class="dot"></span>
          </div>
        ` : ''}
      </div>
      <div class="suggestions" id="suggestions">
        ${this.state.suggestions.map(suggestion => `
          <button class="suggestion-btn" data-suggestion="${suggestion}">
            ${suggestion}
          </button>
        `).join('')}
      </div>
      <div class="input-area">
        <input type="text"
               class="input"
               id="message-input"
               placeholder="어떤 영상을 찾고 있나요?">
        <button class="send-btn" id="send-btn">
          <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
            <path d="M2 21l21-9L2 3v7l15 2-15 2v7z"/>
          </svg>
        </button>
      </div>
    `;
    
    this.attachEventListeners();
  }
  
  attachEventListeners() {
    const input = this.el.querySelector('#message-input');
    const sendBtn = this.el.querySelector('#send-btn');
    
    sendBtn.addEventListener('click', () => {
      const message = input.value.trim();
      if (message) {
        this.sendMessage(message);
        input.value = '';
      }
    });
    
    input.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        sendBtn.click();
      }
    });
    
    // 추천 버튼 이벤트
    this.el.addEventListener('click', (e) => {
      if (e.target.classList.contains('suggestion-btn')) {
        const suggestion = e.target.dataset.suggestion;
        this.sendMessage(suggestion);
      }
    });
  }

  async sendMessage(message) {
    // 상태에 메시지 추가
    this.state.messages.push({
      text: message,
      sender: 'user',
      timestamp: Date.now()
    });
    
    // 타이핑 표시
    this.state.isTyping = true;
    this.render();

    try {
      // MCP 서버로 메시지 전송
      const response = await fetch('/api/search/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${localStorage.getItem('token')}`
        },
        body: JSON.stringify({
          message,
          conversationId: this.conversationId
        })
      });

      const data = await response.json();
      
      // AI 응답 추가
      this.state.messages.push({
        text: data.response,
        sender: 'ai',
        timestamp: Date.now()
      });
      
      // 추천 버튼 업데이트
      if (data.suggestions) {
        this.state.suggestions = data.suggestions;
      }
      
      // 추출된 키워드로 영상 검색
      if (data.keywords) {
        youtubeStore.state.searchQuery = data.keywords.join(' ');
      }
    } catch (error) {
      console.error('메시지 전송 실패:', error);
    } finally {
      this.state.isTyping = false;
      this.render();
    }
  }
  
  showTypingIndicator() {
    this.state.isTyping = true;
    this.render();
  }
  
  hideTypingIndicator() {
    this.state.isTyping = false;
    this.render();
  }
}

```

### 2.2.3 CSS 아키텍처

### CSS 변수 시스템

```css
/* css/main.css */
:root {
  /* Colors */
  --primary-color: #FF0000;
  --primary-hover: #E60000;
  --secondary-color: #065FD4;

  /* Background */
  --bg-primary: #FFFFFF;
  --bg-secondary: #F9F9F9;
  --bg-tertiary: #F1F1F1;

  /* Text */
  --text-primary: #0F0F0F;
  --text-secondary: #606060;
  --text-tertiary: #909090;

  /* Borders */
  --border-color: #E5E5E5;
  --border-radius: 12px;

  /* Shadows */
  --shadow-sm: 0 1px 2px rgba(0,0,0,0.05);
  --shadow-md: 0 4px 6px rgba(0,0,0,0.07);
  --shadow-lg: 0 10px 15px rgba(0,0,0,0.1);

  /* Spacing */
  --spacing-xs: 4px;
  --spacing-sm: 8px;
  --spacing-md: 16px;
  --spacing-lg: 24px;
  --spacing-xl: 32px;

  /* Typography */
  --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
  --font-size-xs: 12px;
  --font-size-sm: 14px;
  --font-size-md: 16px;
  --font-size-lg: 18px;
  --font-size-xl: 24px;

  /* Transitions */
  --transition-fast: 150ms ease;
  --transition-base: 250ms ease;
  --transition-slow: 350ms ease;
}

/* Dark mode */
[data-theme="dark"] {
  --bg-primary: #0F0F0F;
  --bg-secondary: #1A1A1A;
  --bg-tertiary: #242424;
  --text-primary: #FFFFFF;
  --text-secondary: #AAAAAA;
  --text-tertiary: #717171;
  --border-color: #303030;
}

```

### 유틸리티 클래스

```css
/* css/utilities.css */
/* Layout */
.container {
  width: 100%;
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 var(--spacing-md);
}

.grid {
  display: grid;
  gap: var(--spacing-md);
}

.grid-cols-2 { grid-template-columns: repeat(2, 1fr); }
.grid-cols-3 { grid-template-columns: repeat(3, 1fr); }
.grid-cols-4 { grid-template-columns: repeat(4, 1fr); }

/* Flexbox */
.flex { display: flex; }
.flex-col { flex-direction: column; }
.items-center { align-items: center; }
.justify-center { justify-content: center; }
.justify-between { justify-content: space-between; }
.gap-sm { gap: var(--spacing-sm); }
.gap-md { gap: var(--spacing-md); }
.gap-lg { gap: var(--spacing-lg); }

/* Spacing */
.m-0 { margin: 0; }
.mt-sm { margin-top: var(--spacing-sm); }
.mt-md { margin-top: var(--spacing-md); }
.mb-md { margin-bottom: var(--spacing-md); }
.p-sm { padding: var(--spacing-sm); }
.p-md { padding: var(--spacing-md); }
.p-lg { padding: var(--spacing-lg); }

/* Typography */
.text-xs { font-size: var(--font-size-xs); }
.text-sm { font-size: var(--font-size-sm); }
.text-md { font-size: var(--font-size-md); }
.text-lg { font-size: var(--font-size-lg); }
.text-xl { font-size: var(--font-size-xl); }
.font-bold { font-weight: 700; }
.text-center { text-align: center; }
.text-secondary { color: var(--text-secondary); }

/* Visual */
.rounded { border-radius: var(--border-radius); }
.shadow-sm { box-shadow: var(--shadow-sm); }
.shadow-md { box-shadow: var(--shadow-md); }

/* States */
.hover\:scale-105:hover { transform: scale(1.05); }
.transition { transition: all var(--transition-base); }

/* Responsive */
@media (max-width: 768px) {
  .md\:hidden { display: none; }
  .grid-cols-2 { grid-template-columns: 1fr; }
}

```

### 2.2.4 PWA 구현 전략

### Service Worker

```jsx
// sw.js
const CACHE_NAME = 'youtube-shorts-v1';
const STATIC_ASSETS = [
  '/',
  '/css/main.css',
  '/css/components.css',
  '/js/app.js',
  '/js/router.js',
  '/assets/icons/icon-192.png',
  '/assets/icons/icon-512.png'
];

// 설치 이벤트
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(STATIC_ASSETS))
      .then(() => self.skipWaiting())
  );
});

// 활성화 이벤트
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys()
      .then(cacheNames => {
        return Promise.all(
          cacheNames
            .filter(name => name !== CACHE_NAME)
            .map(name => caches.delete(name))
        );
      })
      .then(() => self.clients.claim())
  );
});

// Fetch 이벤트 - 네트워크 우선, 캐시 폴백
self.addEventListener('fetch', (event) => {
  // API 요청은 항상 네트워크로
  if (event.request.url.includes('/api/')) {
    return event.respondWith(fetch(event.request));
  }

  event.respondWith(
    fetch(event.request)
      .then(response => {
        // 성공적인 응답은 캐시에 저장
        if (response.status === 200) {
          const responseClone = response.clone();
          caches.open(CACHE_NAME)
            .then(cache => cache.put(event.request, responseClone));
        }
        return response;
      })
      .catch(() => {
        // 네트워크 실패시 캐시에서 제공
        return caches.match(event.request);
      })
  );
});

// 백그라운드 동기화
self.addEventListener('sync', (event) => {
  if (event.tag === 'sync-trends') {
    event.waitUntil(syncTrends());
  }
});

async function syncTrends() {
  const response = await fetch('/api/trending/now');
  const trends = await response.json();

  // 트렌드 데이터 캐시
  const cache = await caches.open(CACHE_NAME);
  await cache.put('/api/trending/now', new Response(JSON.stringify(trends)));

  // 클라이언트에 알림
  self.clients.matchAll().then(clients => {
    clients.forEach(client => {
      client.postMessage({
        type: 'TRENDS_UPDATED',
        data: trends
      });
    });
  });
}

```

### PWA Manifest

```json
{
  "name": "YouTube Shorts AI 큐레이터",
  "short_name": "Shorts AI",
  "description": "AI가 추천하는 맞춤형 YouTube Shorts",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#FFFFFF",
  "theme_color": "#FF0000",
  "orientation": "portrait",
  "icons": [
    {
      "src": "/assets/icons/icon-72.png",
      "sizes": "72x72",
      "type": "image/png"
    },
    {
      "src": "/assets/icons/icon-96.png",
      "sizes": "96x96",
      "type": "image/png"
    },
    {
      "src": "/assets/icons/icon-128.png",
      "sizes": "128x128",
      "type": "image/png"
    },
    {
      "src": "/assets/icons/icon-144.png",
      "sizes": "144x144",
      "type": "image/png"
    },
    {
      "src": "/assets/icons/icon-152.png",
      "sizes": "152x152",
      "type": "image/png"
    },
    {
      "src": "/assets/icons/icon-192.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any maskable"
    },
    {
      "src": "/assets/icons/icon-384.png",
      "sizes": "384x384",
      "type": "image/png"
    },
    {
      "src": "/assets/icons/icon-512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ],
  "screenshots": [
    {
      "src": "/assets/screenshots/home.png",
      "sizes": "1080x1920",
      "type": "image/png"
    },
    {
      "src": "/assets/screenshots/chat.png",
      "sizes": "1080x1920",
      "type": "image/png"
    }
  ],
  "categories": ["entertainment", "video"],
  "lang": "ko-KR"
}

```

## 2.3 백엔드 기술 스택

### 2.3.1 Node.js + Express 구조

### 선택 이유

```yaml
Node.js 선택:
  - JavaScript 전체 스택 통일
  - 비동기 I/O로 높은 동시성 처리
  - npm 생태계 활용
  - MCP 서버 구현 용이

Express 선택:
  - 가벼운 프레임워크
  - 미들웨어 생태계
  - 빠른 개발 속도
  - 유연한 라우팅

```

### 프로젝트 구조

```
backend/
├── src/
│   ├── app.js                 # Express 앱 초기화
│   ├── server.js              # 서버 시작점
│   ├── config/
│   │   ├── database.js        # Supabase 연결
│   │   ├── redis.js           # Redis 연결
│   │   ├── environment.js     # 환경변수 관리
│   │   └── constants.js       # 상수 정의
│   ├── middleware/
│   │   ├── auth.js            # JWT 인증
│   │   ├── rateLimit.js       # API 제한
│   │   ├── cache.js           # 캐시 미들웨어
│   │   ├── validation.js      # 입력 검증
│   │   ├── error.js           # 에러 핸들링
│   │   └── logger.js          # 로깅
│   ├── routes/
│   │   ├── auth.routes.js     # 인증 라우트
│   │   ├── search.routes.js   # 검색 라우트
│   │   ├── trending.routes.js # 트렌드 라우트
│   │   ├── video.routes.js    # 영상 라우트
│   │   └── user.routes.js     # 사용자 라우트
│   ├── controllers/
│   │   ├── authController.js
│   │   ├── searchController.js
│   │   ├── trendingController.js
│   │   └── videoController.js
│   ├── services/
│   │   ├── mcp/
│   │   │   ├── server.js      # MCP 서버 ⭐
│   │   │   ├── tools.js       # MCP 도구 정의
│   │   │   └── handlers.js    # MCP 핸들러
│   │   ├── youtube/
│   │   │   ├── client.js      # YouTube API 클라이언트
│   │   │   ├── search.js      # 검색 로직
│   │   │   └── quota.js       # 할당량 관리
│   │   ├── trending/
│   │   │   ├── brightdata.js  # Bright Data MCP
│   │   │   ├── analyzer.js    # 트렌드 분석
│   │   │   └── scheduler.js   # 스케줄러
│   │   ├── cache/
│   │   │   ├── manager.js     # 캐시 관리
│   │   │   ├── strategies.js  # 캐싱 전략
│   │   │   └── invalidation.js
│   │   └── ai/
│   │       ├── claude.js      # Claude API
│   │       ├── prompts.js     # 프롬프트 관리
│   │       └── context.js     # 컨텍스트 관리
│   ├── models/
│   │   ├── User.js
│   │   ├── Video.js
│   │   ├── SearchLog.js
│   │   └── TrendData.js
│   ├── jobs/
│   │   ├── trendUpdate.js    # 트렌드 업데이트
│   │   ├── cacheRefresh.js   # 캐시 갱신
│   │   └── cleanup.js         # 데이터 정리
│   └── utils/
│       ├── validators.js
│       ├── formatters.js
│       └── helpers.js
├── tests/
├── package.json
└── .env.example

```

### 2.3.2 Railway 배포 설정

### Railway 구성

```yaml
# railway.toml
[build]
builder = "nixpacks"
buildCommand = "npm install && npm run build"

[deploy]
startCommand = "npm start"
healthcheckPath = "/health"
healthcheckTimeout = 300
restartPolicyType = "always"

[[services]]
name = "youtube-shorts-api"
port = 3000

[services.youtube-shorts-api]
  [services.youtube-shorts-api.envs]
    NODE_ENV = "production"
    PORT = "$PORT"

```

### 환경 변수 관리

```jsx
// config/environment.js
const dotenv = require('dotenv');
const path = require('path');

// 환경별 설정 로드
const envFile = process.env.NODE_ENV === 'production'
  ? '.env.production'
  : '.env.development';

dotenv.config({ path: path.resolve(process.cwd(), envFile) });

module.exports = {
  // 서버 설정
  NODE_ENV: process.env.NODE_ENV || 'development',
  PORT: process.env.PORT || 3000,

  // 데이터베이스
  SUPABASE_URL: process.env.SUPABASE_URL,
  SUPABASE_ANON_KEY: process.env.SUPABASE_ANON_KEY,
  SUPABASE_SERVICE_KEY: process.env.SUPABASE_SERVICE_KEY,

  // Redis
  REDIS_URL: process.env.REDIS_URL,

  // 외부 API
  YOUTUBE_API_KEY: process.env.YOUTUBE_API_KEY,
  CLAUDE_API_KEY: process.env.CLAUDE_API_KEY,

  // JWT
  JWT_SECRET: process.env.JWT_SECRET,
  JWT_EXPIRES_IN: process.env.JWT_EXPIRES_IN || '7d',

  // API 할당량
  YOUTUBE_QUOTA: {
    DAILY_LIMIT: 10000,
    POPULAR_KEYWORDS: 3000,
    TRENDING_KEYWORDS: 1000,
    USER_PATTERNS: 1000,
    HOURLY_TRENDS: 1000,
    PREMIUM_REALTIME: 2500,
    EMERGENCY_BUFFER: 1500
  }
};

```

### 자동 배포 설정

```yaml
# .github/workflows/deploy.yml
name: Deploy to Railway

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install dependencies
        run: npm ci

      - name: Run tests
        run: npm test

      - name: Deploy to Railway
        uses: railwayapp/deploy-action@v1
        with:
          service: youtube-shorts-api
        env:
          RAILWAY_TOKEN: ${{ secrets.RAILWAY_TOKEN }}

```

### 2.3.3 미들웨어 구성

### 1. 인증 미들웨어

```jsx
// middleware/auth.js
const jwt = require('jsonwebtoken');
const { supabase } = require('../config/database');

const authMiddleware = async (req, res, next) => {
  try {
    // Bearer 토큰 추출
    const token = req.headers.authorization?.split(' ')[1];

    if (!token) {
      return res.status(401).json({ error: '인증 토큰이 필요합니다' });
    }

    // JWT 검증
    const payload = jwt.verify(token, process.env.JWT_SECRET);

    // Supabase에서 사용자 확인
    const { data: user, error } = await supabase
      .from('users')
      .select('*')
      .eq('id', payload.userId)
      .single();

    if (error || !user) {
      return res.status(401).json({ error: '유효하지 않은 사용자입니다' });
    }

    // 요청 객체에 사용자 정보 추가
    req.user = user;
    req.userId = user.id;

    next();
  } catch (error) {
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({ error: '토큰이 만료되었습니다' });
    }

    return res.status(401).json({ error: '유효하지 않은 토큰입니다' });
  }
};

// 프리미엄 사용자 확인
const premiumMiddleware = async (req, res, next) => {
  if (req.user.user_tier !== 'premium' && req.user.user_tier !== 'pro') {
    return res.status(403).json({
      error: '프리미엄 기능입니다',
      upgrade_url: '/pricing'
    });
  }
  next();
};

module.exports = { authMiddleware, premiumMiddleware };

```

### 2. Rate Limiting

```jsx
// middleware/rateLimit.js
const rateLimit = require('express-rate-limit');
const RedisStore = require('rate-limit-redis');
const { redis } = require('../config/redis');

// 기본 rate limiter
const defaultLimiter = rateLimit({
  store: new RedisStore({
    client: redis,
    prefix: 'rl:default:'
  }),
  windowMs: 15 * 60 * 1000, // 15분
  max: 100, // 최대 100 요청
  message: '너무 많은 요청을 보내셨습니다. 잠시 후 다시 시도해주세요.',
  standardHeaders: true,
  legacyHeaders: false,
});

// 검색 API rate limiter
const searchLimiter = rateLimit({
  store: new RedisStore({
    client: redis,
    prefix: 'rl:search:'
  }),
  windowMs: 60 * 1000, // 1분
  max: 20, // 분당 20회
  skip: (req) => req.user?.user_tier === 'premium', // 프리미엄 제외
  keyGenerator: (req) => req.userId || req.ip,
});

// AI 채팅 rate limiter
const chatLimiter = rateLimit({
  store: new RedisStore({
    client: redis,
    prefix: 'rl:chat:'
  }),
  windowMs: 60 * 60 * 1000, // 1시간
  max: async (req) => {
    if (req.user?.user_tier === 'premium') return 100;
    return 1; // 무료 사용자는 시간당 1회
  },
  keyGenerator: (req) => req.userId,
});

module.exports = {
  defaultLimiter,
  searchLimiter,
  chatLimiter
};

```

### 3. 캐시 미들웨어

```jsx
// middleware/cache.js
const { redis } = require('../config/redis');

const cacheMiddleware = (options = {}) => {
  const {
    ttl = 3600, // 기본 1시간
    keyPrefix = 'cache:',
    keyGenerator
  } = options;

  return async (req, res, next) => {
    // POST, PUT, DELETE는 캐시하지 않음
    if (req.method !== 'GET') {
      return next();
    }

    // 캐시 키 생성
    const key = keyGenerator
      ? keyGenerator(req)
      : `${keyPrefix}${req.originalUrl}`;

    try {
      // 캐시 확인
      const cached = await redis.get(key);

      if (cached) {
        // 캐시 히트
        const data = JSON.parse(cached);

        // 캐시 히트율 추적
        await redis.incr('stats:cache:hits');

        return res.json({
          ...data,
          _cached: true,
          _cachedAt: new Date().toISOString()
        });
      }

      // 캐시 미스
      await redis.incr('stats:cache:misses');

      // 원본 응답 가로채기
      const originalJson = res.json;
      res.json = function(data) {
        // 성공 응답만 캐시
        if (res.statusCode === 200) {
          redis.setex(key, ttl, JSON.stringify(data));
        }

        return originalJson.call(this, data);
      };

      next();
    } catch (error) {
      console.error('Cache middleware error:', error);
      next();
    }
  };
};

// 캐시 무효화 헬퍼
const invalidateCache = async (pattern) => {
  const keys = await redis.keys(`cache:${pattern}*`);
  if (keys.length > 0) {
    await redis.del(...keys);
  }
};

module.exports = { cacheMiddleware, invalidateCache };

```

### 2.3.4 에러 처리 전략

### 글로벌 에러 핸들러

```jsx
// middleware/error.js
class AppError extends Error {
  constructor(message, statusCode) {
    super(message);
    this.statusCode = statusCode;
    this.isOperational = true;
    Error.captureStackTrace(this, this.constructor);
  }
}

// 비동기 에러 캐처
const asyncHandler = (fn) => (req, res, next) => {
  Promise.resolve(fn(req, res, next)).catch(next);
};

// 에러 핸들링 미들웨어
const errorHandler = (err, req, res, next) => {
  let { statusCode = 500, message } = err;

  // 로깅
  console.error({
    error: err,
    request: {
      method: req.method,
      url: req.url,
      headers: req.headers,
      body: req.body
    },
    timestamp: new Date().toISOString()
  });

  // 프로덕션에서는 상세 에러 숨김
  if (process.env.NODE_ENV === 'production' && !err.isOperational) {
    statusCode = 500;
    message = '서버 오류가 발생했습니다';
  }

  res.status(statusCode).json({
    success: false,
    error: {
      message,
      ...(process.env.NODE_ENV === 'development' && {
        stack: err.stack,
        details: err
      })
    }
  });
};

module.exports = {
  AppError,
  asyncHandler,
  errorHandler
};

```

### API 응답 표준화

```jsx
// utils/apiResponse.js
class ApiResponse {
  static success(res, data, message = '성공', statusCode = 200) {
    return res.status(statusCode).json({
      success: true,
      message,
      data,
      timestamp: new Date().toISOString()
    });
  }

  static error(res, message = '오류가 발생했습니다', statusCode = 400, details = null) {
    return res.status(statusCode).json({
      success: false,
      error: {
        message,
        details,
        timestamp: new Date().toISOString()
      }
    });
  }

  static paginated(res, data, pagination, message = '성공') {
    return res.status(200).json({
      success: true,
      message,
      data,
      pagination: {
        page: pagination.page,
        limit: pagination.limit,
        total: pagination.total,
        totalPages: Math.ceil(pagination.total / pagination.limit)
      },
      timestamp: new Date().toISOString()
    });
  }
}

module.exports = ApiResponse;

```

## 2.4: 데이터베이스 설계 (Database Design)

## 2.4.1 Supabase 선택 이유

### 기술적 장점

```yaml
PostgreSQL 기반:
  - JSONB 지원으로 유연한 스키마 설계
  - 강력한 인덱싱 옵션 (GIN, GIST)
  - 복잡한 쿼리 최적화 가능
  - 대용량 데이터 처리 성능

실시간 기능:
  - Realtime subscriptions 내장
  - WebSocket 기반 실시간 동기화
  - 대화형 검색 응답에 최적
  - 트렌드 업데이트 즉시 반영

통합 인증:
  - Auth 시스템 내장
  - JWT 토큰 자동 관리
  - 소셜 로그인 간편 설정
  - Row Level Security 연동

자동 API 생성:
  - RESTful API 자동 제공
  - GraphQL 지원 (선택)
  - API 문서 자동 생성
  - 타입 안전성 보장

```

### 비즈니스 장점

```yaml
비용 효율성:
  - 무료 티어: 500MB, 2GB 전송량
  - 프로 플랜: $25/월 (8GB, 50GB 전송량)
  - 예상 비용: 월 ₩300,000 (10만 MAU)
  - 경쟁사 대비 70% 저렴

개발 속도:
  - 설정 시간: 5분
  - 기본 CRUD: 자동 생성
  - 인증 시스템: 즉시 사용
  - 10일 개발에 최적

확장성:
  - 수평 확장 가능
  - 읽기 전용 복제본
  - 자동 백업
  - 99.9% SLA

```

### 우리 서비스와의 시너지

```yaml
MCP 연동:
  - JSONB로 AI 분석 결과 저장
  - 실시간 대화 상태 동기화
  - 벡터 검색 지원 (pgvector)

캐싱 전략:
  - 네이티브 캐싱 지원
  - 인덱스 기반 빠른 조회
  - 파티셔닝으로 성능 최적화

트렌드 분석:
  - 시계열 데이터 효율적 저장
  - 집계 함수 최적화
  - 실시간 분석 쿼리

```

## 2.4.2 테이블 스키마 상세

### 사용자 관리 테이블

### users (사용자 기본 정보)

```sql
CREATE TABLE users (
  -- Primary Keys
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  auth_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,

  -- Basic Info
  email TEXT UNIQUE NOT NULL,
  username TEXT UNIQUE,
  display_name TEXT,
  avatar_url TEXT,

  -- Subscription Info
  user_tier TEXT DEFAULT 'free' CHECK (user_tier IN ('free', 'premium', 'pro')),
  subscription_start TIMESTAMP WITH TIME ZONE,
  subscription_end TIMESTAMP WITH TIME ZONE,

  -- Preferences (JSONB for flexibility)
  preferences JSONB DEFAULT '{
    "language": "ko",
    "notifications": true,
    "auto_play": true,
    "content_filter": "safe"
  }'::jsonb,

  -- Statistics
  total_watch_time INTEGER DEFAULT 0, -- seconds
  total_searches INTEGER DEFAULT 0,
  ai_conversations INTEGER DEFAULT 0,

  -- Timestamps
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  last_active_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_tier ON users(user_tier);
CREATE INDEX idx_users_active ON users(last_active_at DESC);

```

### user_profiles (AI 학습용 프로필)

```sql
CREATE TABLE user_profiles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,

  -- MCP 분석 결과 저장
  personality_vector JSONB DEFAULT '{}', -- AI가 파악한 성향
  preferred_categories TEXT[] DEFAULT '{}',
  preferred_keywords TEXT[] DEFAULT '{}',

  -- 시간대별 선호도
  time_preferences JSONB DEFAULT '{
    "morning": ["활력", "뉴스", "루틴"],
    "afternoon": ["음악", "요리", "브이로그"],
    "evening": ["힐링", "ASMR", "게임"],
    "night": ["수면", "명상", "라디오"]
  }'::jsonb,

  -- 맥락별 선호도
  context_preferences JSONB DEFAULT '{
    "mood": {
      "happy": ["댄스", "웃긴영상"],
      "sad": ["위로", "음악"],
      "tired": ["힐링", "ASMR"]
    },
    "activity": {
      "commute": ["짧은영상", "뉴스"],
      "meal": ["먹방", "요리"],
      "exercise": ["운동", "동기부여"]
    }
  }'::jsonb,

  -- AI 신뢰도 점수
  profile_confidence DECIMAL(3,2) DEFAULT 0.0,
  last_analyzed TIMESTAMP WITH TIME ZONE DEFAULT NOW(),

  -- 벡터 임베딩 (향후 확장)
  embedding vector(1536) -- OpenAI embeddings
);

-- Indexes
CREATE INDEX idx_profiles_user ON user_profiles(user_id);
CREATE INDEX idx_profiles_categories ON user_profiles USING GIN(preferred_categories);
CREATE INDEX idx_profiles_keywords ON user_profiles USING GIN(preferred_keywords);

```

### 영상 캐싱 테이블

### cached_videos (YouTube 영상 메타데이터)

```sql
CREATE TABLE cached_videos (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  video_id VARCHAR(20) UNIQUE NOT NULL, -- YouTube video ID

  -- Basic Info
  title TEXT NOT NULL,
  description TEXT,
  channel_id VARCHAR(50) NOT NULL,
  channel_title VARCHAR(200) NOT NULL,

  -- URLs
  thumbnail_url TEXT,
  video_url TEXT GENERATED ALWAYS AS
    ('https://www.youtube.com/shorts/' || video_id) STORED,

  -- Metadata
  duration INTEGER, -- seconds
  published_at TIMESTAMP WITH TIME ZONE,

  -- Statistics
  view_count BIGINT DEFAULT 0,
  like_count INTEGER DEFAULT 0,
  comment_count INTEGER DEFAULT 0,

  -- Quality Metrics
  is_shorts BOOLEAN DEFAULT true,
  is_embeddable BOOLEAN DEFAULT true,
  quality_score DECIMAL(3,2) DEFAULT 0.0, -- 0.0 to 1.0

  -- AI Analysis (MCP 결과)
  ai_analysis JSONB DEFAULT '{
    "categories": [],
    "keywords": [],
    "emotions": [],
    "topics": [],
    "language": "ko"
  }'::jsonb,

  -- Caching Info
  cached_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  expires_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() + INTERVAL '30 days',
  cache_hit_count INTEGER DEFAULT 0,
  last_accessed TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_videos_video_id ON cached_videos(video_id);
CREATE INDEX idx_videos_channel ON cached_videos(channel_id);
CREATE INDEX idx_videos_quality ON cached_videos(quality_score DESC);
CREATE INDEX idx_videos_views ON cached_videos(view_count DESC);
CREATE INDEX idx_videos_expires ON cached_videos(expires_at);
CREATE INDEX idx_videos_ai_keywords ON cached_videos USING GIN((ai_analysis->'keywords'));

```

### keyword_video_mappings (키워드-영상 매핑)

```sql
CREATE TABLE keyword_video_mappings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Relations
  keyword VARCHAR(100) NOT NULL,
  video_id UUID REFERENCES cached_videos(id) ON DELETE CASCADE,

  -- Ranking Info
  rank_position INTEGER NOT NULL,
  relevance_score DECIMAL(3,2) NOT NULL, -- 0.0 to 1.0

  -- Source Info
  source TEXT CHECK (source IN ('user_search', 'trending', 'ai_suggestion', 'manual')),

  -- Performance Metrics
  click_count INTEGER DEFAULT 0,
  completion_rate DECIMAL(3,2) DEFAULT 0.0,
  user_rating DECIMAL(2,1) DEFAULT 0.0, -- 0.0 to 5.0

  -- Timestamps
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_kvm_keyword ON keyword_video_mappings(keyword);
CREATE INDEX idx_kvm_video ON keyword_video_mappings(video_id);
CREATE INDEX idx_kvm_keyword_rank ON keyword_video_mappings(keyword, rank_position);
CREATE INDEX idx_kvm_relevance ON keyword_video_mappings(relevance_score DESC);

```

### 사용자 활동 추적 테이블

### search_sessions (검색 세션)

```sql
CREATE TABLE search_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE SET NULL,
  session_id UUID NOT NULL,

  -- Search Info
  search_type TEXT CHECK (search_type IN ('keyword', 'ai_chat', 'trending')),
  search_query TEXT,

  -- AI Chat Context (MCP 대화 저장)
  conversation_context JSONB DEFAULT '{
    "messages": [],
    "extracted_keywords": [],
    "user_context": {},
    "ai_suggestions": []
  }'::jsonb,

  -- Results
  results_count INTEGER DEFAULT 0,
  results_shown UUID[] DEFAULT '{}', -- video IDs

  -- Performance
  response_time_ms INTEGER,
  cache_hit BOOLEAN DEFAULT false,

  -- Timestamps
  started_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  ended_at TIMESTAMP WITH TIME ZONE
);

-- Indexes
CREATE INDEX idx_sessions_user ON search_sessions(user_id);
CREATE INDEX idx_sessions_session ON search_sessions(session_id);
CREATE INDEX idx_sessions_time ON search_sessions(started_at DESC);
CREATE INDEX idx_sessions_type ON search_sessions(search_type);

```

### video_interactions (영상 상호작용)

```sql
CREATE TABLE video_interactions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Relations
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  video_id UUID REFERENCES cached_videos(id) ON DELETE CASCADE,
  session_id UUID REFERENCES search_sessions(session_id),

  -- Interaction Type
  interaction_type TEXT NOT NULL CHECK (
    interaction_type IN ('view', 'like', 'dislike', 'share', 'save', 'skip')
  ),

  -- View Details
  watch_duration INTEGER, -- seconds
  total_duration INTEGER, -- video length
  completion_rate DECIMAL(3,2) GENERATED ALWAYS AS
    (CASE WHEN total_duration > 0
      THEN LEAST(watch_duration::DECIMAL / total_duration, 1.0)
      ELSE 0 END) STORED,

  -- Context
  source_keyword VARCHAR(100),
  source_type TEXT, -- 'search', 'trending', 'recommendation'

  -- Timestamp
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_interactions_user ON video_interactions(user_id);
CREATE INDEX idx_interactions_video ON video_interactions(video_id);
CREATE INDEX idx_interactions_type ON video_interactions(interaction_type);
CREATE INDEX idx_interactions_time ON video_interactions(created_at DESC);
CREATE INDEX idx_interactions_completion ON video_interactions(completion_rate DESC);

```

### 트렌드 데이터 테이블

### trending_keywords (실시간 트렌드)

```sql
CREATE TABLE trending_keywords (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Keyword Info
  keyword VARCHAR(100) NOT NULL,
  category VARCHAR(50),

  -- Trend Metrics
  trend_score DECIMAL(5,2) NOT NULL, -- 0-100
  search_volume INTEGER,
  growth_rate DECIMAL(5,2), -- percentage

  -- Source
  source TEXT NOT NULL CHECK (source IN ('bright_data_mcp', 'serpapi', 'internal', 'youtube', 'mixed')),
  region VARCHAR(10) DEFAULT 'KR',

  -- Time Context
  time_slot VARCHAR(20), -- 'morning', 'afternoon', 'evening', 'night'
  day_of_week INTEGER, -- 0-6 (Sunday-Saturday)

  -- Valid Period
  valid_from TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  valid_until TIMESTAMP WITH TIME ZONE DEFAULT NOW() + INTERVAL '4 hours',

  -- Metadata
  related_keywords TEXT[] DEFAULT '{}',
  metadata JSONB DEFAULT '{}'::jsonb
);

-- Indexes
CREATE INDEX idx_trending_keyword ON trending_keywords(keyword);
CREATE INDEX idx_trending_score ON trending_keywords(trend_score DESC);
CREATE INDEX idx_trending_valid ON trending_keywords(valid_from, valid_until);
CREATE INDEX idx_trending_category ON trending_keywords(category);
CREATE INDEX idx_trending_time ON trending_keywords(time_slot, day_of_week);

```

### user_search_patterns (사용자 검색 패턴)

```sql
CREATE TABLE user_search_patterns (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Aggregation Key
  time_bucket TIMESTAMP WITH TIME ZONE NOT NULL, -- 1시간 단위
  keyword VARCHAR(100) NOT NULL,

  -- Metrics
  search_count INTEGER DEFAULT 0,
  unique_users INTEGER DEFAULT 0,
  avg_results_clicked DECIMAL(4,2) DEFAULT 0.0,
  avg_watch_time DECIMAL(6,2) DEFAULT 0.0, -- seconds

  -- User Segments
  user_segments JSONB DEFAULT '{
    "free": 0,
    "premium": 0,
    "age_groups": {},
    "time_zones": {}
  }'::jsonb,

  -- Derived Insights
  is_trending BOOLEAN DEFAULT false,
  trend_direction TEXT CHECK (trend_direction IN ('up', 'down', 'stable')),

  -- Timestamps
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Indexes
CREATE INDEX idx_patterns_bucket ON user_search_patterns(time_bucket DESC);
CREATE INDEX idx_patterns_keyword ON user_search_patterns(keyword);
CREATE INDEX idx_patterns_trending ON user_search_patterns(is_trending, time_bucket DESC);

```

## 2.4.3 인덱싱 전략

### 인덱스 설계 원칙

```yaml
Primary Indexes:
  - 모든 Primary Key에 자동 생성
  - Foreign Key 관계에 인덱스 추가
  - 자주 조회되는 컬럼 우선

Composite Indexes:
  - WHERE 절에 자주 사용되는 컬럼 조합
  - 정렬이 필요한 쿼리 최적화
  - 커버링 인덱스로 성능 향상

Specialized Indexes:
  - GIN: JSONB, 배열 타입 검색
  - GIST: 지리 정보, 범위 검색
  - BRIN: 시계열 데이터 (시간순 정렬)

```

### 핵심 쿼리별 인덱스

### 1. 키워드 검색 최적화

```sql
-- 키워드로 영상 찾기 (가장 빈번한 쿼리)
CREATE INDEX idx_keyword_search ON keyword_video_mappings(
  keyword,
  relevance_score DESC,
  rank_position
) INCLUDE (video_id);

-- 인기 키워드 조회
CREATE INDEX idx_popular_keywords ON user_search_patterns(
  time_bucket DESC,
  search_count DESC
) WHERE search_count > 10;

```

### 2. 개인화 추천 최적화

```sql
-- 사용자 선호 카테고리 매칭
CREATE INDEX idx_user_preferences ON user_profiles
USING GIN(preferred_categories);

-- 시간대별 추천
CREATE INDEX idx_time_recommendations ON user_profiles
USING GIN(time_preferences);

-- 사용자 최근 활동
CREATE INDEX idx_recent_activity ON video_interactions(
  user_id,
  created_at DESC
) INCLUDE (video_id, interaction_type);

```

### 3. 트렌드 분석 최적화

```sql
-- 실시간 트렌드 조회
CREATE INDEX idx_current_trends ON trending_keywords(
  valid_from,
  valid_until,
  trend_score DESC
) WHERE valid_until > NOW();

-- 시간대별 트렌드
CREATE INDEX idx_hourly_trends ON trending_keywords(
  time_slot,
  day_of_week,
  trend_score DESC
);

```

### 4. 캐시 관리 최적화

```sql
-- 만료된 캐시 정리
CREATE INDEX idx_expired_cache ON cached_videos(expires_at)
WHERE expires_at < NOW();

-- 캐시 히트율 분석
CREATE INDEX idx_cache_performance ON cached_videos(
  cache_hit_count DESC,
  last_accessed DESC
);

```

### JSONB 인덱싱 전략

```sql
-- AI 분석 결과 검색
CREATE INDEX idx_ai_categories ON cached_videos
USING GIN((ai_analysis->'categories'));

CREATE INDEX idx_ai_keywords ON cached_videos
USING GIN((ai_analysis->'keywords'));

CREATE INDEX idx_ai_emotions ON cached_videos
USING GIN((ai_analysis->'emotions'));

-- 사용자 맥락 검색
CREATE INDEX idx_user_context ON search_sessions
USING GIN((conversation_context->'user_context'));

```

### 파티셔닝 전략

```sql
-- 대용량 로그 테이블 월별 파티셔닝
CREATE TABLE video_interactions_2025_06
PARTITION OF video_interactions
FOR VALUES FROM ('2025-06-01') TO ('2025-07-01');

-- 자동 파티션 생성 함수
CREATE OR REPLACE FUNCTION create_monthly_partition()
RETURNS void AS $$
DECLARE
  start_date date;
  end_date date;
  partition_name text;
BEGIN
  start_date := date_trunc('month', CURRENT_DATE);
  end_date := start_date + interval '1 month';
  partition_name := 'video_interactions_' || to_char(start_date, 'YYYY_MM');

  EXECUTE format('CREATE TABLE IF NOT EXISTS %I PARTITION OF video_interactions FOR VALUES FROM (%L) TO (%L)',
    partition_name, start_date, end_date);
END;
$$ LANGUAGE plpgsql;

-- 매월 실행 스케줄
SELECT cron.schedule('create-monthly-partition', '0 0 1 * *', 'SELECT create_monthly_partition()');

```

## 2.4.4 보안 정책 (Row Level Security)

### RLS 정책 설계 원칙

```yaml
기본 원칙:
  - 모든 테이블에 RLS 활성화
  - 최소 권한 원칙 적용
  - 역할별 접근 제어
  - 감사 로그 유지

사용자 역할:
  - anonymous: 읽기 전용 (공개 데이터)
  - authenticated: 자신의 데이터만 접근
  - premium: 추가 기능 접근
  - admin: 전체 접근 권한

```

### 테이블별 RLS 정책

### users 테이블

```sql
-- RLS 활성화
ALTER TABLE users ENABLE ROW LEVEL SECURITY;

-- 정책 1: 사용자는 자신의 정보만 조회
CREATE POLICY "Users can view own profile" ON users
  FOR SELECT
  USING (auth.uid() = auth_id);

-- 정책 2: 사용자는 자신의 정보만 수정
CREATE POLICY "Users can update own profile" ON users
  FOR UPDATE
  USING (auth.uid() = auth_id)
  WITH CHECK (auth.uid() = auth_id);

-- 정책 3: 신규 사용자 생성은 인증된 사용자만
CREATE POLICY "Authenticated users can insert" ON users
  FOR INSERT
  WITH CHECK (auth.uid() = auth_id);

-- 정책 4: 삭제는 관리자만
CREATE POLICY "Only admins can delete users" ON users
  FOR DELETE
  USING (auth.jwt() ->> 'role' = 'admin');

```

### cached_videos 테이블

```sql
-- RLS 활성화
ALTER TABLE cached_videos ENABLE ROW LEVEL SECURITY;

-- 정책 1: 모든 사용자가 캐시된 영상 조회 가능
CREATE POLICY "Anyone can view cached videos" ON cached_videos
  FOR SELECT
  USING (true);

-- 정책 2: 시스템만 영상 추가/수정 가능
CREATE POLICY "Only system can modify videos" ON cached_videos
  FOR ALL
  USING (auth.jwt() ->> 'role' = 'service_role');

```

### video_interactions 테이블

```sql
-- RLS 활성화
ALTER TABLE video_interactions ENABLE ROW LEVEL SECURITY;

-- 정책 1: 사용자는 자신의 상호작용만 조회
CREATE POLICY "Users can view own interactions" ON video_interactions
  FOR SELECT
  USING (auth.uid() = user_id);

-- 정책 2: 사용자는 자신의 상호작용만 생성
CREATE POLICY "Users can create own interactions" ON video_interactions
  FOR INSERT
  WITH CHECK (auth.uid() = user_id);

-- 정책 3: 집계 데이터는 프리미엄 사용자만
CREATE POLICY "Premium users can view analytics" ON video_interactions
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM users
      WHERE users.auth_id = auth.uid()
      AND users.user_tier IN ('premium', 'pro')
    )
  );

```

### search_sessions 테이블

```sql
-- RLS 활성화
ALTER TABLE search_sessions ENABLE ROW LEVEL SECURITY;

-- 정책 1: 사용자는 자신의 검색 기록만 조회
CREATE POLICY "Users can view own searches" ON search_sessions
  FOR SELECT
  USING (auth.uid() = user_id);

-- 정책 2: AI 대화는 프리미엄 사용자만 생성
CREATE POLICY "Premium users can use AI chat" ON search_sessions
  FOR INSERT
  WITH CHECK (
    CASE
      WHEN search_type = 'ai_chat' THEN
        EXISTS (
          SELECT 1 FROM users
          WHERE users.auth_id = auth.uid()
          AND users.user_tier IN ('premium', 'pro')
        )
      ELSE true
    END
  );

```

### 데이터 암호화 정책

```sql
-- 민감한 데이터 암호화
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- 사용자 개인정보 암호화 함수
CREATE OR REPLACE FUNCTION encrypt_sensitive_data(data text)
RETURNS text AS $$
BEGIN
  RETURN pgp_sym_encrypt(data, current_setting('app.encryption_key'));
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 복호화 함수 (권한 있는 사용자만)
CREATE OR REPLACE FUNCTION decrypt_sensitive_data(encrypted_data text)
RETURNS text AS $$
BEGIN
  -- 권한 확인
  IF NOT (auth.jwt() ->> 'role' IN ('admin', 'service_role')) THEN
    RAISE EXCEPTION 'Unauthorized access';
  END IF;

  RETURN pgp_sym_decrypt(encrypted_data::bytea, current_setting('app.encryption_key'));
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

```

### 감사 로그 (Audit Logging)

```sql
-- 감사 로그 테이블
CREATE TABLE audit_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  table_name TEXT NOT NULL,
  operation TEXT NOT NULL,
  user_id UUID,
  changed_data JSONB,
  ip_address INET,
  user_agent TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 감사 트리거 함수
CREATE OR REPLACE FUNCTION audit_trigger_function()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO audit_logs (
    table_name,
    operation,
    user_id,
    changed_data,
    ip_address,
    user_agent
  ) VALUES (
    TG_TABLE_NAME,
    TG_OP,
    auth.uid(),
    to_jsonb(NEW),
    inet_client_addr(),
    current_setting('app.user_agent', true)
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- 주요 테이블에 감사 트리거 적용
CREATE TRIGGER audit_users
  AFTER INSERT OR UPDATE OR DELETE ON users
  FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();

CREATE TRIGGER audit_interactions
  AFTER INSERT ON video_interactions
  FOR EACH ROW EXECUTE FUNCTION audit_trigger_function();

```

### 성능 최적화 뷰

```sql
-- 자주 사용되는 복잡한 쿼리를 뷰로 최적화
CREATE OR REPLACE VIEW popular_videos_by_keyword AS
SELECT
  k.keyword,
  v.video_id,
  v.title,
  v.thumbnail_url,
  v.view_count,
  k.relevance_score,
  k.rank_position
FROM keyword_video_mappings k
JOIN cached_videos v ON k.video_id = v.id
WHERE v.expires_at > NOW()
  AND v.quality_score > 0.7
ORDER BY k.keyword, k.rank_position;

-- 사용자 맞춤 추천 뷰
CREATE OR REPLACE VIEW user_recommendations AS
WITH user_preferences AS (
  SELECT
    u.id as user_id,
    up.preferred_categories,
    up.preferred_keywords,
    EXTRACT(HOUR FROM NOW()) as current_hour
  FROM users u
  JOIN user_profiles up ON u.id = up.user_id
)
SELECT
  up.user_id,
  v.video_id,
  v.title,
  v.thumbnail_url,
  CASE
    WHEN up.preferred_categories && v.ai_analysis->>'categories' THEN 0.3
    ELSE 0
  END +
  CASE
    WHEN up.preferred_keywords && v.ai_analysis->>'keywords' THEN 0.3
    ELSE 0
  END +
  (v.quality_score * 0.4) as recommendation_score
FROM user_preferences up
CROSS JOIN cached_videos v
WHERE v.expires_at > NOW()
ORDER BY recommendation_score DESC;

```

## 2.4.5 데이터베이스 모니터링 및 유지보수

### 성능 모니터링

```sql
-- 슬로우 쿼리 모니터링
CREATE OR REPLACE VIEW slow_queries AS
SELECT
  query,
  calls,
  total_time,
  mean_time,
  max_time
FROM pg_stat_statements
WHERE mean_time > 100 -- 100ms 이상
ORDER BY mean_time DESC
LIMIT 20;

-- 인덱스 사용률 모니터링
CREATE OR REPLACE VIEW index_usage AS
SELECT
  schemaname,
  tablename,
  indexname,
  idx_scan,
  idx_tup_read,
  idx_tup_fetch
FROM pg_stat_user_indexes
ORDER BY idx_scan DESC;

-- 테이블 크기 모니터링
CREATE OR REPLACE VIEW table_sizes AS
SELECT
  schemaname,
  tablename,
  pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size,
  pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) as table_size,
  pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename) - pg_relation_size(schemaname||'.'||tablename)) as index_size
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;

```

### 자동 유지보수 작업

```sql
-- 오래된 데이터 정리 (매일 실행)
CREATE OR REPLACE FUNCTION cleanup_old_data()
RETURNS void AS $$
BEGIN
  -- 30일 이상 된 로그 삭제
  DELETE FROM audit_logs WHERE created_at < NOW() - INTERVAL '30 days';

  -- 만료된 캐시 삭제
  DELETE FROM cached_videos WHERE expires_at < NOW() - INTERVAL '7 days';

  -- 오래된 검색 세션 삭제
  DELETE FROM search_sessions WHERE started_at < NOW() - INTERVAL '90 days';

  -- 통계 재계산
  REFRESH MATERIALIZED VIEW CONCURRENTLY daily_stats;
END;
$$ LANGUAGE plpgsql;

-- 스케줄 설정
SELECT cron.schedule('cleanup-old-data', '0 3 * * *', 'SELECT cleanup_old_data()');

```

## 2.4.6 백업 및 복구 전략

### 백업 정책

```yaml
자동 백업:
  - 일일 백업: 매일 오전 3시
  - 주간 백업: 매주 일요일
  - 월간 백업: 매월 1일
  - 보관 기간: 일일(7일), 주간(4주), 월간(12개월)

실시간 복제:
  - 읽기 전용 복제본: 2개
  - 지역: 서울, 도쿄
  - 지연 시간: < 1초

Point-in-Time Recovery:
  - WAL 아카이빙 활성화
  - 최대 7일 이내 특정 시점 복구
  - 복구 시간 목표(RTO): 1시간
  - 복구 시점 목표(RPO): 5분

```

### 재해 복구 계획

```yaml
시나리오별 대응:
  1. 단일 테이블 손상:
     - 백업에서 특정 테이블만 복구
     - 예상 시간: 10분

  2. 전체 데이터베이스 손실:
     - 가장 최근 백업으로 복구
     - WAL 적용으로 최신 상태 복원
     - 예상 시간: 1시간

  3. 리전 전체 장애:
     - 다른 리전 복제본으로 자동 전환
     - DNS 업데이트
     - 예상 시간: 5분

```

## 2.5: 외부 서비스 연동 (External Service Integration)

## 2.5.1 YouTube Data API v3

### API 설정 및 초기화

### 1. Google Cloud Console 설정

```yaml
프로젝트 설정:
  1. Google Cloud Console 접속
  2. 새 프로젝트 생성: "youtube-shorts-curator"
  3. YouTube Data API v3 활성화
  4. API 키 생성 (서버용)
  5. API 키 제한:
     - IP 주소 제한: Railway 서버 IP
     - API 제한: YouTube Data API v3만
     - 할당량: 기본 10,000 units/day

```

### 2. Node.js 클라이언트 설정

```jsx
// youtube-service.js
const { google } = require('googleapis');
const NodeCache = require('node-cache');

class YouTubeService {
  constructor() {
    // API 클라이언트 초기화
    this.youtube = google.youtube({
      version: 'v3',
      auth: process.env.YOUTUBE_API_KEY
    });

    // 로컬 캐시 (5분)
    this.cache = new NodeCache({ stdTTL: 300 });

    // API 할당량 추적
    this.quotaTracker = {
      used: 0,
      limit: 10000,
      resetTime: this.getNextResetTime()
    };
  }

  getNextResetTime() {
    const now = new Date();
    const reset = new Date(now);
    reset.setUTCHours(7, 0, 0, 0); // PST 자정 = UTC 07:00
    if (reset <= now) {
      reset.setDate(reset.getDate() + 1);
    }
    return reset;
  }
}

```

### 핵심 API 메소드 구현

### 1. Shorts 검색 기능

```jsx
async searchShorts(query, options = {}) {
  const cacheKey = `search:${query}:${JSON.stringify(options)}`;
  const cached = this.cache.get(cacheKey);
  if (cached) return cached;

  try {
    // 할당량 체크
    if (!this.checkQuota(100)) {
      throw new Error('YouTube API quota exceeded');
    }

    const response = await this.youtube.search.list({
      part: 'snippet',
      q: query,
      type: 'video',
              videoDuration: 'short', // 4분 미만
      maxResults: options.maxResults || 50,
      order: options.order || 'relevance',
      relevanceLanguage: 'ko',
      regionCode: 'KR',
      publishedAfter: options.publishedAfter || undefined,
      pageToken: options.pageToken || undefined
    });

    // 할당량 차감
    this.useQuota(100);

    // Shorts 필터링
    const shorts = await this.filterShorts(response.data.items);

    // 캐시 저장
    this.cache.set(cacheKey, shorts);

    return shorts;
  } catch (error) {
    this.handleAPIError(error);
  }
}

async filterShorts(items) {
  const videoIds = items.map(item => item.id.videoId).join(',');

  try {
    // 상세 정보 조회 (1 unit per video)
    const response = await this.youtube.videos.list({
      part: 'contentDetails,statistics',
      id: videoIds
    });

    this.useQuota(items.length);

    // Shorts 조건 필터링
    return response.data.items.filter(video => {
      const duration = this.parseDuration(video.contentDetails.duration);
      const views = parseInt(video.statistics.viewCount || 0);

      return (
        duration <= 60 && // 60초 이하
        views >= 100000 && // 10만 뷰 이상
        video.contentDetails.regionRestriction?.blocked?.includes('KR') !== true
      );
    }).map(video => ({
      videoId: video.id,
      title: items.find(i => i.id.videoId === video.id)?.snippet.title,
      description: items.find(i => i.id.videoId === video.id)?.snippet.description,
      thumbnail: items.find(i => i.id.videoId === video.id)?.snippet.thumbnails.high.url,
      channelTitle: items.find(i => i.id.videoId === video.id)?.snippet.channelTitle,
      publishedAt: items.find(i => i.id.videoId === video.id)?.snippet.publishedAt,
      viewCount: video.statistics.viewCount,
      likeCount: video.statistics.likeCount,
      duration: duration
    }));
  } catch (error) {
    this.handleAPIError(error);
  }
}

```

### 2. 채널별 Shorts 조회

```jsx
async getChannelShorts(channelId, options = {}) {
  const cacheKey = `channel:${channelId}:shorts`;
  const cached = this.cache.get(cacheKey);
  if (cached) return cached;

  try {
    // 먼저 채널의 uploads 플레이리스트 ID 조회
    const channelResponse = await this.youtube.channels.list({
      part: 'contentDetails',
      id: channelId
    });

    this.useQuota(1);

    const uploadsPlaylistId = channelResponse.data.items[0]
      ?.contentDetails.relatedPlaylists.uploads;

    if (!uploadsPlaylistId) {
      throw new Error('Channel uploads playlist not found');
    }

    // 플레이리스트 아이템 조회
    const playlistResponse = await this.youtube.playlistItems.list({
      part: 'snippet',
      playlistId: uploadsPlaylistId,
      maxResults: 50
    });

    this.useQuota(1);

    // Shorts 필터링
    const shorts = await this.filterShorts(
      playlistResponse.data.items.map(item => ({
        id: { videoId: item.snippet.resourceId.videoId },
        snippet: item.snippet
      }))
    );

    this.cache.set(cacheKey, shorts, 3600); // 1시간 캐싱
    return shorts;
  } catch (error) {
    this.handleAPIError(error);
  }
}

```

### 3. 트렌딩 Shorts 조회

```jsx
async getTrendingShorts(category = null) {
  const cacheKey = `trending:${category || 'all'}`;
  const cached = this.cache.get(cacheKey);
  if (cached) return cached;

  try {
    const response = await this.youtube.videos.list({
      part: 'snippet,statistics,contentDetails',
      chart: 'mostPopular',
      regionCode: 'KR',
      videoCategoryId: category,
      maxResults: 50
    });

    this.useQuota(1);

    // Shorts만 필터링
    const shorts = response.data.items.filter(video => {
      const duration = this.parseDuration(video.contentDetails.duration);
      return duration <= 60;
    });

    this.cache.set(cacheKey, shorts, 1800); // 30분 캐싱
    return shorts;
  } catch (error) {
    this.handleAPIError(error);
  }
}

```

### 에러 처리 및 재시도

```jsx
handleAPIError(error) {
  if (error.code === 403) {
    // 할당량 초과
    console.error('YouTube API quota exceeded');
    throw new QuotaExceededError('Daily quota limit reached');
  } else if (error.code === 429) {
    // Rate limiting
    console.error('YouTube API rate limit');
    throw new RateLimitError('Too many requests');
  } else if (error.code >= 500) {
    // 서버 에러 - 재시도 가능
    console.error('YouTube API server error');
    throw new ServerError('YouTube service unavailable');
  } else {
    console.error('YouTube API error:', error);
    throw error;
  }
}

async withRetry(fn, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      if (error instanceof ServerError && i < maxRetries - 1) {
        // 지수 백오프
        await new Promise(resolve =>
          setTimeout(resolve, Math.pow(2, i) * 1000)
        );
        continue;
      }
      throw error;
    }
  }
}

```

## 2.5.2 Claude API (Anthropic)

### API 설정 및 초기화

### 1. Claude API 클라이언트 설정

```jsx
// claude-service.js
const Anthropic = require('@anthropic-ai/sdk');

class ClaudeService {
  constructor() {
    this.client = new Anthropic({
      apiKey: process.env.CLAUDE_API_KEY,
    });

    // 비용 추적
    this.costTracker = {
      inputTokens: 0,
      outputTokens: 0,
      totalCost: 0
    };

    // 응답 캐시 (컨텍스트별)
    this.contextCache = new Map();
  }

  // 토큰 비용 계산 (Claude 3 Sonnet 기준)
  calculateCost(inputTokens, outputTokens) {
    const inputCost = (inputTokens / 1000) * 0.003;  // $3 per 1M tokens
    const outputCost = (outputTokens / 1000) * 0.015; // $15 per 1M tokens
    return inputCost + outputCost;
  }
}

```

### 2. 자연어 대화 처리

```jsx
async processConversation(message, context = {}) {
  try {
    // 시스템 프롬프트 구성
    const systemPrompt = `당신은 YouTube Shorts 큐레이션 전문 AI입니다.
사용자의 현재 상황, 감정, 필요를 정확히 파악하여 최적의 Shorts를 찾을 수 있는 키워드를 추출합니다.

규칙:
1. 사용자의 맥락을 깊이 이해하세요 (시간, 장소, 감정, 목적)
2. 2-5개의 구체적인 한국어 키워드를 추출하세요
3. 트렌드와 사용자 선호도를 모두 고려하세요
4. 자연스럽고 공감하는 톤으로 대화하세요

사용자 컨텍스트:
- 현재 시간: ${context.currentTime}
- 사용자 선호: ${JSON.stringify(context.preferences)}
- 최근 시청: ${JSON.stringify(context.recentViews)}
- 현재 트렌드: ${JSON.stringify(context.trends)}`;

    const response = await this.client.messages.create({
      model: 'claude-3-sonnet-20240229',
      max_tokens: 500,
      temperature: 0.7,
      system: systemPrompt,
      messages: [
        {
          role: 'user',
          content: message
        }
      ]
    });

    // 비용 추적
    this.costTracker.inputTokens += response.usage.input_tokens;
    this.costTracker.outputTokens += response.usage.output_tokens;
    this.costTracker.totalCost += this.calculateCost(
      response.usage.input_tokens,
      response.usage.output_tokens
    );

    // 응답 파싱
    return this.parseResponse(response.content[0].text);
  } catch (error) {
    this.handleAPIError(error);
  }
}

```

### 3. 키워드 추출 및 분석

```jsx
async extractKeywords(message, context = {}) {
  const cacheKey = `keywords:${message}`;
  if (this.contextCache.has(cacheKey)) {
    return this.contextCache.get(cacheKey);
  }

  try {
    const response = await this.client.messages.create({
      model: 'claude-3-haiku-20240307', // 더 빠르고 저렴한 모델
      max_tokens: 200,
      temperature: 0.3,
      system: `YouTube Shorts 검색을 위한 키워드를 추출하세요.
반드시 다음 JSON 형식으로만 응답하세요:
{
  "keywords": ["키워드1", "키워드2", ...],
  "context": {
    "mood": "감정상태",
    "time": "시간대",
    "purpose": "목적"
  },
  "confidence": 0.0-1.0
}`,
      messages: [{
        role: 'user',
        content: `사용자 입력: "${message}"
시간: ${context.currentTime}
이전 대화: ${context.previousMessages?.join(' -> ')}`
      }]
    });

    const result = JSON.parse(response.content[0].text);

    // 캐시 저장 (5분)
    this.contextCache.set(cacheKey, result);
    setTimeout(() => this.contextCache.delete(cacheKey), 300000);

    return result;
  } catch (error) {
    this.handleAPIError(error);
  }
}

```

### 4. 예상 응답 생성

```jsx
async generateSuggestions(currentContext) {
  try {
    const response = await this.client.messages.create({
      model: 'claude-3-haiku-20240307',
      max_tokens: 150,
      temperature: 0.8,
      system: '사용자가 다음에 물어볼 만한 질문 4개를 짧게 제안하세요.',
      messages: [{
        role: 'user',
        content: `현재 대화 맥락:
사용자 입력: ${currentContext.lastMessage}
추출된 키워드: ${currentContext.keywords.join(', ')}
시간대: ${currentContext.time}
감정: ${currentContext.mood}`
      }]
    });

    // 응답을 배열로 파싱
    const suggestions = response.content[0].text
      .split('\n')
      .filter(line => line.trim())
      .slice(0, 4)
      .map(line => line.replace(/^\d+\.\s*/, ''));

    return suggestions;
  } catch (error) {
    // 에러 시 기본 제안
    return [
      "좀 더 신나는 영상 보여줘",
      "비슷한 다른 영상도 있어?",
      "이번엔 힐링되는 걸로",
      "최신 트렌드 영상 추천해줘"
    ];
  }
}

```

### 비용 최적화 전략

```jsx
class ClaudeOptimizer {
  constructor(claudeService) {
    this.claude = claudeService;
    this.dailyBudget = 50; // $50/day
    this.currentSpend = 0;
  }

  async optimizedRequest(message, context) {
    // 1. 비용 체크
    if (this.currentSpend >= this.dailyBudget) {
      throw new Error('Daily Claude API budget exceeded');
    }

    // 2. 간단한 요청은 로컬 처리
    const simpleKeywords = this.tryLocalExtraction(message);
    if (simpleKeywords) {
      return simpleKeywords;
    }

    // 3. 컨텍스트 압축
    const compressedContext = this.compressContext(context);

    // 4. 모델 선택 (복잡도에 따라)
    const model = this.selectModel(message, context);

    // 5. API 호출
    const result = await this.claude.extractKeywords(
      message,
      compressedContext
    );

    // 6. 비용 업데이트
    this.currentSpend = this.claude.costTracker.totalCost;

    return result;
  }

  tryLocalExtraction(message) {
    // 간단한 패턴 매칭
    const patterns = {
      'BTS': ['BTS', '방탄소년단', '케이팝', '댄스'],
      '요리': ['요리', '레시피', '쿠킹', '음식'],
      '운동': ['운동', '헬스', '피트니스', '홈트'],
      // ... 더 많은 패턴
    };

    for (const [key, keywords] of Object.entries(patterns)) {
      if (message.includes(key)) {
        return { keywords, confidence: 0.7 };
      }
    }
    return null;
  }
}

```

## 2.5.3 Bright Data MCP (트렌드 분석)

### Bright Data MCP 서비스 설정

### 1. MCP 서버 통합

```javascript
// bright-data-mcp-service.js
import { BrightDataMCP } from '@brightdata/mcp-server';
import { MCPClient } from '@modelcontextprotocol/sdk/client/index.js';

class TrendsService {
  constructor() {
    // Bright Data MCP 초기화
    this.brightDataMCP = new MCPClient({
      name: 'bright-data-trends',
      version: '1.0.0',
      transport: {
        command: 'npx',
        args: ['-y', '@brightdata/mcp-server']
      }
    });

    
    // 캐시 설정
    this.cache = new Map();
    this.cacheExpiry = 4 * 60 * 60 * 1000; // 4시간
    
    this.init();
  }

  async init() {
    await this.brightDataMCP.connect();
    console.log('Bright Data MCP connected successfully');
  }

  async getTrendingSearches(options = {}) {
    const cacheKey = `trending:${options.country || 'KR'}:${options.category || 'all'}`;
    const cached = this.cache.get(cacheKey);
    
    if (cached && cached.expiry > Date.now()) {
      return cached.data;
    }

    try {
      // Bright Data MCP를 통한 트렌드 수집
      const result = await this.brightDataMCP.callTool('web_search', {
        query: 'trending youtube shorts korea',
        country: 'KR',
        language: 'ko',
        filter: {
          time_range: 'past_day',
          source_type: ['google_trends', 'youtube_trending', 'social_media']
        }
      });

      // 구조화된 트렌드 데이터 추출
      const trends = await this.processWebSearchResults(result);
      
      // 캐시 저장
      this.cache.set(cacheKey, {
        data: trends,
        expiry: Date.now() + this.cacheExpiry
      });

      return trends;
    } catch (error) {
      console.error('Error fetching trends via Bright Data:', error);
      return this.getFallbackTrends();
    }
  }

  async processWebSearchResults(results) {
    const trends = [];
    
    for (const result of results.content) {
      // AI를 통한 트렌드 키워드 추출
      const extracted = await this.brightDataMCP.callTool('extract_keywords', {
        text: result.snippet,
        context: 'youtube_shorts_trends',
        language: 'ko'
      });

      trends.push({
        keyword: extracted.primary_keyword,
        related_keywords: extracted.related_keywords,
        trend_score: extracted.relevance_score,
        source: result.source,
        category: this.categorizeKeyword(extracted.primary_keyword),
        timestamp: new Date()
      });
    }

    return trends.sort((a, b) => b.trend_score - a.trend_score);
  }

  async getDetailedTrendAnalysis(keyword) {
    try {
      // 더 상세한 트렌드 분석
      const analysis = await this.brightDataMCP.callTool('analyze_trend', {
        keyword,
        metrics: ['search_volume', 'growth_rate', 'demographics', 'related_topics'],
        timeframe: '7d',
        region: 'KR'
      });

      return {
        keyword,
        search_volume: analysis.search_volume,
        growth_rate: analysis.growth_rate,
        peak_hours: analysis.peak_hours,
        demographics: analysis.demographics,
        related_videos: analysis.related_content.youtube_shorts || []
      };
    } catch (error) {
      console.error('Detailed trend analysis failed:', error);
      return null;
    }
  }
}
```

### 2. SerpAPI 통합 (백업 트렌드 소스)

```javascript
// serpapi-integration.js
import SerpApi from 'google-search-results-nodejs';

class SerpApiTrends {
  constructor() {
    this.search = new SerpApi.GoogleSearch(process.env.SERPAPI_KEY);
  }

  async getGoogleTrends() {
    return new Promise((resolve, reject) => {
      this.search.json({
        engine: 'google_trends',
        q: 'youtube shorts',
        geo: 'KR',
        hl: 'ko',
        data_type: 'TIMESERIES',
        tz: 540 // KST
      }, (data) => {
        if (data.error) {
          reject(data.error);
        } else {
          resolve(this.processGoogleTrendsData(data));
        }
      });
    });
  }

  async getYouTubeTrending() {
    return new Promise((resolve, reject) => {
      this.search.json({
        engine: 'youtube',
        search_query: 'shorts',
        sp: 'CAMSAhgB', // Shorts filter
        gl: 'kr',
        hl: 'ko'
      }, (data) => {
        if (data.error) {
          reject(data.error);
        } else {
          resolve(this.processYouTubeData(data));
        }
      });
    });
  }

  processGoogleTrendsData(data) {
    return data.interest_over_time?.map(item => ({
      keyword: item.query,
      interest: item.values[0]?.value || 0,
      timestamp: item.values[0]?.extracted_time
    })) || [];
  }

  processYouTubeData(data) {
    return data.video_results?.map(video => ({
      title: video.title,
      views: video.views,
      channel: video.channel.name,
      keywords: this.extractKeywordsFromTitle(video.title)
    })) || [];
  }

  extractKeywordsFromTitle(title) {
    // 간단한 키워드 추출 로직
    const stopWords = ['의', '를', '을', '은', '는', '이', '가'];
    return title.split(/\s+/)
      .filter(word => word.length > 1 && !stopWords.includes(word))
      .slice(0, 5);
  }
}
```

### 3. n8n 자동화 워크플로우 통합

```javascript
// n8n-automation.js
class N8nAutomation {
  constructor() {
    this.n8nUrl = process.env.N8N_WEBHOOK_URL;
    this.workflows = {
      trendCollection: process.env.N8N_TREND_WORKFLOW_ID,
      keywordAnalysis: process.env.N8N_KEYWORD_WORKFLOW_ID,
      reportGeneration: process.env.N8N_REPORT_WORKFLOW_ID
    };
  }

  async triggerTrendCollection() {
    try {
      const response = await fetch(`${this.n8nUrl}/webhook/${this.workflows.trendCollection}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          action: 'collect_trends',
          sources: ['google_trends', 'youtube_trending', 'social_media'],
          region: 'KR',
          timestamp: new Date().toISOString()
        })
      });

      return await response.json();
    } catch (error) {
      console.error('n8n workflow trigger failed:', error);
      throw error;
    }
  }

  async scheduleAutomatedReports() {
    // 매일 오전 6시 트렌드 리포트 생성
    const cronJob = {
      schedule: '0 6 * * *',
      workflow: this.workflows.reportGeneration,
      data: {
        report_type: 'daily_trends',
        recipients: ['admin@youtubeshortsai.com'],
        include_metrics: ['top_keywords', 'rising_trends', 'category_analysis']
      }
    };

    return this.createN8nSchedule(cronJob);
  }

  async createN8nSchedule(jobConfig) {
    const response = await fetch(`${this.n8nUrl}/webhook-schedule`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(jobConfig)
    });

    return await response.json();
  }
}
```

### 4. 통합 트렌드 매니저

```javascript
// integrated-trends-manager.js
class IntegratedTrendsManager {
  constructor() {
    this.brightData = new TrendsService();
    this.serpApi = new SerpApiTrends();
    this.n8n = new N8nAutomation();
    
    // 우선순위 설정
    this.sources = {
      primary: this.brightData,
      secondary: this.serpApi,
      automation: this.n8n
    };
  }

  async getTrends(options = {}) {
    let trends = [];
    
    try {
      // 1차: Bright Data MCP
      trends = await this.sources.primary.getTrendingSearches(options);
      
      if (trends.length < 10) {
        // 2차: SerpAPI로 보충
        const serpTrends = await this.sources.secondary.getGoogleTrends();
        trends = this.mergeTrends(trends, serpTrends);
      }
    } catch (error) {
      console.error('Primary trend source failed:', error);
      // 폴백: SerpAPI
      trends = await this.sources.secondary.getYouTubeTrending();
    }

    // n8n으로 수집 결과 기록
    await this.sources.automation.triggerTrendCollection();

      return trends;
  }

  mergeTrends(primary, secondary) {
    const merged = [...primary];
    const existingKeywords = new Set(primary.map(t => t.keyword.toLowerCase()));
    
    for (const trend of secondary) {
      if (!existingKeywords.has(trend.keyword.toLowerCase())) {
        merged.push(trend);
      }
    }
    
    return merged.slice(0, 20); // 상위 20개 반환
  }

  async analyzeAndCacheTrends() {
    const trends = await this.getTrends();
    
    for (const trend of trends) {
      // 상세 분석
      const analysis = await this.sources.primary.getDetailedTrendAnalysis(trend.keyword);
      
      // Supabase에 저장 (아래 Supabase MCP 섹션 참조)
      await this.saveTrendAnalysis(trend.keyword, analysis);
    }
    
    return trends;
  }
}
```

## 2.5.4 Supabase MCP (데이터베이스 관리)

### Supabase MCP 통합

### 1. Supabase MCP 클라이언트 설정

```javascript
// supabase-mcp-client.js
import { MCPClient } from '@modelcontextprotocol/sdk/client/index.js';

class SupabaseMCPService {
  constructor() {
    this.mcp = new MCPClient({
      name: 'supabase-mcp',
      version: '1.0.0',
      transport: {
        command: 'npx',
        args: [
          '-y',
          '@supabase/mcp-server-supabase@latest',
          '--access-token',
          process.env.SUPABASE_ACCESS_TOKEN,
          '--project-ref',
          process.env.SUPABASE_PROJECT_REF
        ]
      }
    });
    
    this.init();
  }

  async init() {
    await this.mcp.connect();
    console.log('Supabase MCP connected successfully');
    
    // 사용 가능한 도구 확인
    const tools = await this.mcp.listTools();
    console.log('Available Supabase tools:', tools);
  }

  // 동적 쿼리 실행
  async executeQuery(query, params = []) {
    try {
      const result = await this.mcp.callTool('execute_sql', {
        query,
        params
      });
      
      return JSON.parse(result.content[0].text);
    } catch (error) {
      console.error('Query execution failed:', error);
      throw error;
    }
  }

  // 테이블 스키마 분석
  async analyzeTableStructure(tableName) {
    const result = await this.mcp.callTool('list_tables', {
      schemas: ['public'],
      filter: tableName
    });
    
    return JSON.parse(result.content[0].text);
  }

  // 마이그레이션 적용
  async applyMigration(migrationSQL, description) {
    const result = await this.mcp.callTool('apply_migration', {
      sql: migrationSQL,
      description
    });
    
    return JSON.parse(result.content[0].text);
  }
}
```

### 2. 트렌드 분석 데이터 저장

```javascript
// trend-analysis-storage.js
class TrendAnalysisStorage {
  constructor(supabaseMCP) {
    this.supabase = supabaseMCP;
  }

  async saveTrendAnalysis(keyword, analysis) {
    const query = `
      INSERT INTO trend_analysis (
        keyword,
        search_volume,
        growth_rate,
        peak_hours,
        demographics,
        related_videos,
        source,
        analyzed_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
      ON CONFLICT (keyword, DATE(analyzed_at))
      DO UPDATE SET
        search_volume = EXCLUDED.search_volume,
        growth_rate = EXCLUDED.growth_rate,
        peak_hours = EXCLUDED.peak_hours,
        demographics = EXCLUDED.demographics,
        related_videos = EXCLUDED.related_videos,
        updated_at = NOW()
      RETURNING *;
    `;

    const params = [
      keyword,
      analysis.search_volume,
      analysis.growth_rate,
      JSON.stringify(analysis.peak_hours),
      JSON.stringify(analysis.demographics),
      JSON.stringify(analysis.related_videos),
      'bright_data_mcp',
      new Date()
    ];

    return await this.supabase.executeQuery(query, params);
  }

  async getHistoricalTrends(keyword, days = 30) {
    const query = `
      SELECT 
        keyword,
        DATE(analyzed_at) as date,
        AVG(search_volume) as avg_search_volume,
        AVG(growth_rate) as avg_growth_rate,
        JSON_AGG(peak_hours) as all_peak_hours
      FROM trend_analysis
      WHERE keyword = $1
        AND analyzed_at >= NOW() - INTERVAL '$2 days'
      GROUP BY keyword, DATE(analyzed_at)
      ORDER BY date DESC;
    `;

    return await this.supabase.executeQuery(query, [keyword, days]);
  }

  async generateTrendInsights() {
    // AI를 통한 트렌드 인사이트 생성
    const recentTrends = await this.getRecentTrends(7);
    
    const insights = await this.supabase.mcp.callTool('generate_insights', {
      data: recentTrends,
      analysis_type: 'trend_patterns',
      output_format: 'summary'
    });

    return JSON.parse(insights.content[0].text);
  }
}
```

### 3. 실시간 모니터링 및 분석

```javascript
// realtime-analytics.js
class RealtimeAnalytics {
  constructor(supabaseMCP) {
    this.supabase = supabaseMCP;
    this.monitors = new Map();
  }

  async setupRealtimeMonitoring() {
    // 검색 패턴 모니터링
    await this.monitorSearchPatterns();
    
    // 트렌드 변화 감지
    await this.monitorTrendChanges();
    
    // 사용자 행동 추적
    await this.monitorUserBehavior();
  }

  async monitorSearchPatterns() {
    const query = `
      SELECT 
        keyword,
        COUNT(*) as search_count,
        COUNT(DISTINCT user_id) as unique_users,
        DATE_TRUNC('hour', created_at) as hour
      FROM search_logs
      WHERE created_at >= NOW() - INTERVAL '24 hours'
      GROUP BY keyword, hour
      HAVING COUNT(*) >= 5
      ORDER BY search_count DESC;
    `;

    const patterns = await this.supabase.executeQuery(query);
    
    // 패턴 분석 및 캐싱 전략 수립
    for (const pattern of patterns) {
      if (pattern.search_count > 20 && !await this.isCached(pattern.keyword)) {
        await this.recommendForCaching(pattern.keyword);
      }
    }
  }

  async monitorTrendChanges() {
    const query = `
      WITH trend_comparison AS (
        SELECT 
          t1.keyword,
          t1.trend_score as current_score,
          t2.trend_score as previous_score,
          ((t1.trend_score - t2.trend_score) / NULLIF(t2.trend_score, 0)) * 100 as growth_rate
        FROM trending_keywords t1
        LEFT JOIN trending_keywords t2 
          ON t1.keyword = t2.keyword 
          AND t2.created_at = t1.created_at - INTERVAL '1 day'
        WHERE t1.created_at >= CURRENT_DATE
      )
      SELECT * FROM trend_comparison
      WHERE ABS(growth_rate) > 50
      ORDER BY growth_rate DESC;
    `;

    const changes = await this.supabase.executeQuery(query);
    return this.analyzeSignificantChanges(changes);
  }
}
```

## 2.5.5 API 할당량 관리

### 통합 할당량 관리 시스템

### 1. 할당량 매니저 구현

```jsx
// quota-manager.js
class QuotaManager {
  constructor() {
    this.quotas = {
      youtube: {
        daily: 10000,
        distribution: {
          popular_keywords: 3000,      // 30% - 인기 키워드 (30일 주기)
          trending_keywords: 1000,     // 10% - Bright Data MCP 실시간 트렌드
          user_search_patterns: 1000,  // 10% - 사용자 검색 패턴
          hourly_trends: 1000,        // 10% - 시간대별 트렌드
          premium_realtime: 2500,     // 25% - 프리미엄 실시간
          emergency_buffer: 1500      // 15% - 긴급 상황
        },
        used: {},
        resetTime: null
      },
      claude: {
        daily_budget: 50, // $50
        used: 0,
        requests: {
          free_tier: 10,    // 무료 사용자 일일 제한
          premium: 1000     // 프리미엄 무제한
        }
      }
    };

    this.initializeQuotas();
  }

  async allocateYouTubeQuota(category, units) {
    const quota = this.quotas.youtube;

    // 카테고리별 한도 체크
    const categoryLimit = quota.distribution[category];
    const categoryUsed = quota.used[category] || 0;

    if (categoryUsed + units > categoryLimit) {
      // 긴급 버퍼에서 차용
      const bufferAvailable = quota.distribution.emergency_buffer -
                            (quota.used.emergency_buffer || 0);

      if (bufferAvailable >= units) {
        quota.used.emergency_buffer = (quota.used.emergency_buffer || 0) + units;
        console.log(`Borrowed ${units} units from emergency buffer for ${category}`);
      } else {
        throw new Error(`Quota exceeded for category: ${category}`);
      }
    } else {
      quota.used[category] = categoryUsed + units;
    }

    // 전체 사용량 업데이트
    const totalUsed = Object.values(quota.used).reduce((a, b) => a + b, 0);

    // 데이터베이스에 기록
    await this.logQuotaUsage('youtube', category, units, totalUsed);

    return {
      category,
      used: quota.used[category],
      limit: categoryLimit,
      total_used: totalUsed,
      total_limit: quota.daily
    };
  }

```

### 2. 스마트 캐싱 전략

```jsx
class SmartCacheManager {
  constructor(quotaManager) {
    this.quotaManager = quotaManager;
    this.cacheDB = {}; // Supabase 연동
  }

  async executeCachingStrategy() {
    console.log('Starting daily caching strategy...');

    // 1. 인기 키워드 캐싱 (30일 주기)
    await this.cachePopularKeywords();

    // 2. 실시간 트렌드 캐싱 (4시간 주기)
    await this.cacheTrendingKeywords();

    // 3. 사용자 패턴 기반 캐싱 (일일)
    await this.cacheUserPatterns();

    // 4. 시간대별 캐싱 (2시간 주기)
    await this.cacheHourlyTrends();
  }

  async cachePopularKeywords() {
    try {
      // 지난 30일 인기 키워드 조회
      const popularKeywords = await this.getPopularKeywords(30);

      for (const keyword of popularKeywords) {
        // 이미 캐시되어 있는지 확인
        const cached = await this.isCached(keyword);
        if (cached && !this.isExpired(cached)) continue;

        // YouTube API 호출
        await this.quotaManager.allocateYouTubeQuota('popular_keywords', 101);
        const videos = await youtube.searchShorts(keyword);

        // 캐시 저장
        await this.saveCache(keyword, videos, 30 * 24 * 60 * 60); // 30일
      }
    } catch (error) {
      console.error('Popular keywords caching failed:', error);
    }
  }

  async cacheTrendingKeywords() {
    try {
      // Bright Data MCP에서 실시간 트렌드 가져오기
      const trends = await trendsConnector.getRealTimeTrends();

      for (const trend of trends.slice(0, 10)) { // 상위 10개만
        await this.quotaManager.allocateYouTubeQuota('trending_keywords', 101);
        const videos = await youtube.searchShorts(trend.keyword);

        // 4시간 캐시
        await this.saveCache(trend.keyword, videos, 4 * 60 * 60);
      }
    } catch (error) {
      console.error('Trending keywords caching failed:', error);
    }
  }

  async cacheUserPatterns() {
    try {
      // 최근 24시간 사용자 검색 패턴 분석
      const patterns = await this.analyzeUserSearchPatterns();

      // 자주 검색되지만 캐시되지 않은 키워드
      const uncachedPopular = patterns.filter(p =>
        p.search_count > 10 && !this.isCached(p.keyword)
      );

      for (const pattern of uncachedPopular.slice(0, 10)) {
        await this.quotaManager.allocateYouTubeQuota('user_search_patterns', 101);
        const videos = await youtube.searchShorts(pattern.keyword);

        // 24시간 캐시
        await this.saveCache(pattern.keyword, videos, 24 * 60 * 60);
      }
    } catch (error) {
      console.error('User pattern caching failed:', error);
    }
  }
}

```

### 3. 할당량 모니터링 대시보드

```jsx
class QuotaMonitor {
  async getQuotaStatus() {
    const youtube = await this.getYouTubeQuotaStatus();
    const claude = await this.getClaudeQuotaStatus();

    return {
      timestamp: new Date(),
      youtube: {
        total_limit: 10000,
        total_used: youtube.total_used,
        percentage_used: (youtube.total_used / 10000) * 100,
        by_category: youtube.by_category,
        reset_in: youtube.reset_in,
        projected_usage: this.projectUsage(youtube),
        warnings: this.checkWarnings(youtube)
      },
      claude: {
        budget_limit: 50,
        budget_used: claude.budget_used,
        percentage_used: (claude.budget_used / 50) * 100,
        avg_cost_per_request: claude.avg_cost,
        projected_daily_cost: claude.projected_cost
      }
    };
  }

  projectUsage(current) {
    // 현재 사용 속도로 하루 종료 시 예상 사용량
    const hoursElapsed = (new Date() - current.reset_time) / (1000 * 60 * 60);
    const rate = current.total_used / hoursElapsed;
    return Math.round(rate * 24);
  }

  checkWarnings(status) {
    const warnings = [];

    // 전체 사용량 경고
    if (status.percentage_used > 80) {
      warnings.push({
        level: 'critical',
        message: `YouTube quota ${status.percentage_used}% used`
      });
    }

    // 카테고리별 경고
    for (const [category, used] of Object.entries(status.by_category)) {
      const limit = this.quotas.youtube.distribution[category];
      if (used / limit > 0.9) {
        warnings.push({
          level: 'warning',
          message: `${category} quota 90% used`
        });
      }
    }

    return warnings;
  }
}

```

### 4. 할당량 초과 시 폴백 전략

```jsx
class QuotaFallbackStrategy {
  async handleQuotaExceeded(request) {
    const { type, keyword, user } = request;

    // 1. 캐시 확인
    const cached = await this.checkCache(keyword);
    if (cached) {
      return { source: 'cache', data: cached };
    }

    // 2. 유사 키워드 캐시 확인
    const similar = await this.findSimilarCached(keyword);
    if (similar) {
      return { source: 'similar_cache', data: similar };
    }

    // 3. 프리미엄 사용자는 긴급 버퍼 사용
    if (user.tier === 'premium') {
      try {
        await this.quotaManager.allocateYouTubeQuota('emergency_buffer', 101);
        const data = await youtube.searchShorts(keyword);
        return { source: 'emergency', data };
      } catch (e) {
        // 긴급 버퍼도 소진
      }
    }

    // 4. 기본 추천 제공
    const defaults = await this.getDefaultRecommendations(keyword);
    return {
      source: 'default',
      data: defaults,
      message: 'API 할당량 초과로 캐시된 인기 영상을 제공합니다.'
    };
  }

  async findSimilarCached(keyword) {
    // 편집 거리 계산으로 유사 키워드 찾기
    const allCached = await this.getAllCachedKeywords();

    const similar = allCached
      .map(k => ({
        keyword: k,
        distance: this.levenshteinDistance(keyword, k)
      }))
      .filter(k => k.distance <= 2)
      .sort((a, b) => a.distance - b.distance);

    if (similar.length > 0) {
      return await this.getCache(similar[0].keyword);
    }

    return null;
  }
}

```

### 외부 서비스 통합 모니터링

```jsx
class ExternalServiceMonitor {
  constructor() {
    this.services = {
      youtube: { status: 'healthy', lastCheck: null },
      claude: { status: 'healthy', lastCheck: null },
      brightData: { status: 'healthy', lastCheck: null },
      serpApi: { status: 'healthy', lastCheck: null }
    };
  }

  async healthCheck() {
    const checks = await Promise.allSettled([
      this.checkYouTube(),
      this.checkClaude(),
      this.checkBrightData(),
      this.checkSerpApi()
    ]);

    return {
      timestamp: new Date(),
      services: this.services,
      overall: Object.values(this.services).every(s => s.status === 'healthy')
        ? 'healthy' : 'degraded'
    };
  }

  async checkYouTube() {
    try {
      const start = Date.now();
      await youtube.youtube.videos.list({
        part: 'snippet',
        id: 'dQw4w9WgXcQ' // 테스트용 비디오
      });

      const latency = Date.now() - start;
      this.services.youtube = {
        status: 'healthy',
        latency,
        lastCheck: new Date()
      };
    } catch (error) {
      this.services.youtube = {
        status: 'unhealthy',
        error: error.message,
        lastCheck: new Date()
      };
    }
  }
}

```

## 2.6: 모바일 앱 전략 (Mobile App Strategy)

## 2.6.1 Capacitor 설정

### 프로젝트 초기화

```bash
# Capacitor 설치
npm install @capacitor/core @capacitor/cli

# 프로젝트 초기화
npx cap init "YouTube Shorts Curator" "com.yourcompany.shortscurator" --web-dir=frontend/dist

# 플랫폼 추가
npx cap add android
npx cap add ios

```

### Capacitor 설정 파일

```tsx
// capacitor.config.ts
import { CapacitorConfig } from '@capacitor/cli';

const config: CapacitorConfig = {
  appId: 'com.yourcompany.shortscurator',
  appName: 'Shorts Curator',
  webDir: 'frontend/dist',
  server: {
    androidScheme: 'https',
    iosScheme: 'https',
    hostname: 'shortscurator.app',
    url: process.env.NODE_ENV === 'development'
      ? 'http://localhost:3000'
      : undefined
  },
  plugins: {
    SplashScreen: {
      launchShowDuration: 2000,
      backgroundColor: '#000000',
      androidScaleType: 'CENTER_CROP',
      showSpinner: false,
      splashFullScreen: true,
      splashImmersive: true
    },
    Keyboard: {
      resize: 'body',
      style: 'dark'
    },
    StatusBar: {
      style: 'dark',
      backgroundColor: '#000000'
    }
  },
  android: {
    allowMixedContent: false,
    captureInput: true,
    webContentsDebuggingEnabled: false
  },
  ios: {
    contentInset: 'automatic',
    limitsNavigationsGestureDistance: 25
  }
};

export default config;

```

### 빌드 스크립트 설정

```json
// package.json
{
  "scripts": {
    "build:web": "webpack --mode production",
    "build:mobile": "npm run build:web && npx cap sync",
    "android": "npm run build:mobile && npx cap open android",
    "ios": "npm run build:mobile && npx cap open ios",
    "android:dev": "npm run build:web && npx cap copy android && npx cap run android",
    "ios:dev": "npm run build:web && npx cap copy ios && npx cap run ios"
  }
}

```

## 2.6.2 네이티브 기능 활용

### 필수 플러그인 설치

```bash
# 네트워크 상태
npm install @capacitor/network

# 로컬 알림
npm install @capacitor/local-notifications

# 앱 상태
npm install @capacitor/app

# 햅틱 피드백
npm install @capacitor/haptics

# 공유 기능
npm install @capacitor/share

# 브라우저 (외부 링크)
npm install @capacitor/browser

# 저장소
npm install @capacitor/preferences

```

### 네이티브 기능 구현

### 1. 네트워크 상태 관리

```jsx
// network-manager.js
import { Network } from '@capacitor/network';

class NetworkManager {
  constructor() {
    this.isOnline = true;
    this.connectionType = 'unknown';
    this.listeners = [];
    this.init();
  }

  async init() {
    // 초기 상태 확인
    const status = await Network.getStatus();
    this.isOnline = status.connected;
    this.connectionType = status.connectionType;

    // 네트워크 상태 변경 리스너
    Network.addListener('networkStatusChange', status => {
      this.isOnline = status.connected;
      this.connectionType = status.connectionType;

      // 오프라인 → 온라인 전환 시
      if (status.connected && !this.wasOnline) {
        this.handleReconnection();
      }

      this.wasOnline = status.connected;
      this.notifyListeners(status);
    });
  }

  handleReconnection() {
    // 대기 중인 요청 재시도
    if (window.pendingRequests) {
      window.pendingRequests.forEach(request => {
        request.retry();
      });
      window.pendingRequests = [];
    }

    // 캐시 동기화
    this.syncOfflineData();
  }

  async syncOfflineData() {
    const offlineInteractions = await this.getOfflineInteractions();

    for (const interaction of offlineInteractions) {
      try {
        await api.syncInteraction(interaction);
        await this.removeOfflineInteraction(interaction.id);
      } catch (error) {
        console.error('Sync failed:', error);
      }
    }
  }
}

```

### 2. 푸시 알림 구현

```jsx
// notification-service.js
import { LocalNotifications } from '@capacitor/local-notifications';

class NotificationService {
  async init() {
    // 권한 요청
    const permission = await LocalNotifications.requestPermissions();

    if (permission.display === 'granted') {
      // 알림 채널 생성 (Android)
      await LocalNotifications.createChannel({
        id: 'trends',
        name: 'Trending Updates',
        description: 'New trending Shorts notifications',
        importance: 3,
        visibility: 1,
        sound: 'notification.wav'
      });

      // 알림 클릭 리스너
      LocalNotifications.addListener('localNotificationActionPerformed',
        notification => {
          this.handleNotificationClick(notification);
        }
      );
    }
  }

  async scheduleTrendNotification() {
    const notifications = [{
      id: 1,
      title: '🔥 새로운 트렌드',
      body: '지금 가장 핫한 Shorts를 확인해보세요!',
      schedule: {
        at: new Date(Date.now() + 1000 * 60 * 60 * 4), // 4시간 후
        repeats: true,
        every: 'hour',
        count: 6 // 하루 6번
      },
      channelId: 'trends'
    }];

    await LocalNotifications.schedule({ notifications });
  }

  async notifyWatchTime(minutes) {
    if (minutes >= 30) {
      await LocalNotifications.schedule({
        notifications: [{
          id: 999,
          title: '⏰ 시청 시간 알림',
          body: `${minutes}분 동안 시청하셨어요. 잠시 쉬어가는 건 어때요?`,
          channelId: 'reminder'
        }]
      });
    }
  }
}

```

### 3. 햅틱 피드백

```jsx
// haptic-service.js
import { Haptics, ImpactStyle } from '@capacitor/haptics';

class HapticService {
  async light() {
    await Haptics.impact({ style: ImpactStyle.Light });
  }

  async medium() {
    await Haptics.impact({ style: ImpactStyle.Medium });
  }

  async heavy() {
    await Haptics.impact({ style: ImpactStyle.Heavy });
  }

  async success() {
    await Haptics.notification({ type: 'success' });
  }

  async error() {
    await Haptics.notification({ type: 'error' });
  }

  // UI 인터랙션별 햅틱
  async onLike() {
    await this.medium();
  }

  async onVideoSwipe() {
    await this.light();
  }

  async onKeywordSelect() {
    await this.light();
  }
}

```

### 4. 공유 기능

```jsx
// share-service.js
import { Share } from '@capacitor/share';

class ShareService {
  async shareVideo(video) {
    const shareOptions = {
      title: video.title,
      text: `"${video.title}" - YouTube Shorts 추천`,
      url: `https://youtube.com/shorts/${video.videoId}`,
      dialogTitle: '친구에게 공유하기'
    };

    try {
      const result = await Share.share(shareOptions);

      if (result.activityType) {
        // 공유 완료 추적
        await this.trackShare(video.videoId, result.activityType);
      }
    } catch (error) {
      console.error('Share failed:', error);
    }
  }

  async shareKeywordList(keywords) {
    const text = keywords.map(k => `#${k}`).join(' ');

    await Share.share({
      title: '오늘의 추천 키워드',
      text: `오늘의 YouTube Shorts 추천 키워드\n\n${text}\n\nShorts Curator 앱에서 더 많은 영상을 만나보세요!`,
      dialogTitle: '키워드 공유'
    });
  }
}

```

### 5. 로컬 저장소

```jsx
// storage-service.js
import { Preferences } from '@capacitor/preferences';

class StorageService {
  async saveUserPreferences(preferences) {
    await Preferences.set({
      key: 'user_preferences',
      value: JSON.stringify(preferences)
    });
  }

  async getUserPreferences() {
    const { value } = await Preferences.get({ key: 'user_preferences' });
    return value ? JSON.parse(value) : null;
  }

  async saveOfflineCache(keyword, videos) {
    const cache = await this.getOfflineCache();
    cache[keyword] = {
      videos,
      cachedAt: Date.now(),
      expiresAt: Date.now() + (24 * 60 * 60 * 1000) // 24시간
    };

    await Preferences.set({
      key: 'offline_cache',
      value: JSON.stringify(cache)
    });
  }

  async getOfflineCache() {
    const { value } = await Preferences.get({ key: 'offline_cache' });
    return value ? JSON.parse(value) : {};
  }

  async saveWatchHistory(video) {
    const history = await this.getWatchHistory();
    history.unshift({
      ...video,
      watchedAt: Date.now()
    });

    // 최대 100개 유지
    if (history.length > 100) {
      history = history.slice(0, 100);
    }

    await Preferences.set({
      key: 'watch_history',
      value: JSON.stringify(history)
    });
  }
}

```

### 모바일 최적화 UI 컴포넌트

### 1. 네이티브 스타일 하단 탭바

```jsx
// bottom-tabbar.js
class BottomTabBar extends Component {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    this.render();
    this.addEventListeners();
  }

  render() {
    this.shadowRoot.innerHTML = `
      <style>
        :host {
          position: fixed;
          bottom: 0;
          left: 0;
          right: 0;
          background: var(--bg-primary);
          border-top: 1px solid var(--border-color);
          z-index: 1000;
        }

        .tab-bar {
          display: flex;
          height: 56px;
          padding-bottom: env(safe-area-inset-bottom);
        }

        .tab-item {
          flex: 1;
          display: flex;
          flex-direction: column;
          align-items: center;
          justify-content: center;
          padding: 8px;
          cursor: pointer;
          transition: all 0.2s;
        }

        .tab-item.active {
          color: var(--primary-color);
        }

        .tab-icon {
          width: 24px;
          height: 24px;
          margin-bottom: 4px;
        }

        .tab-label {
          font-size: 11px;
          font-weight: 500;
        }

        /* iOS 스타일 안전 영역 */
        @supports (padding: max(0px)) {
          .tab-bar {
            padding-bottom: max(8px, env(safe-area-inset-bottom));
          }
        }
      </style>

      <nav class="tab-bar">
        <div class="tab-item active" data-tab="home">
          <svg class="tab-icon"><!-- 홈 아이콘 --></svg>
          <span class="tab-label">홈</span>
        </div>
        <div class="tab-item" data-tab="trending">
          <svg class="tab-icon"><!-- 트렌드 아이콘 --></svg>
          <span class="tab-label">트렌드</span>
        </div>
        <div class="tab-item" data-tab="chat">
          <svg class="tab-icon"><!-- 채팅 아이콘 --></svg>
          <span class="tab-label">AI 검색</span>
        </div>
        <div class="tab-item" data-tab="profile">
          <svg class="tab-icon"><!-- 프로필 아이콘 --></svg>
          <span class="tab-label">내 정보</span>
        </div>
      </nav>
    `;
  }

  addEventListeners() {
    this.shadowRoot.querySelectorAll('.tab-item').forEach(tab => {
      tab.addEventListener('click', async (e) => {
        // 햅틱 피드백
        await hapticService.light();

        // 탭 변경
        this.setActiveTab(tab.dataset.tab);

        // 라우팅
        this.dispatchEvent(new CustomEvent('tab-change', {
          detail: { tab: tab.dataset.tab }
        }));
      });
    });
  }
}

customElements.define('bottom-tabbar', BottomTabBar);

```

### 2. 스와이프 제스처 처리

```jsx
// swipe-handler.js
class SwipeHandler {
  constructor(element) {
    this.element = element;
    this.threshold = 50;
    this.restraint = 100;
    this.allowedTime = 300;

    this.init();
  }

  init() {
    let startX, startY, startTime;

    this.element.addEventListener('touchstart', (e) => {
      startX = e.touches[0].pageX;
      startY = e.touches[0].pageY;
      startTime = Date.now();
    }, { passive: true });

    this.element.addEventListener('touchend', async (e) => {
      const endX = e.changedTouches[0].pageX;
      const endY = e.changedTouches[0].pageY;
      const endTime = Date.now();

      const distX = endX - startX;
      const distY = endY - startY;
      const elapsedTime = endTime - startTime;

      if (elapsedTime <= this.allowedTime) {
        if (Math.abs(distX) >= this.threshold &&
            Math.abs(distY) <= this.restraint) {
          // 수평 스와이프
          if (distX > 0) {
            await this.onSwipeRight();
          } else {
            await this.onSwipeLeft();
          }
        } else if (Math.abs(distY) >= this.threshold &&
                   Math.abs(distX) <= this.restraint) {
          // 수직 스와이프
          if (distY > 0) {
            await this.onSwipeDown();
          } else {
            await this.onSwipeUp();
          }
        }
      }
    }, { passive: true });
  }

  async onSwipeUp() {
    await hapticService.light();
    this.element.dispatchEvent(new CustomEvent('swipe-up'));
  }

  async onSwipeDown() {
    await hapticService.light();
    this.element.dispatchEvent(new CustomEvent('swipe-down'));
  }
}

```

## 2.6.3 빌드 및 배포

### Android 빌드 설정

### 1. build.gradle 설정

```
// android/app/build.gradle
android {
    compileSdkVersion 33

    defaultConfig {
        applicationId "com.yourcompany.shortscurator"
        minSdkVersion 21
        targetSdkVersion 33
        versionCode 1
        versionName "1.0.0"

        testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner"
    }

    buildTypes {
        release {
            minifyEnabled true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'),
                         'proguard-rules.pro'

            // 서명 설정
            signingConfig signingConfigs.release
        }
    }

    signingConfigs {
        release {
            storeFile file(RELEASE_STORE_FILE)
            storePassword RELEASE_STORE_PASSWORD
            keyAlias RELEASE_KEY_ALIAS
            keyPassword RELEASE_KEY_PASSWORD
        }
    }
}

dependencies {
    implementation 'androidx.appcompat:appcompat:1.6.1'
    implementation 'androidx.core:core-splashscreen:1.0.1'
}

```

### 2. AndroidManifest.xml

```xml
<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.yourcompany.shortscurator">

    <!-- 권한 -->
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.VIBRATE" />

    <application
        android:allowBackup="true"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/AppTheme"
        android:usesCleartextTraffic="false">

        <activity
            android:name=".MainActivity"
            android:exported="true"
            android:launchMode="singleTask"
            android:theme="@style/AppTheme.NoActionBarLaunch">

            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>

            <!-- 딥링크 -->
            <intent-filter>
                <action android:name="android.intent.action.VIEW" />
                <category android:name="android.intent.category.DEFAULT" />
                <category android:name="android.intent.category.BROWSABLE" />
                <data android:scheme="shortscurator" android:host="video" />
            </intent-filter>
        </activity>
    </application>
</manifest>

```

### iOS 빌드 설정

### 1. Info.plist

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN"
         "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>CFBundleDevelopmentRegion</key>
    <string>ko_KR</string>
    <key>CFBundleDisplayName</key>
    <string>Shorts Curator</string>
    <key>CFBundleIdentifier</key>
    <string>$(PRODUCT_BUNDLE_IDENTIFIER)</string>
    <key>CFBundleName</key>
    <string>$(PRODUCT_NAME)</string>
    <key>CFBundleShortVersionString</key>
    <string>1.0.0</string>
    <key>CFBundleVersion</key>
    <string>1</string>

    <!-- 권한 설명 -->
    <key>NSUserTrackingUsageDescription</key>
    <string>맞춤형 콘텐츠 추천을 위해 사용됩니다</string>

    <!-- URL Schemes -->
    <key>CFBundleURLTypes</key>
    <array>
        <dict>
            <key>CFBundleURLSchemes</key>
            <array>
                <string>shortscurator</string>
            </array>
        </dict>
    </array>

    <!-- 상태바 스타일 -->
    <key>UIStatusBarStyle</key>
    <string>UIStatusBarStyleDarkContent</string>
    <key>UIViewControllerBasedStatusBarAppearance</key>
    <false/>
</dict>
</plist>

```

### 2. Podfile

```ruby
platform :ios, '13.0'
use_frameworks!

def capacitor_pods
  pod 'Capacitor', :path => '../../node_modules/@capacitor/ios'
  pod 'CapacitorCordova', :path => '../../node_modules/@capacitor/ios'
  pod 'CapacitorNetwork', :path => '../../node_modules/@capacitor/network'
  pod 'CapacitorLocalNotifications', :path => '../../node_modules/@capacitor/local-notifications'
  pod 'CapacitorApp', :path => '../../node_modules/@capacitor/app'
  pod 'CapacitorHaptics', :path => '../../node_modules/@capacitor/haptics'
  pod 'CapacitorShare', :path => '../../node_modules/@capacitor/share'
  pod 'CapacitorBrowser', :path => '../../node_modules/@capacitor/browser'
  pod 'CapacitorPreferences', :path => '../../node_modules/@capacitor/preferences'
end

target 'App' do
  capacitor_pods
end

```

### 배포 자동화

### 1. GitHub Actions 워크플로우

```yaml
# .github/workflows/mobile-build.yml
name: Mobile Build and Deploy

on:
  push:
    tags:
      - 'v*'

jobs:
  android-build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install dependencies
        run: |
          npm ci
          npm run build:mobile

      - name: Setup JDK
        uses: actions/setup-java@v3
        with:
          java-version: '11'
          distribution: 'temurin'

      - name: Build Android
        run: |
          cd android
          ./gradlew assembleRelease

      - name: Sign APK
        uses: r0adkll/sign-android-release@v1
        with:
          releaseDirectory: android/app/build/outputs/apk/release
          signingKeyBase64: ${{ secrets.SIGNING_KEY }}
          alias: ${{ secrets.ALIAS }}
          keyStorePassword: ${{ secrets.KEY_STORE_PASSWORD }}
          keyPassword: ${{ secrets.KEY_PASSWORD }}

      - name: Upload to Play Store
        uses: r0adkll/upload-google-play@v1
        with:
          serviceAccountJsonPlainText: ${{ secrets.SERVICE_ACCOUNT_JSON }}
          packageName: com.yourcompany.shortscurator
          releaseFiles: android/app/build/outputs/apk/release/app-release-signed.apk
          track: internal

  ios-build:
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Install dependencies
        run: |
          npm ci
          npm run build:mobile

      - name: Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.0'
          bundler-cache: true

      - name: Install pods
        run: |
          cd ios/App
          pod install

      - name: Build iOS
        run: |
          cd ios/App
          xcodebuild -workspace App.xcworkspace \
                     -scheme App \
                     -configuration Release \
                     -archivePath build/App.xcarchive \
                     archive

      - name: Export IPA
        run: |
          cd ios/App
          xcodebuild -exportArchive \
                     -archivePath build/App.xcarchive \
                     -exportPath build \
                     -exportOptionsPlist ExportOptions.plist

      - name: Upload to TestFlight
        uses: apple-actions/upload-testflight-build@v1
        with:
          app-path: ios/App/build/App.ipa
          issuer-id: ${{ secrets.APPSTORE_ISSUER_ID }}
          api-key-id: ${{ secrets.APPSTORE_API_KEY_ID }}
          api-private-key: ${{ secrets.APPSTORE_API_PRIVATE_KEY }}

```

### 2. 버전 관리 스크립트

```jsx
// scripts/version-bump.js
const fs = require('fs');
const path = require('path');

function bumpVersion(type = 'patch') {
  // package.json
  const packagePath = path.join(__dirname, '../package.json');
  const package = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
  const [major, minor, patch] = package.version.split('.').map(Number);

  let newVersion;
  switch (type) {
    case 'major':
      newVersion = `${major + 1}.0.0`;
      break;
    case 'minor':
      newVersion = `${major}.${minor + 1}.0`;
      break;
    default:
      newVersion = `${major}.${minor}.${patch + 1}`;
  }

  package.version = newVersion;
  fs.writeFileSync(packagePath, JSON.stringify(package, null, 2));

  // Android
  const gradlePath = path.join(__dirname, '../android/app/build.gradle');
  let gradle = fs.readFileSync(gradlePath, 'utf8');
  gradle = gradle.replace(/versionName "[\d.]+"/, `versionName "${newVersion}"`);
  const versionCode = parseInt(gradle.match(/versionCode (\d+)/)[1]) + 1;
  gradle = gradle.replace(/versionCode \d+/, `versionCode ${versionCode}`);
  fs.writeFileSync(gradlePath, gradle);

  // iOS
  const plistPath = path.join(__dirname, '../ios/App/App/Info.plist');
  let plist = fs.readFileSync(plistPath, 'utf8');
  plist = plist.replace(
    /<key>CFBundleShortVersionString<\/key>\s*<string>[\d.]+<\/string>/,
    `<key>CFBundleShortVersionString</key>\n\t<string>${newVersion}</string>`
  );
  const buildNumber = parseInt(plist.match(/<key>CFBundleVersion<\/key>\s*<string>(\d+)<\/string>/)[1]) + 1;
  plist = plist.replace(
    /<key>CFBundleVersion<\/key>\s*<string>\d+<\/string>/,
    `<key>CFBundleVersion</key>\n\t<string>${buildNumber}</string>`
  );
  fs.writeFileSync(plistPath, plist);

  console.log(`Version bumped to ${newVersion}`);
  console.log(`Android versionCode: ${versionCode}`);
  console.log(`iOS build number: ${buildNumber}`);
}

bumpVersion(process.argv[2]);

```