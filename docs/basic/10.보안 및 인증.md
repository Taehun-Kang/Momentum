# 보안 및 인증 (Security & Authentication)

## 10.1 인증 시스템

### 10.1.1 Supabase Auth 구현

### 백엔드 인증 설정

```jsx
// config/supabaseAuth.js
const { createClient } = require('@supabase/supabase-js');
const jwt = require('jsonwebtoken');

class SupabaseAuthService {
  constructor() {
    this.supabase = createClient(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_ANON_KEY,
      {
        auth: {
          autoRefreshToken: true,
          persistSession: true,
          detectSessionInUrl: true
        }
      }
    );

    // 서비스 역할 클라이언트 (관리자 작업용)
    this.supabaseAdmin = createClient(
      process.env.SUPABASE_URL,
      process.env.SUPABASE_SERVICE_ROLE_KEY
    );
  }

  // 사용자 등록
  async signUp(email, password, metadata = {}) {
    try {
      const { data, error } = await this.supabase.auth.signUp({
        email,
        password,
        options: {
          data: {
            name: metadata.name,
            avatar_url: metadata.avatar_url,
            preferences: metadata.preferences || {}
          },
          emailRedirectTo: `${process.env.APP_URL}/auth/callback`
        }
      });

      if (error) throw error;

      // 사용자 프로필 생성
      await this.createUserProfile(data.user);

      return {
        success: true,
        user: data.user,
        session: data.session,
        needsEmailVerification: true
      };
    } catch (error) {
      console.error('SignUp Error:', error);
      throw error;
    }
  }

  // 사용자 로그인
  async signIn(email, password) {
    try {
      const { data, error } = await this.supabase.auth.signInWithPassword({
        email,
        password
      });

      if (error) throw error;

      // 로그인 이력 기록
      await this.logUserActivity(data.user.id, 'login');

      // 세션 토큰 생성
      const customToken = this.generateCustomToken(data.user);

      return {
        success: true,
        user: data.user,
        session: data.session,
        customToken
      };
    } catch (error) {
      console.error('SignIn Error:', error);
      throw error;
    }
  }

  // 소셜 로그인
  async signInWithProvider(provider) {
    try {
      const { data, error } = await this.supabase.auth.signInWithOAuth({
        provider,
        options: {
          redirectTo: `${process.env.APP_URL}/auth/callback`,
          scopes: this.getProviderScopes(provider)
        }
      });

      if (error) throw error;

      return {
        success: true,
        url: data.url
      };
    } catch (error) {
      console.error('Social SignIn Error:', error);
      throw error;
    }
  }

  // 토큰 검증
  async verifyToken(token) {
    try {
      const { data, error } = await this.supabase.auth.getUser(token);

      if (error) throw error;

      return {
        valid: true,
        user: data.user
      };
    } catch (error) {
      return {
        valid: false,
        error: error.message
      };
    }
  }

  // 리프레시 토큰
  async refreshToken(refreshToken) {
    try {
      const { data, error } = await this.supabase.auth.refreshSession({
        refresh_token: refreshToken
      });

      if (error) throw error;

      return {
        success: true,
        session: data.session
      };
    } catch (error) {
      console.error('Refresh Token Error:', error);
      throw error;
    }
  }

  // 로그아웃
  async signOut(userId) {
    try {
      const { error } = await this.supabase.auth.signOut();

      if (error) throw error;

      // 로그아웃 이력 기록
      await this.logUserActivity(userId, 'logout');

      // 관련 캐시 삭제
      await this.clearUserCache(userId);

      return { success: true };
    } catch (error) {
      console.error('SignOut Error:', error);
      throw error;
    }
  }

  // 비밀번호 재설정 요청
  async resetPassword(email) {
    try {
      const { data, error } = await this.supabase.auth.resetPasswordForEmail(
        email,
        {
          redirectTo: `${process.env.APP_URL}/auth/reset-password`
        }
      );

      if (error) throw error;

      return {
        success: true,
        message: '비밀번호 재설정 이메일을 전송했습니다.'
      };
    } catch (error) {
      console.error('Reset Password Error:', error);
      throw error;
    }
  }

  // 사용자 프로필 생성
  async createUserProfile(user) {
    try {
      const { error } = await this.supabaseAdmin
        .from('users')
        .insert({
          id: user.id,
          email: user.email,
          name: user.user_metadata.name,
          avatar_url: user.user_metadata.avatar_url,
          user_tier: 'free',
          created_at: new Date().toISOString()
        });

      if (error && error.code !== '23505') { // 중복 키 에러 무시
        throw error;
      }
    } catch (error) {
      console.error('Create Profile Error:', error);
    }
  }

  // 커스텀 토큰 생성
  generateCustomToken(user) {
    const payload = {
      sub: user.id,
      email: user.email,
      role: user.role || 'user',
      tier: user.user_metadata.tier || 'free',
      iat: Math.floor(Date.now() / 1000),
      exp: Math.floor(Date.now() / 1000) + (60 * 60 * 24) // 24시간
    };

    return jwt.sign(payload, process.env.JWT_SECRET);
  }

  // 프로바이더별 스코프 설정
  getProviderScopes(provider) {
    const scopes = {
      google: 'email profile',
      github: 'read:user user:email',
      facebook: 'email public_profile'
    };

    return scopes[provider] || '';
  }

  // 사용자 활동 로깅
  async logUserActivity(userId, action) {
    try {
      await this.supabaseAdmin
        .from('user_activity_logs')
        .insert({
          user_id: userId,
          action,
          ip_address: this.getClientIP(),
          user_agent: this.getUserAgent(),
          created_at: new Date().toISOString()
        });
    } catch (error) {
      console.error('Log Activity Error:', error);
    }
  }

  // 사용자 캐시 삭제
  async clearUserCache(userId) {
    const cacheService = require('../services/cacheService');
    await cacheService.deletePattern(`user:${userId}:*`);
  }

  // 클라이언트 IP 가져오기 (Express 요청 객체에서)
  getClientIP(req) {
    return req?.ip ||
           req?.headers['x-forwarded-for']?.split(',')[0] ||
           req?.connection?.remoteAddress ||
           'unknown';
  }

  // User Agent 가져오기
  getUserAgent(req) {
    return req?.headers['user-agent'] || 'unknown';
  }
}

module.exports = new SupabaseAuthService();

```

### Express 인증 미들웨어

```jsx
// middleware/auth.js
const supabaseAuth = require('../config/supabaseAuth');
const jwt = require('jsonwebtoken');

class AuthMiddleware {
  // JWT 토큰 검증 미들웨어
  async verifyToken(req, res, next) {
    try {
      const authHeader = req.headers.authorization;

      if (!authHeader) {
        return res.status(401).json({
          error: 'Authorization header missing'
        });
      }

      const token = authHeader.replace('Bearer ', '');

      // Supabase 토큰 검증
      const { valid, user, error } = await supabaseAuth.verifyToken(token);

      if (!valid) {
        return res.status(401).json({
          error: error || 'Invalid token'
        });
      }

      // 사용자 정보를 요청 객체에 추가
      req.user = user;
      req.userId = user.id;

      // 사용자 티어 확인
      const userProfile = await this.getUserProfile(user.id);
      req.userTier = userProfile?.user_tier || 'free';

      next();
    } catch (error) {
      console.error('Auth Middleware Error:', error);
      res.status(401).json({
        error: 'Authentication failed'
      });
    }
  }

  // 프리미엄 사용자 확인 미들웨어
  requirePremium(req, res, next) {
    if (req.userTier !== 'premium' && req.userTier !== 'pro') {
      return res.status(403).json({
        error: 'Premium subscription required',
        code: 'PREMIUM_REQUIRED'
      });
    }
    next();
  }

  // 관리자 확인 미들웨어
  requireAdmin(req, res, next) {
    if (req.user?.role !== 'admin') {
      return res.status(403).json({
        error: 'Admin access required',
        code: 'ADMIN_REQUIRED'
      });
    }
    next();
  }

  // Rate Limiting 미들웨어
  rateLimit(options = {}) {
    const {
      windowMs = 15 * 60 * 1000, // 15분
      max = 100, // 최대 요청 수
      message = 'Too many requests',
      keyGenerator = (req) => req.userId || req.ip
    } = options;

    const requests = new Map();

    return (req, res, next) => {
      const key = keyGenerator(req);
      const now = Date.now();
      const windowStart = now - windowMs;

      // 이전 요청 기록 정리
      const userRequests = requests.get(key) || [];
      const recentRequests = userRequests.filter(time => time > windowStart);

      if (recentRequests.length >= max) {
        const retryAfter = Math.ceil((recentRequests[0] + windowMs - now) / 1000);

        res.set('Retry-After', retryAfter);
        return res.status(429).json({
          error: message,
          retryAfter
        });
      }

      recentRequests.push(now);
      requests.set(key, recentRequests);

      // 메모리 정리 (1시간마다)
      if (Math.random() < 0.001) {
        for (const [k, v] of requests.entries()) {
          if (v.every(time => time < windowStart)) {
            requests.delete(k);
          }
        }
      }

      next();
    };
  }

  // API 키 인증 (외부 서비스용)
  async verifyApiKey(req, res, next) {
    const apiKey = req.headers['x-api-key'];

    if (!apiKey) {
      return res.status(401).json({
        error: 'API key required'
      });
    }

    try {
      // API 키 검증
      const { data, error } = await supabaseAuth.supabaseAdmin
        .from('api_keys')
        .select('*')
        .eq('key', apiKey)
        .eq('is_active', true)
        .single();

      if (error || !data) {
        return res.status(401).json({
          error: 'Invalid API key'
        });
      }

      // 사용량 체크
      if (data.usage_count >= data.usage_limit) {
        return res.status(429).json({
          error: 'API key usage limit exceeded'
        });
      }

      // 사용량 증가
      await supabaseAuth.supabaseAdmin
        .from('api_keys')
        .update({
          usage_count: data.usage_count + 1,
          last_used_at: new Date().toISOString()
        })
        .eq('id', data.id);

      req.apiKey = data;
      next();
    } catch (error) {
      console.error('API Key Verification Error:', error);
      res.status(500).json({
        error: 'Internal server error'
      });
    }
  }

  // 사용자 프로필 조회
  async getUserProfile(userId) {
    try {
      const { data } = await supabaseAuth.supabaseAdmin
        .from('users')
        .select('*')
        .eq('id', userId)
        .single();

      return data;
    } catch (error) {
      console.error('Get User Profile Error:', error);
      return null;
    }
  }

  // CORS 설정
  cors(options = {}) {
    const {
      origin = process.env.ALLOWED_ORIGINS?.split(',') || '*',
      credentials = true,
      methods = ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
      allowedHeaders = ['Content-Type', 'Authorization', 'X-API-Key'],
      maxAge = 86400 // 24시간
    } = options;

    return (req, res, next) => {
      const requestOrigin = req.headers.origin;

      if (origin === '*' || origin.includes(requestOrigin)) {
        res.header('Access-Control-Allow-Origin', requestOrigin || '*');
      }

      res.header('Access-Control-Allow-Credentials', credentials);
      res.header('Access-Control-Allow-Methods', methods.join(', '));
      res.header('Access-Control-Allow-Headers', allowedHeaders.join(', '));
      res.header('Access-Control-Max-Age', maxAge);

      if (req.method === 'OPTIONS') {
        return res.sendStatus(200);
      }

      next();
    };
  }
}

module.exports = new AuthMiddleware();

```

### 10.1.2 소셜 로그인 연동

### 프론트엔드 소셜 로그인 구현

```jsx
// frontend/js/auth/socialAuth.js
class SocialAuthManager {
  constructor() {
    this.supabase = window.supabase;
    this.providers = ['google', 'github', 'facebook'];
  }

  // 소셜 로그인 초기화
  init() {
    this.providers.forEach(provider => {
      const button = document.getElementById(`${provider}-login-btn`);
      if (button) {
        button.addEventListener('click', () => this.signInWithProvider(provider));
      }
    });

    // OAuth 콜백 처리
    this.handleOAuthCallback();
  }

  // 프로바이더로 로그인
  async signInWithProvider(provider) {
    try {
      const { data, error } = await this.supabase.auth.signInWithOAuth({
        provider,
        options: {
          redirectTo: `${window.location.origin}/auth/callback`,
          scopes: this.getProviderScopes(provider),
          queryParams: {
            access_type: 'offline',
            prompt: 'consent'
          }
        }
      });

      if (error) throw error;

      // 로딩 표시
      this.showLoading(provider);

    } catch (error) {
      console.error(`${provider} login error:`, error);
      this.showError(`${provider} 로그인 중 오류가 발생했습니다.`);
    }
  }

  // OAuth 콜백 처리
  async handleOAuthCallback() {
    // URL에서 에러 확인
    const urlParams = new URLSearchParams(window.location.search);
    const error = urlParams.get('error');
    const errorDescription = urlParams.get('error_description');

    if (error) {
      console.error('OAuth Error:', error, errorDescription);
      this.showError(errorDescription || '로그인 중 오류가 발생했습니다.');
      return;
    }

    // 세션 확인
    const { data: { session }, error: sessionError } = await this.supabase.auth.getSession();

    if (sessionError) {
      console.error('Session Error:', sessionError);
      return;
    }

    if (session) {
      // 로그인 성공 처리
      await this.onLoginSuccess(session);
    }
  }

  // 로그인 성공 처리
  async onLoginSuccess(session) {
    try {
      // 사용자 프로필 완성 확인
      const profileComplete = await this.checkProfileComplete(session.user);

      if (!profileComplete) {
        // 프로필 완성 페이지로 이동
        window.location.href = '/profile/complete';
        return;
      }

      // 사용자 정보 저장
      localStorage.setItem('user', JSON.stringify(session.user));
      localStorage.setItem('access_token', session.access_token);

      // 대시보드로 이동
      window.location.href = '/dashboard';

    } catch (error) {
      console.error('Login Success Handler Error:', error);
    }
  }

  // 프로필 완성 여부 확인
  async checkProfileComplete(user) {
    try {
      const response = await fetch('/api/user/profile', {
        headers: {
          'Authorization': `Bearer ${this.supabase.auth.session()?.access_token}`
        }
      });

      if (!response.ok) return false;

      const profile = await response.json();
      return profile.name && profile.preferences;

    } catch (error) {
      console.error('Profile Check Error:', error);
      return false;
    }
  }

  // 프로바이더별 스코프 설정
  getProviderScopes(provider) {
    const scopes = {
      google: 'email profile https://www.googleapis.com/auth/youtube.readonly',
      github: 'read:user user:email',
      facebook: 'email public_profile'
    };

    return scopes[provider] || '';
  }

  // 로딩 표시
  showLoading(provider) {
    const button = document.getElementById(`${provider}-login-btn`);
    if (button) {
      button.disabled = true;
      button.innerHTML = '<span class="spinner"></span> 연결 중...';
    }
  }

  // 에러 표시
  showError(message) {
    const errorDiv = document.getElementById('auth-error');
    if (errorDiv) {
      errorDiv.textContent = message;
      errorDiv.style.display = 'block';

      setTimeout(() => {
        errorDiv.style.display = 'none';
      }, 5000);
    }
  }
}

// 초기화
document.addEventListener('DOMContentLoaded', () => {
  const socialAuth = new SocialAuthManager();
  socialAuth.init();
});

```

### 10.1.3 2FA 구현

```jsx
// services/twoFactorAuth.js
const speakeasy = require('speakeasy');
const QRCode = require('qrcode');
const crypto = require('crypto');

class TwoFactorAuthService {
  constructor() {
    this.issuer = 'YouTube Shorts Curator';
    this.algorithm = 'sha256';
    this.digits = 6;
    this.window = 2; // 시간 윈도우 (전후 2개)
  }

  // 2FA 시크릿 생성
  async generateSecret(userId, userEmail) {
    try {
      const secret = speakeasy.generateSecret({
        name: `${this.issuer} (${userEmail})`,
        issuer: this.issuer,
        length: 32
      });

      // 백업 코드 생성
      const backupCodes = this.generateBackupCodes();

      // 암호화하여 저장
      const encryptedSecret = this.encryptSecret(secret.base32);

      const { error } = await supabaseAuth.supabaseAdmin
        .from('two_factor_auth')
        .upsert({
          user_id: userId,
          secret: encryptedSecret,
          backup_codes: backupCodes,
          is_enabled: false,
          created_at: new Date().toISOString()
        });

      if (error) throw error;

      // QR 코드 생성
      const qrCodeUrl = await this.generateQRCode(secret.otpauth_url);

      return {
        secret: secret.base32,
        qrCode: qrCodeUrl,
        backupCodes
      };

    } catch (error) {
      console.error('Generate 2FA Secret Error:', error);
      throw error;
    }
  }

  // QR 코드 생성
  async generateQRCode(otpauthUrl) {
    try {
      const qrCode = await QRCode.toDataURL(otpauthUrl, {
        width: 256,
        margin: 2,
        color: {
          dark: '#000000',
          light: '#FFFFFF'
        }
      });

      return qrCode;
    } catch (error) {
      console.error('QR Code Generation Error:', error);
      throw error;
    }
  }

  // 2FA 활성화
  async enable2FA(userId, token) {
    try {
      // 토큰 검증
      const isValid = await this.verifyToken(userId, token);

      if (!isValid) {
        throw new Error('Invalid verification token');
      }

      // 2FA 활성화
      const { error } = await supabaseAuth.supabaseAdmin
        .from('two_factor_auth')
        .update({
          is_enabled: true,
          enabled_at: new Date().toISOString()
        })
        .eq('user_id', userId);

      if (error) throw error;

      // 사용자 설정 업데이트
      await this.updateUserSettings(userId, { two_factor_enabled: true });

      return {
        success: true,
        message: '2FA가 성공적으로 활성화되었습니다.'
      };

    } catch (error) {
      console.error('Enable 2FA Error:', error);
      throw error;
    }
  }

  // 토큰 검증
  async verifyToken(userId, token) {
    try {
      // 사용자의 시크릿 조회
      const { data, error } = await supabaseAuth.supabaseAdmin
        .from('two_factor_auth')
        .select('secret')
        .eq('user_id', userId)
        .single();

      if (error || !data) {
        return false;
      }

      // 시크릿 복호화
      const secret = this.decryptSecret(data.secret);

      // 토큰 검증
      const verified = speakeasy.totp.verify({
        secret,
        encoding: 'base32',
        token,
        algorithm: this.algorithm,
        digits: this.digits,
        window: this.window
      });

      return verified;

    } catch (error) {
      console.error('Verify Token Error:', error);
      return false;
    }
  }

  // 백업 코드 검증
  async verifyBackupCode(userId, code) {
    try {
      const { data, error } = await supabaseAuth.supabaseAdmin
        .from('two_factor_auth')
        .select('backup_codes')
        .eq('user_id', userId)
        .single();

      if (error || !data) {
        return false;
      }

      const backupCodes = data.backup_codes;
      const codeIndex = backupCodes.findIndex(bc => bc.code === code && !bc.used);

      if (codeIndex === -1) {
        return false;
      }

      // 백업 코드 사용 처리
      backupCodes[codeIndex].used = true;
      backupCodes[codeIndex].used_at = new Date().toISOString();

      await supabaseAuth.supabaseAdmin
        .from('two_factor_auth')
        .update({ backup_codes: backupCodes })
        .eq('user_id', userId);

      return true;

    } catch (error) {
      console.error('Verify Backup Code Error:', error);
      return false;
    }
  }

  // 백업 코드 생성
  generateBackupCodes(count = 8) {
    const codes = [];

    for (let i = 0; i < count; i++) {
      codes.push({
        code: this.generateSecureCode(),
        used: false,
        created_at: new Date().toISOString()
      });
    }

    return codes;
  }

  // 보안 코드 생성
  generateSecureCode() {
    return crypto.randomBytes(4).toString('hex').toUpperCase();
  }

  // 시크릿 암호화
  encryptSecret(secret) {
    const algorithm = 'aes-256-gcm';
    const key = Buffer.from(process.env.ENCRYPTION_KEY, 'hex');
    const iv = crypto.randomBytes(16);

    const cipher = crypto.createCipheriv(algorithm, key, iv);

    let encrypted = cipher.update(secret, 'utf8', 'hex');
    encrypted += cipher.final('hex');

    const authTag = cipher.getAuthTag();

    return {
      encrypted,
      iv: iv.toString('hex'),
      authTag: authTag.toString('hex')
    };
  }

  // 시크릿 복호화
  decryptSecret(encryptedData) {
    const algorithm = 'aes-256-gcm';
    const key = Buffer.from(process.env.ENCRYPTION_KEY, 'hex');

    const decipher = crypto.createDecipheriv(
      algorithm,
      key,
      Buffer.from(encryptedData.iv, 'hex')
    );

    decipher.setAuthTag(Buffer.from(encryptedData.authTag, 'hex'));

    let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
    decrypted += decipher.final('utf8');

    return decrypted;
  }

  // 2FA 비활성화
  async disable2FA(userId, password) {
    try {
      // 비밀번호 확인
      const passwordValid = await this.verifyUserPassword(userId, password);

      if (!passwordValid) {
        throw new Error('Invalid password');
      }

      // 2FA 데이터 삭제
      const { error } = await supabaseAuth.supabaseAdmin
        .from('two_factor_auth')
        .delete()
        .eq('user_id', userId);

      if (error) throw error;

      // 사용자 설정 업데이트
      await this.updateUserSettings(userId, { two_factor_enabled: false });

      return {
        success: true,
        message: '2FA가 비활성화되었습니다.'
      };

    } catch (error) {
      console.error('Disable 2FA Error:', error);
      throw error;
    }
  }

  // 사용자 비밀번호 확인
  async verifyUserPassword(userId, password) {
    // Supabase Auth를 통한 비밀번호 확인
    // 실제 구현에서는 현재 세션과 비밀번호를 사용하여 재인증
    return true; // 임시
  }

  // 사용자 설정 업데이트
  async updateUserSettings(userId, settings) {
    await supabaseAuth.supabaseAdmin
      .from('users')
      .update({ settings })
      .eq('id', userId);
  }
}

module.exports = new TwoFactorAuthService();

```

## 10.2 보안 best practices

### 10.2.1 OWASP Top 10 대응

```jsx
// security/owaspProtection.js
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const mongoSanitize = require('express-mongo-sanitize');
const xss = require('xss-clean');
const hpp = require('hpp');
const cors = require('cors');

class SecurityManager {
  // 1. Injection 방어
  preventInjection() {
    return [
      // NoSQL Injection 방어
      mongoSanitize({
        allowDots: true,
        replaceWith: '_'
      }),

      // SQL Injection 방어 (Supabase는 파라미터화된 쿼리 사용)
      (req, res, next) => {
        // 입력값 검증
        Object.keys(req.body).forEach(key => {
          if (typeof req.body[key] === 'string') {
            req.body[key] = req.body[key].replace(/[';\\]/g, '');
          }
        });
        next();
      }
    ];
  }

  // 2. Broken Authentication 방어
  secureAuthentication() {
    return {
      sessionConfig: {
        secret: process.env.SESSION_SECRET,
        name: 'sessionId',
        resave: false,
        saveUninitialized: false,
        cookie: {
          secure: process.env.NODE_ENV === 'production',
          httpOnly: true,
          maxAge: 1000 * 60 * 60 * 24, // 24시간
          sameSite: 'strict'
        }
      },
      passwordPolicy: {
        minLength: 8,
        requireUppercase: true,
        requireLowercase: true,
        requireNumbers: true,
        requireSpecialChars: true,
        maxConsecutiveChars: 3
      }
    };
  }

  // 3. Sensitive Data Exposure 방어
  protectSensitiveData() {
    return [
      // HTTPS 강제
      (req, res, next) => {
        if (process.env.NODE_ENV === 'production' && !req.secure) {
          return res.redirect('https://' + req.headers.host + req.url);
        }
        next();
      },

      // 민감한 데이터 마스킹
      (req, res, next) => {
        const originalJson = res.json;
        res.json = function(data) {
          const masked = SecurityManager.maskSensitiveData(data);
          originalJson.call(this, masked);
        };
        next();
      }
    ];
  }

  // 4. XML External Entities (XXE) 방어
  preventXXE() {
    return (req, res, next) => {
      // XML 파싱 비활성화 또는 안전한 파서 사용
      if (req.is('xml') || req.is('text/xml')) {
        return res.status(415).json({
          error: 'XML content type not supported'
        });
      }
      next();
    };
  }

  // 5. Broken Access Control 방어
  enforceAccessControl() {
    return {
      // 리소스 접근 권한 확인
      checkResourceOwnership: async (req, res, next) => {
        const resourceId = req.params.id;
        const userId = req.userId;

        if (resourceId && userId) {
          const hasAccess = await this.verifyResourceAccess(resourceId, userId);
          if (!hasAccess) {
            return res.status(403).json({
              error: 'Access denied'
            });
          }
        }

        next();
      },

      // 역할 기반 접근 제어
      rbac: {
        admin: ['*'],
        premium: ['videos:read', 'videos:write', 'chat:unlimited'],
        free: ['videos:read', 'chat:limited']
      }
    };
  }

  // 6. Security Misconfiguration 방어
  preventMisconfiguration() {
    return [
      // 보안 헤더 설정
      helmet({
        contentSecurityPolicy: {
          directives: {
            defaultSrc: ["'self'"],
            scriptSrc: ["'self'", "'unsafe-inline'", 'https://cdn.jsdelivr.net'],
            styleSrc: ["'self'", "'unsafe-inline'", 'https://fonts.googleapis.com'],
            imgSrc: ["'self'", 'data:', 'https:'],
            connectSrc: ["'self'", 'https://api.youtube.com', process.env.SUPABASE_URL],
            fontSrc: ["'self'", 'https://fonts.gstatic.com'],
            objectSrc: ["'none'"],
            mediaSrc: ["'self'", 'https://www.youtube.com'],
            frameSrc: ["'self'", 'https://www.youtube.com']
          }
        },
        crossOriginEmbedderPolicy: false
      }),

      // 에러 처리
      (err, req, res, next) => {
        console.error(err.stack);

        // 프로덕션에서는 상세 에러 숨김
        const message = process.env.NODE_ENV === 'production'
          ? 'Internal Server Error'
          : err.message;

        res.status(err.status || 500).json({
          error: message
        });
      }
    ];
  }

  // 7. Cross-Site Scripting (XSS) 방어
  preventXSS() {
    return [
      // XSS Clean
      xss(),

      // Content-Type 설정
      (req, res, next) => {
        res.setHeader('X-Content-Type-Options', 'nosniff');
        next();
      },

      // 입력값 검증
      (req, res, next) => {
        const sanitize = (obj) => {
          for (let key in obj) {
            if (typeof obj[key] === 'string') {
              obj[key] = obj[key]
                .replace(/[<>]/g, '')
                .replace(/javascript:/gi, '')
                .replace(/on\w+=/gi, '');
            } else if (typeof obj[key] === 'object') {
              sanitize(obj[key]);
            }
          }
        };

        sanitize(req.body);
        sanitize(req.query);
        sanitize(req.params);

        next();
      }
    ];
  }

  // 8. Insecure Deserialization 방어
  preventInsecureDeserialization() {
    return (req, res, next) => {
      // JSON 파싱 크기 제한
      if (req.headers['content-length'] > 1048576) { // 1MB
        return res.status(413).json({
          error: 'Payload too large'
        });
      }

      // 안전한 JSON 파싱
      const originalJson = JSON.parse;
      JSON.parse = function(text, reviver) {
        // 위험한 프로토타입 체크
        if (text.includes('__proto__') || text.includes('constructor')) {
          throw new Error('Unsafe JSON detected');
        }
        return originalJson.call(this, text, reviver);
      };

      next();
    };
  }

  // 9. Using Components with Known Vulnerabilities 방어
  preventKnownVulnerabilities() {
    // package.json에 npm audit 설정
    // CI/CD 파이프라인에 보안 스캔 추가
    return {
      npmAudit: 'npm audit --production',
      dependencyCheck: 'npm-check-updates',
      securityHeaders: {
        'X-Powered-By': 'Hidden',
        'Server': 'Hidden'
      }
    };
  }

  // 10. Insufficient Logging & Monitoring 방어
  enhanceLoggingMonitoring() {
    const winston = require('winston');

    const logger = winston.createLogger({
      level: 'info',
      format: winston.format.json(),
      defaultMeta: { service: 'youtube-shorts-curator' },
      transports: [
        new winston.transports.File({ filename: 'error.log', level: 'error' }),
        new winston.transports.File({ filename: 'combined.log' }),
        new winston.transports.Console({
          format: winston.format.simple()
        })
      ]
    });

    return {
      logger,
      auditLog: async (action, userId, details) => {
        await supabaseAuth.supabaseAdmin
          .from('audit_logs')
          .insert({
            action,
            user_id: userId,
            details,
            ip_address: req.ip,
            user_agent: req.headers['user-agent'],
            created_at: new Date().toISOString()
          });
      }
    };
  }

  // 민감한 데이터 마스킹
  static maskSensitiveData(data) {
    const sensitiveFields = ['password', 'token', 'secret', 'api_key', 'credit_card'];

    const mask = (obj) => {
      if (typeof obj !== 'object' || obj === null) return obj;

      const masked = Array.isArray(obj) ? [] : {};

      for (let key in obj) {
        if (sensitiveFields.some(field => key.toLowerCase().includes(field))) {
          masked[key] = '***MASKED***';
        } else if (typeof obj[key] === 'object') {
          masked[key] = mask(obj[key]);
        } else {
          masked[key] = obj[key];
        }
      }

      return masked;
    };

    return mask(data);
  }

  // 리소스 접근 권한 확인
  async verifyResourceAccess(resourceId, userId) {
    // 실제 구현에서는 데이터베이스에서 확인
    return true;
  }

  // 전체 보안 미들웨어 적용
  applyAll(app) {
    // CORS 설정
    app.use(cors({
      origin: process.env.ALLOWED_ORIGINS?.split(',') || '*',
      credentials: true
    }));

    // Rate Limiting
    app.use(rateLimit({
      windowMs: 15 * 60 * 1000,
      max: 100,
      message: 'Too many requests from this IP'
    }));

    // 보안 헤더
    app.use(helmet());

    // 각종 보안 미들웨어
    app.use(this.preventInjection());
    app.use(this.preventXSS());
    app.use(this.preventXXE());
    app.use(this.preventInsecureDeserialization());
    app.use(this.protectSensitiveData());

    // HPP (HTTP Parameter Pollution) 방어
    app.use(hpp());

    console.log('Security middleware applied');
  }
}

module.exports = new SecurityManager();

```

### 10.2.2 데이터 암호화

```jsx
// security/encryption.js
const crypto = require('crypto');
const bcrypt = require('bcrypt');

class EncryptionService {
  constructor() {
    this.algorithm = 'aes-256-gcm';
    this.saltRounds = 12;
    this.keyDerivationIterations = 100000;
  }

  // AES 암호화
  encrypt(text, key = process.env.ENCRYPTION_KEY) {
    try {
      const iv = crypto.randomBytes(16);
      const salt = crypto.randomBytes(64);

      const derivedKey = crypto.pbkdf2Sync(key, salt, this.keyDerivationIterations, 32, 'sha256');

      const cipher = crypto.createCipheriv(this.algorithm, derivedKey, iv);

      let encrypted = cipher.update(text, 'utf8', 'hex');
      encrypted += cipher.final('hex');

      const authTag = cipher.getAuthTag();

      return {
        encrypted,
        salt: salt.toString('hex'),
        iv: iv.toString('hex'),
        authTag: authTag.toString('hex')
      };
    } catch (error) {
      console.error('Encryption Error:', error);
      throw error;
    }
  }

  // AES 복호화
  decrypt(encryptedData, key = process.env.ENCRYPTION_KEY) {
    try {
      const salt = Buffer.from(encryptedData.salt, 'hex');
      const iv = Buffer.from(encryptedData.iv, 'hex');
      const authTag = Buffer.from(encryptedData.authTag, 'hex');

      const derivedKey = crypto.pbkdf2Sync(key, salt, this.keyDerivationIterations, 32, 'sha256');

      const decipher = crypto.createDecipheriv(this.algorithm, derivedKey, iv);
      decipher.setAuthTag(authTag);

      let decrypted = decipher.update(encryptedData.encrypted, 'hex', 'utf8');
      decrypted += decipher.final('utf8');

      return decrypted;
    } catch (error) {
      console.error('Decryption Error:', error);
      throw error;
    }
  }

  // 필드 레벨 암호화
  async encryptFields(data, fieldsToEncrypt) {
    const encrypted = { ...data };

    for (const field of fieldsToEncrypt) {
      if (data[field]) {
        encrypted[field] = this.encrypt(data[field].toString());
      }
    }

    return encrypted;
  }

  // 필드 레벨 복호화
  async decryptFields(data, fieldsToDecrypt) {
    const decrypted = { ...data };

    for (const field of fieldsToDecrypt) {
      if (data[field] && typeof data[field] === 'object') {
        try {
          decrypted[field] = this.decrypt(data[field]);
        } catch (error) {
          console.error(`Failed to decrypt field ${field}:`, error);
          decrypted[field] = null;
        }
      }
    }

    return decrypted;
  }

  // 비밀번호 해싱
  async hashPassword(password) {
    try {
      const hash = await bcrypt.hash(password, this.saltRounds);
      return hash;
    } catch (error) {
      console.error('Password Hashing Error:', error);
      throw error;
    }
  }

  // 비밀번호 검증
  async verifyPassword(password, hash) {
    try {
      const isValid = await bcrypt.compare(password, hash);
      return isValid;
    } catch (error) {
      console.error('Password Verification Error:', error);
      return false;
    }
  }

  // 토큰 생성
  generateToken(length = 32) {
    return crypto.randomBytes(length).toString('hex');
  }

  // HMAC 서명 생성
  generateHMAC(data, secret = process.env.HMAC_SECRET) {
    const hmac = crypto.createHmac('sha256', secret);
    hmac.update(JSON.stringify(data));
    return hmac.digest('hex');
  }

  // HMAC 서명 검증
  verifyHMAC(data, signature, secret = process.env.HMAC_SECRET) {
    const expectedSignature = this.generateHMAC(data, secret);
    return crypto.timingSafeEqual(
      Buffer.from(signature),
      Buffer.from(expectedSignature)
    );
  }

  // 개인정보 마스킹
  maskPII(data) {
    const patterns = {
      email: /([a-zA-Z0-9._-]+)@([a-zA-Z0-9._-]+\.[a-zA-Z0-9_-]+)/gi,
      phone: /(\d{3})[-.\s]?(\d{3,4})[-.\s]?(\d{4})/g,
      creditCard: /(\d{4})[-.\s]?(\d{4})[-.\s]?(\d{4})[-.\s]?(\d{4})/g,
      ssn: /(\d{3})-(\d{2})-(\d{4})/g
    };

    let masked = data;

    // 이메일 마스킹
    masked = masked.replace(patterns.email, (match, p1, p2) => {
      const maskedLocal = p1.charAt(0) + '*'.repeat(p1.length - 2) + p1.charAt(p1.length - 1);
      return `${maskedLocal}@${p2}`;
    });

    // 전화번호 마스킹
    masked = masked.replace(patterns.phone, (match, p1, p2, p3) => {
      return `${p1}-****-${p3.substr(-2)}`;
    });

    // 신용카드 마스킹
    masked = masked.replace(patterns.creditCard, (match, p1, p2, p3, p4) => {
      return `${p1} **** **** ${p4}`;
    });

    return masked;
  }

  // 키 로테이션
  async rotateEncryptionKey(oldKey, newKey) {
    try {
      // 기존 암호화된 데이터 조회
      const { data: encryptedData, error } = await supabaseAuth.supabaseAdmin
        .from('encrypted_data')
        .select('*');

      if (error) throw error;

      // 각 데이터를 새 키로 재암호화
      const rotatedData = await Promise.all(
        encryptedData.map(async (item) => {
          const decrypted = this.decrypt(item.encrypted_value, oldKey);
          const reencrypted = this.encrypt(decrypted, newKey);

          return {
            id: item.id,
            encrypted_value: reencrypted
          };
        })
      );

      // 업데이트
      for (const item of rotatedData) {
        await supabaseAuth.supabaseAdmin
          .from('encrypted_data')
          .update({ encrypted_value: item.encrypted_value })
          .eq('id', item.id);
      }

      return {
        success: true,
        rotatedCount: rotatedData.length
      };

    } catch (error) {
      console.error('Key Rotation Error:', error);
      throw error;
    }
  }
}

module.exports = new EncryptionService();

```

### 10.2.3 보안 헤더 설정

```jsx
// security/securityHeaders.js
class SecurityHeaders {
  // 보안 헤더 설정
  static configure(app) {
    // Strict-Transport-Security
    app.use((req, res, next) => {
      if (req.secure || process.env.NODE_ENV === 'production') {
        res.setHeader(
          'Strict-Transport-Security',
          'max-age=31536000; includeSubDomains; preload'
        );
      }
      next();
    });

    // Content-Security-Policy
    app.use((req, res, next) => {
      const csp = [
        "default-src 'self'",
        "script-src 'self' 'unsafe-inline' 'unsafe-eval' https://cdn.jsdelivr.net https://www.youtube.com",
        "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com",
        "font-src 'self' https://fonts.gstatic.com",
        "img-src 'self' data: https: blob:",
        "media-src 'self' https://www.youtube.com",
        "connect-src 'self' https://api.youtube.com " + process.env.SUPABASE_URL,
        "frame-src 'self' https://www.youtube.com",
        "object-src 'none'",
        "base-uri 'self'",
        "form-action 'self'",
        "frame-ancestors 'none'",
        "upgrade-insecure-requests"
      ].join('; ');

      res.setHeader('Content-Security-Policy', csp);
      next();
    });

    // 기타 보안 헤더
    app.use((req, res, next) => {
      // XSS 보호
      res.setHeader('X-XSS-Protection', '1; mode=block');

      // 클릭재킹 방지
      res.setHeader('X-Frame-Options', 'DENY');

      // MIME 타입 스니핑 방지
      res.setHeader('X-Content-Type-Options', 'nosniff');

      // Referrer 정책
      res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');

      // 기능 정책
      res.setHeader(
        'Permissions-Policy',
        'camera=(), microphone=(), geolocation=(), payment=()'
      );

      // DNS Prefetch 제어
      res.setHeader('X-DNS-Prefetch-Control', 'off');

      // IE8+ XSS 필터 활성화
      res.setHeader('X-Download-Options', 'noopen');

      next();
    });

    // 보안 쿠키 설정
    app.use((req, res, next) => {
      const originalCookie = res.cookie;

      res.cookie = function(name, value, options = {}) {
        const secureOptions = {
          ...options,
          secure: process.env.NODE_ENV === 'production',
          httpOnly: true,
          sameSite: 'strict',
          maxAge: options.maxAge || 1000 * 60 * 60 * 24 // 기본 24시간
        };

        return originalCookie.call(this, name, value, secureOptions);
      };

      next();
    });
  }

  // API 응답 보안
  static secureApiResponses(app) {
    app.use((req, res, next) => {
      // API 버전 숨기기
      res.removeHeader('X-Powered-By');

      // 캐시 제어 (민감한 데이터)
      if (req.path.includes('/api/user') || req.path.includes('/api/auth')) {
        res.setHeader(
          'Cache-Control',
          'no-store, no-cache, must-revalidate, proxy-revalidate'
        );
        res.setHeader('Pragma', 'no-cache');
        res.setHeader('Expires', '0');
      }

      next();
    });
  }
}

module.exports = SecurityHeaders;

```

## 10.3 개인정보 보호

### 10.3.1 GDPR 준수

```jsx
// privacy/gdprCompliance.js
class GDPRCompliance {
  // 개인정보 수집 동의
  async recordConsent(userId, consentData) {
    try {
      const consent = {
        user_id: userId,
        consent_type: consentData.type,
        granted: consentData.granted,
        purpose: consentData.purpose,
        version: consentData.version || '1.0',
        ip_address: consentData.ipAddress,
        user_agent: consentData.userAgent,
        created_at: new Date().toISOString()
      };

      const { error } = await supabaseAuth.supabaseAdmin
        .from('privacy_consents')
        .insert(consent);

      if (error) throw error;

      return { success: true };
    } catch (error) {
      console.error('Record Consent Error:', error);
      throw error;
    }
  }

  // 개인정보 접근 요청 (GDPR Article 15)
  async handleAccessRequest(userId) {
    try {
      const userData = await this.collectUserData(userId);

      return {
        success: true,
        data: userData,
        exportUrl: await this.generateDataExport(userData)
      };
    } catch (error) {
      console.error('Access Request Error:', error);
      throw error;
    }
  }

  // 개인정보 수정 요청 (GDPR Article 16)
  async handleRectificationRequest(userId, updates) {
    try {
      const allowedFields = ['name', 'email', 'preferences'];
      const filteredUpdates = {};

      // 허용된 필드만 업데이트
      for (const field of allowedFields) {
        if (updates[field] !== undefined) {
          filteredUpdates[field] = updates[field];
        }
      }

      const { error } = await supabaseAuth.supabaseAdmin
        .from('users')
        .update(filteredUpdates)
        .eq('id', userId);

      if (error) throw error;

      // 수정 이력 기록
      await this.logDataChange(userId, 'rectification', filteredUpdates);

      return { success: true };
    } catch (error) {
      console.error('Rectification Request Error:', error);
      throw error;
    }
  }

  // 개인정보 삭제 요청 (GDPR Article 17 - Right to be forgotten)
  async handleDeletionRequest(userId, reason) {
    try {
      // 삭제 가능 여부 확인
      const canDelete = await this.checkDeletionEligibility(userId);

      if (!canDelete.eligible) {
        return {
          success: false,
          reason: canDelete.reason
        };
      }

      // 데이터 익명화 (완전 삭제 대신)
      await this.anonymizeUserData(userId);

      // 삭제 요청 기록
      await this.logDeletionRequest(userId, reason);

      return {
        success: true,
        message: '개인정보가 익명화되었습니다.'
      };
    } catch (error) {
      console.error('Deletion Request Error:', error);
      throw error;
    }
  }

  // 개인정보 이동권 (GDPR Article 20)
  async handlePortabilityRequest(userId, format = 'json') {
    try {
      const userData = await this.collectUserData(userId);

      let exportData;
      switch (format) {
        case 'json':
          exportData = JSON.stringify(userData, null, 2);
          break;
        case 'csv':
          exportData = this.convertToCSV(userData);
          break;
        default:
          throw new Error('Unsupported format');
      }

      return {
        success: true,
        data: exportData,
        format,
        filename: `user_data_${userId}_${Date.now()}.${format}`
      };
    } catch (error) {
      console.error('Portability Request Error:', error);
      throw error;
    }
  }

  // 처리 제한권 (GDPR Article 18)
  async handleRestrictionRequest(userId, scope) {
    try {
      const restrictions = {
        marketing: scope.includes('marketing'),
        analytics: scope.includes('analytics'),
        personalization: scope.includes('personalization')
      };

      const { error } = await supabaseAuth.supabaseAdmin
        .from('users')
        .update({
          processing_restrictions: restrictions,
          restricted_at: new Date().toISOString()
        })
        .eq('id', userId);

      if (error) throw error;

      return { success: true, restrictions };
    } catch (error) {
      console.error('Restriction Request Error:', error);
      throw error;
    }
  }

  // 사용자 데이터 수집
  async collectUserData(userId) {
    try {
      const [profile, activities, preferences, consents] = await Promise.all([
        this.getUserProfile(userId),
        this.getUserActivities(userId),
        this.getUserPreferences(userId),
        this.getUserConsents(userId)
      ]);

      return {
        profile,
        activities,
        preferences,
        consents,
        exportedAt: new Date().toISOString()
      };
    } catch (error) {
      console.error('Collect User Data Error:', error);
      throw error;
    }
  }

  // 사용자 프로필 조회
  async getUserProfile(userId) {
    const { data } = await supabaseAuth.supabaseAdmin
      .from('users')
      .select('id, email, name, created_at, user_tier')
      .eq('id', userId)
      .single();

    return data;
  }

  // 사용자 활동 조회
  async getUserActivities(userId) {
    const { data } = await supabaseAuth.supabaseAdmin
      .from('user_activity_logs')
      .select('action, created_at')
      .eq('user_id', userId)
      .order('created_at', { ascending: false })
      .limit(1000);

    return data;
  }

  // 사용자 선호도 조회
  async getUserPreferences(userId) {
    const { data } = await supabaseAuth.supabaseAdmin
      .from('user_preference_profiles')
      .select('preferred_categories, preferred_keywords')
      .eq('user_id', userId)
      .single();

    return data;
  }

  // 사용자 동의 기록 조회
  async getUserConsents(userId) {
    const { data } = await supabaseAuth.supabaseAdmin
      .from('privacy_consents')
      .select('consent_type, granted, purpose, created_at')
      .eq('user_id', userId)
      .order('created_at', { ascending: false });

    return data;
  }

  // 삭제 가능 여부 확인
  async checkDeletionEligibility(userId) {
    // 법적 의무 확인 (예: 세금 기록 보관 의무)
    const hasLegalObligation = await this.checkLegalObligations(userId);

    if (hasLegalObligation) {
      return {
        eligible: false,
        reason: 'Legal obligation to retain data'
      };
    }

    return { eligible: true };
  }

  // 데이터 익명화
  async anonymizeUserData(userId) {
    const anonymousId = `ANON_${crypto.randomBytes(16).toString('hex')}`;

    // 사용자 프로필 익명화
    await supabaseAuth.supabaseAdmin
      .from('users')
      .update({
        email: `${anonymousId}@anonymous.local`,
        name: 'Anonymous User',
        is_deleted: true,
        deleted_at: new Date().toISOString()
      })
      .eq('id', userId);

    // 관련 데이터 익명화
    await this.anonymizeRelatedData(userId, anonymousId);
  }

  // 관련 데이터 익명화
  async anonymizeRelatedData(userId, anonymousId) {
    // 검색 로그 익명화
    await supabaseAuth.supabaseAdmin
      .from('search_logs')
      .update({ user_id: anonymousId })
      .eq('user_id', userId);

    // 활동 로그는 30일 후 삭제
    // ... 기타 관련 테이블 처리
  }

  // 데이터 변경 로깅
  async logDataChange(userId, changeType, details) {
    await supabaseAuth.supabaseAdmin
      .from('data_change_logs')
      .insert({
        user_id: userId,
        change_type: changeType,
        details,
        created_at: new Date().toISOString()
      });
  }

  // 삭제 요청 로깅
  async logDeletionRequest(userId, reason) {
    await supabaseAuth.supabaseAdmin
      .from('deletion_requests')
      .insert({
        user_id: userId,
        reason,
        processed_at: new Date().toISOString()
      });
  }

  // CSV 변환
  convertToCSV(data) {
    // 간단한 CSV 변환 로직
    const csv = [];

    // 프로필 데이터
    csv.push('Profile Data');
    csv.push('Field,Value');
    Object.entries(data.profile).forEach(([key, value]) => {
      csv.push(`${key},"${value}"`);
    });

    // ... 기타 데이터 섹션

    return csv.join('\n');
  }

  // 법적 의무 확인
  async checkLegalObligations(userId) {
    // 실제 구현에서는 비즈니스 로직에 따라 확인
    return false;
  }
}

module.exports = new GDPRCompliance();

```

### 10.3.2 데이터 최소화

```jsx
// privacy/dataMinimization.js
class DataMinimization {
  // 데이터 수집 정책
  static dataCollectionPolicy = {
    required: ['email', 'password'], // 필수 데이터
    optional: ['name', 'preferences'], // 선택 데이터
    prohibited: ['ssn', 'credit_card', 'health_info'] // 수집 금지 데이터
  };

  // 데이터 보존 기간
  static retentionPeriods = {
    user_profiles: null, // 계정 삭제까지
    activity_logs: 90, // 90일
    search_logs: 30, // 30일
    error_logs: 180, // 180일
    audit_logs: 365 * 3 // 3년 (법적 요구사항)
  };

  // 데이터 수집 검증
  validateDataCollection(data, context) {
    const errors = [];
    const warnings = [];

    // 금지된 데이터 확인
    Object.keys(data).forEach(key => {
      if (DataMinimization.dataCollectionPolicy.prohibited.includes(key)) {
        errors.push(`Prohibited data field: ${key}`);
      }
    });

    // 필수 데이터 확인
    if (context === 'registration') {
      DataMinimization.dataCollectionPolicy.required.forEach(field => {
        if (!data[field]) {
          errors.push(`Required field missing: ${field}`);
        }
      });
    }

    // 불필요한 데이터 경고
    Object.keys(data).forEach(key => {
      if (!DataMinimization.dataCollectionPolicy.required.includes(key) &&
          !DataMinimization.dataCollectionPolicy.optional.includes(key)) {
        warnings.push(`Unnecessary data field: ${key}`);
      }
    });

    return { valid: errors.length === 0, errors, warnings };
  }

  // 자동 데이터 정리
  async cleanupExpiredData() {
    const cleanupTasks = [];

    Object.entries(DataMinimization.retentionPeriods).forEach(([table, days]) => {
      if (days !== null) {
        cleanupTasks.push(this.deleteOldRecords(table, days));
      }
    });

    const results = await Promise.allSettled(cleanupTasks);

    return results.map((result, index) => ({
      table: Object.keys(DataMinimization.retentionPeriods)[index],
      status: result.status,
      deletedCount: result.value || 0,
      error: result.reason
    }));
  }

  // 오래된 레코드 삭제
  async deleteOldRecords(table, days) {
    try {
      const cutoffDate = new Date();
      cutoffDate.setDate(cutoffDate.getDate() - days);

      const { data, error } = await supabaseAuth.supabaseAdmin
        .from(table)
        .delete()
        .lt('created_at', cutoffDate.toISOString())
        .select('id');

      if (error) throw error;

      return data?.length || 0;
    } catch (error) {
      console.error(`Cleanup error for ${table}:`, error);
      throw error;
    }
  }

  // 데이터 익명화 스케줄러
  scheduleAnonymization() {
    const cron = require('node-cron');

    // 매일 새벽 3시에 실행
    cron.schedule('0 3 * * *', async () => {
      console.log('Starting data anonymization...');

      try {
        await this.anonymizeOldSearchLogs();
        await this.anonymizeOldActivityLogs();
        console.log('Data anonymization completed');
      } catch (error) {
        console.error('Anonymization error:', error);
      }
    });
  }

  // 검색 로그 익명화
  async anonymizeOldSearchLogs() {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - 30);

    const { error } = await supabaseAuth.supabaseAdmin
      .from('search_logs')
      .update({
        user_id: null,
        ip_address: null
      })
      .lt('created_at', cutoffDate.toISOString())
      .is('user_id', 'not.null');

    if (error) throw error;
  }

  // 활동 로그 익명화
  async anonymizeOldActivityLogs() {
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - 90);

    const { error } = await supabaseAuth.supabaseAdmin
      .from('user_activity_logs')
      .update({
        user_id: 'anonymous',
        ip_address: null,
        user_agent: null
      })
      .lt('created_at', cutoffDate.toISOString());

    if (error) throw error;
  }
}

module.exports = DataMinimization;

```

### 10.3.3 사용자 권리 보장

```jsx
// privacy/userRights.js
class UserRightsManager {
  // 사용자 권리 대시보드 API
  async getUserRightsDashboard(userId) {
    try {
      const [
        dataCollected,
        processingActivities,
        consents,
        restrictions
      ] = await Promise.all([
        this.getDataCollectedSummary(userId),
        this.getProcessingActivities(userId),
        this.getActiveConsents(userId),
        this.getProcessingRestrictions(userId)
      ]);

      return {
        overview: {
          dataCollected,
          processingActivities,
          consents,
          restrictions
        },
        rights: {
          access: {
            available: true,
            description: '개인정보 열람권',
            lastExercised: await this.getLastRightExercise(userId, 'access')
          },
          rectification: {
            available: true,
            description: '개인정보 정정권',
            lastExercised: await this.getLastRightExercise(userId, 'rectification')
          },
          deletion: {
            available: true,
            description: '개인정보 삭제권 (잊혀질 권리)',
            lastExercised: await this.getLastRightExercise(userId, 'deletion')
          },
          restriction: {
            available: true,
            description: '처리 제한권',
            lastExercised: await this.getLastRightExercise(userId, 'restriction')
          },
          portability: {
            available: true,
            description: '개인정보 이동권',
            lastExercised: await this.getLastRightExercise(userId, 'portability')
          },
          objection: {
            available: true,
            description: '처리 거부권',
            lastExercised: await this.getLastRightExercise(userId, 'objection')
          }
        }
      };
    } catch (error) {
      console.error('Get User Rights Dashboard Error:', error);
      throw error;
    }
  }

  // 데이터 수집 요약
  async getDataCollectedSummary(userId) {
    const tables = [
      'users',
      'user_preference_profiles',
      'search_logs',
      'video_interactions'
    ];

    const summary = {};

    for (const table of tables) {
      const { count } = await supabaseAuth.supabaseAdmin
        .from(table)
        .select('*', { count: 'exact', head: true })
        .eq('user_id', userId);

      summary[table] = count || 0;
    }

    return summary;
  }

  // 처리 활동 조회
  async getProcessingActivities(userId) {
    return {
      personalization: {
        active: true,
        purpose: '맞춤형 콘텐츠 추천',
        legalBasis: '정당한 이익'
      },
      analytics: {
        active: true,
        purpose: '서비스 개선을 위한 분석',
        legalBasis: '동의'
      },
      marketing: {
        active: false,
        purpose: '마케팅 커뮤니케이션',
        legalBasis: '동의'
      }
    };
  }

  // 활성 동의 조회
  async getActiveConsents(userId) {
    const { data } = await supabaseAuth.supabaseAdmin
      .from('privacy_consents')
      .select('*')
      .eq('user_id', userId)
      .eq('granted', true)
      .order('created_at', { ascending: false });

    return data || [];
  }

  // 처리 제한 조회
  async getProcessingRestrictions(userId) {
    const { data } = await supabaseAuth.supabaseAdmin
      .from('users')
      .select('processing_restrictions')
      .eq('id', userId)
      .single();

    return data?.processing_restrictions || {};
  }

  // 마지막 권리 행사 기록
  async getLastRightExercise(userId, rightType) {
    const { data } = await supabaseAuth.supabaseAdmin
      .from('user_rights_requests')
      .select('created_at')
      .eq('user_id', userId)
      .eq('right_type', rightType)
      .order('created_at', { ascending: false })
      .limit(1)
      .single();

    return data?.created_at || null;
  }

  // 권리 행사 요청 처리
  async processRightRequest(userId, rightType, details) {
    try {
      // 요청 기록
      const { data: request, error } = await supabaseAuth.supabaseAdmin
        .from('user_rights_requests')
        .insert({
          user_id: userId,
          right_type: rightType,
          status: 'pending',
          details,
          created_at: new Date().toISOString()
        })
        .select()
        .single();

      if (error) throw error;

      // 권리 유형별 처리
      let result;
      switch (rightType) {
        case 'access':
          result = await gdprCompliance.handleAccessRequest(userId);
          break;
        case 'rectification':
          result = await gdprCompliance.handleRectificationRequest(userId, details);
          break;
        case 'deletion':
          result = await gdprCompliance.handleDeletionRequest(userId, details.reason);
          break;
        case 'restriction':
          result = await gdprCompliance.handleRestrictionRequest(userId, details.scope);
          break;
        case 'portability':
          result = await gdprCompliance.handlePortabilityRequest(userId, details.format);
          break;
        case 'objection':
          result = await this.handleObjectionRequest(userId, details);
          break;
        default:
          throw new Error('Unknown right type');
      }

      // 요청 상태 업데이트
      await supabaseAuth.supabaseAdmin
        .from('user_rights_requests')
        .update({
          status: result.success ? 'completed' : 'failed',
          processed_at: new Date().toISOString(),
          result
        })
        .eq('id', request.id);

      return result;

    } catch (error) {
      console.error('Process Right Request Error:', error);
      throw error;
    }
  }

  // 처리 거부 요청 처리
  async handleObjectionRequest(userId, details) {
    try {
      const objections = {
        marketing: details.marketing || false,
        profiling: details.profiling || false,
        automated_decision: details.automated_decision || false
      };

      const { error } = await supabaseAuth.supabaseAdmin
        .from('users')
        .update({
          processing_objections: objections,
          objected_at: new Date().toISOString()
        })
        .eq('id', userId);

      if (error) throw error;

      // 관련 처리 중단
      if (objections.marketing) {
        await this.stopMarketingProcessing(userId);
      }
      if (objections.profiling) {
        await this.stopProfilingProcessing(userId);
      }

      return { success: true, objections };
    } catch (error) {
      console.error('Objection Request Error:', error);
      throw error;
    }
  }

  // 마케팅 처리 중단
  async stopMarketingProcessing(userId) {
    // 마케팅 목록에서 제거
    await supabaseAuth.supabaseAdmin
      .from('marketing_lists')
      .delete()
      .eq('user_id', userId);

    // 마케팅 동의 철회
    await supabaseAuth.supabaseAdmin
      .from('privacy_consents')
      .update({ granted: false })
      .eq('user_id', userId)
      .eq('consent_type', 'marketing');
  }

  // 프로파일링 처리 중단
  async stopProfilingProcessing(userId) {
    // 개인화 프로필 삭제
    await supabaseAuth.supabaseAdmin
      .from('user_preference_profiles')
      .delete()
      .eq('user_id', userId);

    // 추천 비활성화
    await supabaseAuth.supabaseAdmin
      .from('users')
      .update({ personalization_enabled: false })
      .eq('id', userId);
  }

  // 자동화된 권리 행사 API 엔드포인트
  setupEndpoints(app) {
    // 권리 대시보드
    app.get('/api/privacy/rights', authMiddleware.verifyToken, async (req, res) => {
      try {
        const dashboard = await this.getUserRightsDashboard(req.userId);
        res.json(dashboard);
      } catch (error) {
        res.status(500).json({ error: 'Failed to get rights dashboard' });
      }
    });

    // 권리 행사 요청
    app.post('/api/privacy/rights/:rightType', authMiddleware.verifyToken, async (req, res) => {
      try {
        const result = await this.processRightRequest(
          req.userId,
          req.params.rightType,
          req.body
        );
        res.json(result);
      } catch (error) {
        res.status(500).json({ error: 'Failed to process right request' });
      }
    });

    // 동의 관리
    app.post('/api/privacy/consent', authMiddleware.verifyToken, async (req, res) => {
      try {
        const result = await gdprCompliance.recordConsent(req.userId, {
          ...req.body,
          ipAddress: req.ip,
          userAgent: req.headers['user-agent']
        });
        res.json(result);
      } catch (error) {
        res.status(500).json({ error: 'Failed to record consent' });
      }
    });

    // 데이터 다운로드
    app.get('/api/privacy/download', authMiddleware.verifyToken, async (req, res) => {
      try {
        const result = await gdprCompliance.handlePortabilityRequest(
          req.userId,
          req.query.format || 'json'
        );

        res.setHeader('Content-Type', `application/${result.format}`);
        res.setHeader('Content-Disposition', `attachment; filename="${result.filename}"`);
        res.send(result.data);
      } catch (error) {
        res.status(500).json({ error: 'Failed to generate data export' });
      }
    });
  }
}

module.exports = new UserRightsManager();

```

## 보안 시스템 통합 예제

```jsx
// server.js - 보안 설정 통합
const express = require('express');
const app = express();

// 보안 모듈 임포트
const securityManager = require('./security/owaspProtection');
const authMiddleware = require('./middleware/auth');
const encryptionService = require('./security/encryption');
const SecurityHeaders = require('./security/securityHeaders');
const gdprCompliance = require('./privacy/gdprCompliance');
const userRightsManager = require('./privacy/userRights');
const dataMinimization = require('./privacy/dataMinimization');

// 기본 보안 설정
securityManager.applyAll(app);
SecurityHeaders.configure(app);
SecurityHeaders.secureApiResponses(app);

// Body parser with size limit
app.use(express.json({ limit: '1mb' }));
app.use(express.urlencoded({ extended: true, limit: '1mb' }));

// 인증 라우트
app.post('/api/auth/signup', async (req, res) => {
  try {
    // 데이터 최소화 검증
    const validation = dataMinimization.validateDataCollection(req.body, 'registration');
    if (!validation.valid) {
      return res.status(400).json({ errors: validation.errors });
    }

    const result = await supabaseAuth.signUp(
      req.body.email,
      req.body.password,
      req.body
    );

    res.json(result);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

app.post('/api/auth/signin', authMiddleware.rateLimit({ max: 5, windowMs: 15 * 60 * 1000 }), async (req, res) => {
  try {
    const result = await supabaseAuth.signIn(req.body.email, req.body.password);
    res.json(result);
  } catch (error) {
    res.status(401).json({ error: 'Invalid credentials' });
  }
});

// 2FA 라우트
app.post('/api/auth/2fa/setup', authMiddleware.verifyToken, async (req, res) => {
  try {
    const result = await twoFactorAuth.generateSecret(req.userId, req.user.email);
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: 'Failed to setup 2FA' });
  }
});

app.post('/api/auth/2fa/verify', authMiddleware.verifyToken, async (req, res) => {
  try {
    const isValid = await twoFactorAuth.verifyToken(req.userId, req.body.token);
    if (isValid) {
      await twoFactorAuth.enable2FA(req.userId, req.body.token);
      res.json({ success: true });
    } else {
      res.status(400).json({ error: 'Invalid token' });
    }
  } catch (error) {
    res.status(500).json({ error: 'Failed to verify 2FA' });
  }
});

// 보호된 API 라우트
app.get('/api/videos/search',
  authMiddleware.verifyToken,
  authMiddleware.rateLimit({ max: 100 }),
  async (req, res) => {
    // 검색 로직
  }
);

app.get('/api/chat',
  authMiddleware.verifyToken,
  authMiddleware.requirePremium,
  authMiddleware.rateLimit({ max: 50, windowMs: 60 * 60 * 1000 }),
  async (req, res) => {
    // 프리미엄 채팅 로직
  }
);

// GDPR 엔드포인트 설정
userRightsManager.setupEndpoints(app);

// 데이터 정리 스케줄러 시작
dataMinimization.scheduleAnonymization();

// 서버 시작
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT} with security enabled`);
  console.log('Security features:');
  console.log('- OWASP Top 10 protection');
  console.log('- GDPR compliance');
  console.log('- 2FA support');
  console.log('- Rate limiting');
  console.log('- Data encryption');
});

```