# 운영 매뉴얼 (Operations Manual)

## 14.1 일일 운영 체크리스트

### 오전 점검 (09:00 - 10:00)

### 시스템 상태 확인

```bash
#!/bin/bash
# morning-check.sh - 오전 일일 점검 스크립트

echo "=== YouTube Shorts 큐레이션 서비스 일일 점검 시작 ==="
echo "시작 시간: $(date)"

# 1. 서비스 가용성 확인
echo -e "\n[1/8] 서비스 가용성 확인"
services=(
    "https://api.yourservice.com/health"
    "https://app.yourservice.com"
    "https://admin.yourservice.com"
)

for service in "${services[@]}"; do
    response=$(curl -s -o /dev/null -w "%{http_code}" "$service")
    if [ "$response" = "200" ]; then
        echo "✅ $service - 정상"
    else
        echo "❌ $service - 응답 코드: $response"
        # 알림 발송
        send_alert "서비스 다운: $service"
    fi
done

# 2. 데이터베이스 상태
echo -e "\n[2/8] 데이터베이스 상태"
db_status=$(psql -h $DB_HOST -U $DB_USER -d $DB_NAME -c "SELECT 1" 2>&1)
if [ $? -eq 0 ]; then
    echo "✅ PostgreSQL - 정상"

    # 연결 수 확인
    connections=$(psql -h $DB_HOST -U $DB_USER -d $DB_NAME -t -c \
        "SELECT count(*) FROM pg_stat_activity WHERE state = 'active'")
    echo "   활성 연결: $connections / 100"

    # 느린 쿼리 확인
    slow_queries=$(psql -h $DB_HOST -U $DB_USER -d $DB_NAME -t -c \
        "SELECT count(*) FROM pg_stat_activity WHERE state = 'active' AND query_start < now() - interval '5 seconds'")
    if [ $slow_queries -gt 0 ]; then
        echo "⚠️  느린 쿼리 감지: $slow_queries 개"
    fi
else
    echo "❌ PostgreSQL - 연결 실패"
    send_alert "데이터베이스 연결 실패"
fi

# 3. API 할당량 확인
echo -e "\n[3/8] YouTube API 할당량"
api_usage=$(curl -s "https://api.yourservice.com/admin/youtube-quota" \
    -H "Authorization: Bearer $ADMIN_TOKEN")
quota_used=$(echo $api_usage | jq -r '.used')
quota_limit=$(echo $api_usage | jq -r '.limit')
quota_percent=$((quota_used * 100 / quota_limit))

echo "   사용량: $quota_used / $quota_limit ($quota_percent%)"
if [ $quota_percent -gt 80 ]; then
    echo "⚠️  API 할당량 경고: 80% 초과"
    send_alert "YouTube API 할당량 80% 초과"
fi

# 4. 캐시 상태
echo -e "\n[4/8] 캐시 시스템"
cache_stats=$(curl -s "https://api.yourservice.com/admin/cache-stats" \
    -H "Authorization: Bearer $ADMIN_TOKEN")
hit_rate=$(echo $cache_stats | jq -r '.hit_rate')
memory_usage=$(echo $cache_stats | jq -r '.memory_usage_percent')

echo "   캐시 적중률: $hit_rate%"
echo "   메모리 사용률: $memory_usage%"

# 5. 에러 로그 확인
echo -e "\n[5/8] 최근 24시간 에러"
error_count=$(grep -c "ERROR" /var/log/app/error.log | tail -24h)
if [ $error_count -gt 10 ]; then
    echo "⚠️  에러 증가: $error_count 건"
    # 주요 에러 타입 분석
    echo "   주요 에러:"
    grep "ERROR" /var/log/app/error.log | tail -24h | \
        awk '{print $4}' | sort | uniq -c | sort -rn | head -5
fi

# 6. 디스크 사용량
echo -e "\n[6/8] 디스크 사용량"
df -h | grep -E "^/dev/" | while read line; do
    usage=$(echo $line | awk '{print $5}' | sed 's/%//')
    mount=$(echo $line | awk '{print $6}')
    if [ $usage -gt 80 ]; then
        echo "⚠️  $mount: $usage% 사용중"
    else
        echo "✅ $mount: $usage% 사용중"
    fi
done

# 7. SSL 인증서 만료일
echo -e "\n[7/8] SSL 인증서 상태"
domains=("api.yourservice.com" "app.yourservice.com")
for domain in "${domains[@]}"; do
    expiry_date=$(echo | openssl s_client -servername $domain -connect $domain:443 2>/dev/null | \
        openssl x509 -noout -enddate | cut -d= -f2)
    days_left=$(( ($(date -d "$expiry_date" +%s) - $(date +%s)) / 86400 ))

    if [ $days_left -lt 30 ]; then
        echo "⚠️  $domain: $days_left 일 남음"
    else
        echo "✅ $domain: $days_left 일 남음"
    fi
done

# 8. 백업 상태
echo -e "\n[8/8] 백업 상태"
latest_backup=$(find /backup -name "*.sql.gz" -mtime -1 | wc -l)
if [ $latest_backup -gt 0 ]; then
    echo "✅ 일일 백업 완료"
else
    echo "❌ 백업 실패"
    send_alert "일일 백업 실패"
fi

echo -e "\n=== 점검 완료: $(date) ==="

```

### 운영 대시보드 체크리스트

```jsx
// 운영팀 일일 체크리스트
const dailyOperationsChecklist = {
  morning: {
    time: "09:00 - 10:00",
    tasks: [
      {
        category: "시스템 모니터링",
        items: [
          {
            task: "Grafana 대시보드 확인",
            checks: [
              "CPU 사용률 < 70%",
              "메모리 사용률 < 80%",
              "응답 시간 < 500ms",
              "에러율 < 1%"
            ],
            action: "이상 시 스케일링 또는 재시작"
          },
          {
            task: "Railway 배포 상태",
            checks: [
              "모든 서비스 Running 상태",
              "최근 배포 성공 여부",
              "환경 변수 동기화"
            ],
            action: "실패 시 롤백 검토"
          },
          {
            task: "Supabase 상태",
            checks: [
              "데이터베이스 연결 풀",
              "실시간 구독 상태",
              "스토리지 사용량"
            ],
            action: "임계값 초과 시 정리 작업"
          }
        ]
      },
      {
        category: "비즈니스 메트릭",
        items: [
          {
            task: "사용자 활동 확인",
            metrics: [
              "신규 가입자 수",
              "DAU (일일 활성 사용자)",
              "평균 세션 시간",
              "이탈률"
            ],
            baseline: {
              newUsers: 50,
              dau: 1000,
              sessionTime: "10분",
              bounceRate: "30%"
            }
          },
          {
            task: "수익 지표",
            metrics: [
              "유료 전환율",
              "일일 수익",
              "결제 실패율",
              "해지율"
            ],
            alerts: "전일 대비 20% 이상 변동 시"
          }
        ]
      },
      {
        category: "콘텐츠 상태",
        items: [
          {
            task: "캐시 콘텐츠 확인",
            checks: [
              "캐시된 키워드 수",
              "평균 영상 수/키워드",
              "캐시 만료 예정",
              "콘텐츠 품질 점수"
            ]
          },
          {
            task: "트렌드 업데이트",
            checks: [
              "트렌드 키워드 갱신 시간",
              "새로운 트렌드 감지",
              "지역별 트렌드 차이"
            ]
          }
        ]
      }
    ]
  },

  afternoon: {
    time: "14:00 - 15:00",
    tasks: [
      {
        category: "API 상태",
        items: [
          {
            task: "YouTube API 사용량",
            checks: [
              "현재 사용량 / 일일 한도",
              "시간당 사용 추세",
              "예상 소진 시간",
              "비상 계획 준비 상태"
            ],
            thresholds: {
              warning: "70%",
              critical: "85%",
              action: "캐시 전용 모드 전환"
            }
          },
          {
            task: "Claude API 상태",
            checks: [
              "응답 시간",
              "에러율",
              "토큰 사용량",
              "비용 추적"
            ]
          }
        ]
      },
      {
        category: "사용자 지원",
        items: [
          {
            task: "지원 티켓 검토",
            priorities: [
              "P0: 서비스 접속 불가",
              "P1: 핵심 기능 오류",
              "P2: 부가 기능 문제",
              "P3: 개선 요청"
            ],
            sla: {
              P0: "1시간 내 응답",
              P1: "4시간 내 응답",
              P2: "24시간 내 응답",
              P3: "48시간 내 응답"
            }
          },
          {
            task: "사용자 피드백 분석",
            sources: [
              "인앱 피드백",
              "이메일 문의",
              "소셜 미디어 멘션",
              "앱스토어 리뷰"
            ]
          }
        ]
      }
    ]
  },

  evening: {
    time: "17:00 - 18:00",
    tasks: [
      {
        category: "일일 마감",
        items: [
          {
            task: "백업 확인",
            types: [
              "데이터베이스 전체 백업",
              "증분 백업",
              "로그 파일 아카이빙",
              "설정 파일 백업"
            ],
            verification: "복구 테스트 (주 1회)"
          },
          {
            task: "보안 점검",
            checks: [
              "비정상 접근 시도",
              "Failed login attempts",
              "API 남용 패턴",
              "DDoS 징후"
            ]
          },
          {
            task: "내일 준비",
            items: [
              "예정된 유지보수 공지",
              "캐시 갱신 스케줄",
              "팀 인수인계 사항",
              "긴급 연락망 확인"
            ]
          }
        ]
      }
    ]
  }
};

```

### 주간/월간 정기 작업

### 주간 운영 태스크

```jsx
const weeklyOperationsTasks = {
  monday: {
    focus: "성능 분석 및 최적화",
    tasks: [
      {
        name: "주간 성능 리포트",
        steps: [
          "지난 주 성능 메트릭 수집",
          "병목 지점 분석",
          "최적화 대상 선정",
          "개선 계획 수립"
        ],
        deliverables: ["성능 리포트", "최적화 백로그"]
      },
      {
        name: "데이터베이스 유지보수",
        steps: [
          "인덱스 재구성",
          "통계 업데이트",
          "불필요한 데이터 정리",
          "파티션 관리"
        ],
        maintenanceWindow: "02:00 - 04:00 KST"
      }
    ]
  },

  wednesday: {
    focus: "보안 및 컴플라이언스",
    tasks: [
      {
        name: "보안 감사",
        checklist: [
          "접근 권한 검토",
          "보안 패치 적용 여부",
          "로그 분석",
          "취약점 스캔"
        ],
        tools: ["OWASP ZAP", "Nessus", "Custom Scripts"]
      },
      {
        name: "컴플라이언스 체크",
        items: [
          "개인정보 처리 방침 준수",
          "YouTube ToS 준수",
          "결제 정보 보안 (PCI DSS)",
          "데이터 보관 정책"
        ]
      }
    ]
  },

  friday: {
    focus: "배포 및 업데이트",
    tasks: [
      {
        name: "정기 배포",
        process: [
          {
            time: "14:00",
            step: "배포 준비",
            checks: [
              "모든 테스트 통과",
              "배포 노트 작성",
              "롤백 계획 준비",
              "모니터링 대시보드 준비"
            ]
          },
          {
            time: "15:00",
            step: "단계적 배포",
            stages: [
              "10% 트래픽 (30분)",
              "50% 트래픽 (30분)",
              "100% 트래픽"
            ]
          },
          {
            time: "17:00",
            step: "배포 검증",
            metrics: [
              "에러율 확인",
              "성능 지표 비교",
              "사용자 피드백 모니터링"
            ]
          }
        ]
      }
    ]
  }
};

```

## 14.2 장애 대응 프로세스

### 장애 등급 정의 및 대응 절차

### 장애 등급 분류

```jsx
const incidentSeverityLevels = {
  P0_Critical: {
    definition: "전체 서비스 중단 또는 데이터 손실 위험",
    examples: [
      "모든 사용자 로그인 불가",
      "데이터베이스 접근 불가",
      "결제 시스템 오류",
      "보안 침해"
    ],
    response: {
      timeToAcknowledge: "5분",
      timeToResolve: "1시간",
      escalation: "즉시",
      team: ["On-call Engineer", "Tech Lead", "CTO"]
    },
    communication: {
      internal: "즉시 Slack #incident 채널",
      external: "15분 내 상태 페이지 업데이트",
      customers: "이메일/인앱 공지 (영향받는 사용자)"
    }
  },

  P1_Major: {
    definition: "핵심 기능 장애 또는 다수 사용자 영향",
    examples: [
      "검색 기능 오류",
      "영상 재생 불가",
      "AI 추천 중단",
      "느린 응답 시간 (>5초)"
    ],
    response: {
      timeToAcknowledge: "15분",
      timeToResolve: "4시간",
      escalation: "30분 후",
      team: ["On-call Engineer", "Service Owner"]
    },
    communication: {
      internal: "Slack 알림",
      external: "30분 내 상태 페이지",
      customers: "심각도에 따라 결정"
    }
  },

  P2_Minor: {
    definition: "부가 기능 오류 또는 일부 사용자 영향",
    examples: [
      "프로필 이미지 업로드 오류",
      "통계 지연",
      "특정 브라우저 이슈",
      "UI 깨짐"
    ],
    response: {
      timeToAcknowledge: "1시간",
      timeToResolve: "24시간",
      escalation: "필요시",
      team: ["Assigned Developer"]
    },
    communication: {
      internal: "이슈 트래커",
      external: "필요시",
      customers: "FAQ 업데이트"
    }
  },

  P3_Low: {
    definition: "사용성 개선 또는 미미한 버그",
    examples: [
      "오타",
      "색상 불일치",
      "번역 오류",
      "성능 개선 요청"
    ],
    response: {
      timeToAcknowledge: "2일",
      timeToResolve: "다음 릴리즈",
      escalation: "없음",
      team: ["Product Team"]
    }
  }
};

```

### 장애 대응 플레이북

```jsx
// P0 Critical 장애 대응 스크립트
const criticalIncidentPlaybook = {
  // 1단계: 감지 및 초기 대응 (0-5분)
  detection: {
    triggers: [
      "모니터링 알림",
      "사용자 신고",
      "자동 헬스체크 실패"
    ],

    immediateActions: [
      {
        action: "장애 확인",
        command: `curl -s https://api.yourservice.com/health | jq '.'`,
        checkPoints: [
          "API 응답 상태",
          "데이터베이스 연결",
          "외부 서비스 상태"
        ]
      },
      {
        action: "영향 범위 파악",
        queries: [
          "SELECT count(*) FROM active_sessions WHERE last_activity > NOW() - INTERVAL '5 minutes';",
          "SELECT service_name, error_count FROM service_errors WHERE timestamp > NOW() - INTERVAL '10 minutes';"
        ]
      },
      {
        action: "인시던트 생성",
        template: {
          title: "[P0] ${service} 장애 - ${timestamp}",
          description: "영향: ${affected_users}명, 증상: ${symptoms}",
          commander: "${on_call_engineer}",
          channel: "#incident-${id}"
        }
      }
    ]
  },

  // 2단계: 진단 및 완화 (5-15분)
  diagnosis: {
    checkList: [
      {
        area: "인프라",
        commands: [
          "kubectl get pods -n production",
          "kubectl top nodes",
          "kubectl describe pod ${pod_name}"
        ],
        metrics: ["CPU", "Memory", "Disk I/O", "Network"]
      },
      {
        area: "애플리케이션",
        commands: [
          "tail -f /var/log/app/error.log | grep ERROR",
          "pm2 status",
          "npm run health-check"
        ],
        focus: ["에러 스택트레이스", "메모리 누수", "무한 루프"]
      },
      {
        area: "데이터베이스",
        commands: [
          "pg_stat_activity 확인",
          "슬로우 쿼리 확인",
          "락 상태 확인",
          "레플리케이션 지연"
        ]
      }
    ],

    mitigationOptions: [
      {
        scenario: "트래픽 과부하",
        actions: [
          "오토스케일링 트리거",
          "Rate limiting 강화",
          "캐시 TTL 증가",
          "비필수 기능 비활성화"
        ]
      },
      {
        scenario: "메모리 누수",
        actions: [
          "애플리케이션 재시작",
          "롤링 재시작",
          "이전 버전 롤백",
          "메모리 덤프 수집"
        ]
      },
      {
        scenario: "외부 서비스 장애",
        actions: [
          "Circuit breaker 활성화",
          "폴백 메커니즘 사용",
          "캐시 데이터 활용",
          "사용자 공지"
        ]
      }
    ]
  },

  // 3단계: 복구 및 검증 (15-60분)
  recovery: {
    steps: [
      {
        name: "근본 원인 수정",
        actions: [
          "핫픽스 개발",
          "코드 리뷰 (최소 2명)",
          "긴급 테스트",
          "배포 준비"
        ]
      },
      {
        name: "단계적 복구",
        process: [
          "카나리 배포 (5%)",
          "모니터링 (10분)",
          "점진적 확대 (25% → 50% → 100%)",
          "각 단계별 검증"
        ]
      },
      {
        name: "서비스 정상화 확인",
        verifications: [
          "모든 헬스체크 통과",
          "에러율 < 0.1%",
          "응답시간 정상",
          "사용자 피드백 확인"
        ]
      }
    ]
  },

  // 4단계: 사후 분석 (장애 종료 후 48시간 내)
  postmortem: {
    template: {
      sections: [
        {
          title: "장애 요약",
          content: [
            "발생 시간",
            "복구 시간",
            "영향받은 사용자 수",
            "비즈니스 임팩트"
          ]
        },
        {
          title: "타임라인",
          format: "HH:MM - 이벤트 설명"
        },
        {
          title: "근본 원인",
          analysis: [
            "직접 원인",
            "기여 요인",
            "왜 감지가 늦었는가?",
            "왜 복구가 오래 걸렸는가?"
          ]
        },
        {
          title: "잘한 점",
          items: ["빠른 대응", "효과적인 커뮤니케이션", "...]
        },
        {
          title: "개선 사항",
          actionItems: [
            {
              issue: "모니터링 부족",
              action: "XX 메트릭 추가",
              owner: "DevOps팀",
              due: "2주 내"
            }
          ]
        }
      ]
    }
  }
};

```

### 자동화된 장애 대응

```jsx
// 자동 복구 시스템
class AutoRecoverySystem {
  constructor() {
    this.healthChecks = new Map();
    this.recoveryActions = new Map();
    this.incidentHistory = [];
  }

  // 헬스체크 등록
  registerHealthCheck(service, config) {
    this.healthChecks.set(service, {
      url: config.url,
      interval: config.interval || 30000,
      timeout: config.timeout || 5000,
      retries: config.retries || 3,
      thresholds: config.thresholds
    });
  }

  // 자동 복구 액션 등록
  registerRecoveryAction(condition, action) {
    this.recoveryActions.set(condition, action);
  }

  // 모니터링 시작
  async startMonitoring() {
    for (const [service, config] of this.healthChecks) {
      setInterval(async () => {
        const health = await this.checkHealth(service, config);

        if (!health.healthy) {
          await this.handleUnhealthy(service, health);
        }
      }, config.interval);
    }
  }

  // 건강 상태 확인
  async checkHealth(service, config) {
    let lastError;

    for (let i = 0; i < config.retries; i++) {
      try {
        const response = await fetch(config.url, {
          timeout: config.timeout
        });

        const data = await response.json();

        // 임계값 검사
        for (const [metric, threshold] of Object.entries(config.thresholds)) {
          if (data[metric] > threshold.critical) {
            return {
              healthy: false,
              reason: `${metric} exceeded critical threshold`,
              value: data[metric],
              threshold: threshold.critical
            };
          }
        }

        return { healthy: true, data };

      } catch (error) {
        lastError = error;
        await this.sleep(1000 * (i + 1)); // 백오프
      }
    }

    return {
      healthy: false,
      reason: 'Health check failed',
      error: lastError
    };
  }

  // 비정상 상태 처리
  async handleUnhealthy(service, health) {
    console.error(`Service unhealthy: ${service}`, health);

    // 자동 복구 시도
    const recovered = await this.attemptAutoRecovery(service, health);

    if (!recovered) {
      // 수동 개입 필요
      await this.escalateIncident(service, health);
    }
  }

  // 자동 복구 시도
  async attemptAutoRecovery(service, health) {
    const recoveryKey = `${service}:${health.reason}`;
    const action = this.recoveryActions.get(recoveryKey);

    if (!action) {
      console.log(`No auto-recovery action for ${recoveryKey}`);
      return false;
    }

    try {
      console.log(`Attempting auto-recovery: ${action.name}`);
      await action.execute();

      // 복구 확인
      await this.sleep(10000);
      const newHealth = await this.checkHealth(service,
        this.healthChecks.get(service)
      );

      if (newHealth.healthy) {
        console.log(`Auto-recovery successful for ${service}`);
        await this.notifyRecovery(service, action);
        return true;
      }
    } catch (error) {
      console.error(`Auto-recovery failed: ${error}`);
    }

    return false;
  }

  // 사용 예시: 자동 복구 액션 설정
  setupAutoRecovery() {
    // API 서버 재시작
    this.registerRecoveryAction('api:Health check failed', {
      name: 'Restart API Server',
      execute: async () => {
        await exec('pm2 restart api-server');
      }
    });

    // 데이터베이스 연결 풀 리셋
    this.registerRecoveryAction('database:connection_pool_exhausted', {
      name: 'Reset Connection Pool',
      execute: async () => {
        await this.database.pool.clear();
        await this.database.pool.initialize();
      }
    });

    // 캐시 서버 플러시
    this.registerRecoveryAction('cache:memory_exceeded', {
      name: 'Flush Cache',
      execute: async () => {
        await this.cache.flushAll();
        await this.cache.warmUp(['trending', 'popular']);
      }
    });

    // 오토스케일링 트리거
    this.registerRecoveryAction('api:response_time_high', {
      name: 'Scale Out',
      execute: async () => {
        const currentInstances = await this.getInstanceCount();
        await this.scaleInstances(currentInstances + 2);
      }
    });
  }
}

```

## 14.3 사용자 지원 가이드

### 지원 티켓 처리 프로세스

### 티켓 분류 및 라우팅

```jsx
// 지원 티켓 관리 시스템
class SupportTicketSystem {
  constructor() {
    this.categories = {
      account: {
        keywords: ['로그인', '비밀번호', '계정', '가입'],
        team: 'Account Support',
        templates: new Map()
      },
      billing: {
        keywords: ['결제', '환불', '구독', '요금'],
        team: 'Billing Support',
        templates: new Map(),
        requiresAuth: true
      },
      technical: {
        keywords: ['오류', '버그', '작동', '느림'],
        team: 'Technical Support',
        templates: new Map()
      },
      feature: {
        keywords: ['제안', '기능', '개선', '추가'],
        team: 'Product Team',
        templates: new Map()
      }
    };

    this.initializeTemplates();
  }

  // 응답 템플릿 초기화
  initializeTemplates() {
    // 계정 관련 템플릿
    this.categories.account.templates.set('password_reset', {
      subject: '비밀번호 재설정 안내',
      body: `안녕하세요 {{user_name}}님,

비밀번호 재설정을 요청하셨습니다.

아래 링크를 클릭하여 새로운 비밀번호를 설정해주세요:
{{reset_link}}

이 링크는 24시간 동안 유효합니다.

본인이 요청하지 않으셨다면 이 이메일을 무시해주세요.

감사합니다.
YouTube Shorts 큐레이션 팀`
    });

    this.categories.account.templates.set('login_issue', {
      subject: '로그인 문제 해결 방법',
      body: `안녕하세요 {{user_name}}님,

로그인에 문제가 있으신 것 같습니다. 다음 단계를 시도해보세요:

1. **브라우저 캐시 삭제**
   - Chrome: 설정 > 개인정보 보호 및 보안 > 인터넷 사용 기록 삭제
   - Safari: 개발자 도구 > 캐시 비우기

2. **쿠키 확인**
   - 우리 사이트의 쿠키가 차단되어 있지 않은지 확인

3. **다른 브라우저 시도**
   - 문제가 지속되면 다른 브라우저로 시도

4. **비밀번호 재설정**
   - 여전히 로그인할 수 없다면 비밀번호를 재설정해보세요

추가 도움이 필요하시면 다음 정보와 함께 회신해주세요:
- 사용 중인 브라우저 및 버전
- 오류 메시지 스크린샷
- 문제 발생 시간

감사합니다.`
    });

    // 기술 지원 템플릿
    this.categories.technical.templates.set('video_playback', {
      subject: '영상 재생 문제 해결',
      body: `안녕하세요 {{user_name}}님,

영상 재생에 문제가 있다고 알려주셨습니다.

**즉시 시도해볼 수 있는 해결 방법:**

1. **인터넷 연결 확인**
   - WiFi 또는 모바일 데이터 연결 상태 확인
   - 다른 웹사이트는 정상적으로 로드되는지 확인

2. **브라우저 업데이트**
   - 최신 버전의 브라우저를 사용 중인지 확인

3. **확장 프로그램 비활성화**
   - 광고 차단기나 다른 확장 프로그램이 영향을 줄 수 있습니다

4. **시크릿/프라이빗 모드로 시도**

문제가 지속되면 다음 정보를 보내주세요:
- 문제가 발생하는 영상 링크
- 오류 메시지
- 디바이스 정보 (모델, OS 버전)

24시간 내에 다시 연락드리겠습니다.`
    });

    // 결제 관련 템플릿
    this.categories.billing.templates.set('refund_request', {
      subject: '환불 요청 접수 확인',
      body: `안녕하세요 {{user_name}}님,

환불 요청을 접수했습니다.

**요청 정보:**
- 주문 번호: {{order_id}}
- 결제 금액: {{amount}}
- 요청 사유: {{reason}}

**처리 절차:**
1. 요청 검토 (1-2 영업일)
2. 승인 시 환불 처리 (3-5 영업일)
3. 환불 완료 알림

환불은 원래 결제 수단으로 처리되며, 카드사에 따라
실제 반영까지 추가로 2-3일이 소요될 수 있습니다.

문의사항이 있으시면 이 이메일에 회신해주세요.

감사합니다.`
    });
  }

  // 티켓 자동 분류
  async categorizeTicket(ticket) {
    const content = `${ticket.subject} ${ticket.body}`.toLowerCase();
    let bestMatch = { category: 'general', score: 0 };

    for (const [category, config] of Object.entries(this.categories)) {
      const score = config.keywords.reduce((sum, keyword) => {
        return sum + (content.includes(keyword) ? 1 : 0);
      }, 0);

      if (score > bestMatch.score) {
        bestMatch = { category, score };
      }
    }

    // AI 기반 분류 (MCP 활용)
    if (bestMatch.score < 2) {
      const aiCategory = await this.classifyWithAI(ticket);
      if (aiCategory) {
        bestMatch.category = aiCategory;
      }
    }

    return bestMatch.category;
  }

  // 자동 응답 생성
  async generateResponse(ticket, category) {
    const templates = this.categories[category].templates;

    // 템플릿 매칭
    for (const [templateId, template] of templates) {
      if (this.matchesTemplate(ticket, templateId)) {
        return this.fillTemplate(template, ticket);
      }
    }

    // 템플릿이 없으면 AI 응답 생성
    return await this.generateAIResponse(ticket);
  }

  // 에스컬레이션 규칙
  shouldEscalate(ticket) {
    const rules = [
      {
        condition: ticket.priority === 'urgent',
        escalateTo: 'Team Lead',
        reason: 'Urgent priority'
      },
      {
        condition: ticket.responseTime > 24 * 60 * 60 * 1000,
        escalateTo: 'Manager',
        reason: 'SLA breach'
      },
      {
        condition: ticket.sentiment < -0.5,
        escalateTo: 'Senior Agent',
        reason: 'Very negative sentiment'
      },
      {
        condition: ticket.customerTier === 'premium' &&
                  ticket.responseTime > 4 * 60 * 60 * 1000,
        escalateTo: 'Premium Support Lead',
        reason: 'Premium customer waiting'
      }
    ];

    for (const rule of rules) {
      if (rule.condition) {
        return rule;
      }
    }

    return null;
  }
}

```

### 일반적인 문제 해결 가이드

### FAQ 및 트러블슈팅

```jsx
const troubleshootingGuide = {
  categories: [
    {
      title: "로그인/계정 문제",
      issues: [
        {
          problem: "로그인할 수 없습니다",
          solutions: [
            {
              step: 1,
              action: "이메일 주소 확인",
              details: "가입 시 사용한 정확한 이메일 주소인지 확인하세요."
            },
            {
              step: 2,
              action: "비밀번호 재설정",
              details: "로그인 페이지에서 '비밀번호를 잊으셨나요?' 클릭",
              link: "/auth/reset-password"
            },
            {
              step: 3,
              action: "브라우저 쿠키 삭제",
              details: "브라우저 설정에서 쿠키와 캐시를 삭제하고 다시 시도"
            }
          ],
          additionalInfo: "그래도 문제가 해결되지 않으면 support@yourservice.com으로 문의"
        },
        {
          problem: "이메일 인증을 받지 못했습니다",
          solutions: [
            {
              step: 1,
              action: "스팸 폴더 확인",
              details: "인증 이메일이 스팸 폴더에 있을 수 있습니다"
            },
            {
              step: 2,
              action: "이메일 재발송",
              details: "프로필 설정에서 '인증 이메일 재발송' 클릭"
            },
            {
              step: 3,
              action: "이메일 주소 확인",
              details: "등록된 이메일 주소가 정확한지 확인"
            }
          ]
        }
      ]
    },
    {
      title: "영상 재생 문제",
      issues: [
        {
          problem: "영상이 로드되지 않습니다",
          solutions: [
            {
              step: 1,
              action: "인터넷 연결 확인",
              details: "안정적인 인터넷 연결이 필요합니다 (최소 5Mbps)",
              diagnostic: "speedtest.net에서 속도 테스트"
            },
            {
              step: 2,
              action: "브라우저 호환성",
              details: "Chrome, Firefox, Safari, Edge 최신 버전 사용 권장",
              supportedVersions: {
                Chrome: "100+",
                Firefox: "100+",
                Safari: "15+",
                Edge: "100+"
              }
            },
            {
              step: 3,
              action: "하드웨어 가속 설정",
              details: "브라우저 설정에서 하드웨어 가속 활성화"
            }
          ]
        },
        {
          problem: "영상이 버퍼링됩니다",
          solutions: [
            {
              step: 1,
              action: "화질 낮추기",
              details: "플레이어 설정에서 화질을 720p 또는 480p로 변경"
            },
            {
              step: 2,
              action: "다른 앱 종료",
              details: "백그라운드에서 실행 중인 다른 앱 종료"
            },
            {
              step: 3,
              action: "CDN 서버 변경",
              details: "설정 > 고급 > CDN 지역 변경"
            }
          ]
        }
      ]
    },
    {
      title: "결제 및 구독",
      issues: [
        {
          problem: "결제가 실패했습니다",
          solutions: [
            {
              step: 1,
              action: "카드 정보 확인",
              details: "카드 번호, 만료일, CVV가 정확한지 확인"
            },
            {
              step: 2,
              action: "카드 한도 확인",
              details: "카드사에 해외 결제 차단 여부 확인"
            },
            {
              step: 3,
              action: "다른 결제 수단",
              details: "PayPal, Google Pay 등 다른 결제 방법 시도"
            }
          ],
          errorCodes: {
            "CARD_DECLINED": "카드가 거절되었습니다. 카드사에 문의하세요.",
            "INSUFFICIENT_FUNDS": "잔액이 부족합니다.",
            "INVALID_CVV": "CVV 코드가 올바르지 않습니다."
          }
        },
        {
          problem: "구독을 취소하고 싶습니다",
          solutions: [
            {
              step: 1,
              action: "프로필 설정 접속",
              details: "우측 상단 프로필 아이콘 > 설정"
            },
            {
              step: 2,
              action: "구독 관리",
              details: "결제 및 구독 > 구독 관리 클릭"
            },
            {
              step: 3,
              action: "구독 취소",
              details: "'구독 취소' 버튼 클릭 > 사유 선택"
            }
          ],
          important: "현재 구독 기간이 끝날 때까지 서비스 이용 가능"
        }
      ]
    }
  ],

  // 진단 도구
  diagnosticTools: {
    connectivityTest: {
      name: "연결 테스트",
      command: `
// 브라우저 콘솔에서 실행
(async () => {
  const tests = {
    api: 'https://api.yourservice.com/health',
    cdn: 'https://cdn.yourservice.com/test.txt',
    youtube: 'https://www.youtube.com/iframe_api'
  };

  for (const [service, url] of Object.entries(tests)) {
    try {
      const start = Date.now();
      const response = await fetch(url);
      const time = Date.now() - start;
      console.log(\`✅ \${service}: \${response.status} (\${time}ms)\`);
    } catch (error) {
      console.error(\`❌ \${service}: \${error.message}\`);
    }
  }
})();
      `
    },

    performanceCheck: {
      name: "성능 체크",
      command: `
// 페이지 로드 성능 확인
console.table({
  'DOM 로드': performance.timing.domContentLoadedEventEnd - performance.timing.navigationStart,
  '전체 로드': performance.timing.loadEventEnd - performance.timing.navigationStart,
  'First Paint': performance.getEntriesByType('paint')[0]?.startTime,
  'First Contentful Paint': performance.getEntriesByType('paint')[1]?.startTime
});
      `
    }
  }
};

```

### 사용자 커뮤니케이션 가이드

### 톤 앤 매너 가이드라인

```jsx
const communicationGuidelines = {
  principles: [
    {
      principle: "친근하고 전문적인",
      do: [
        "안녕하세요! 도움이 필요하신가요?",
        "문제를 해결해드릴게요.",
        "추가 질문이 있으시면 언제든지 문의해주세요."
      ],
      dont: [
        "뭐가 문제임?",
        "그건 우리 잘못이 아닙니다.",
        "메뉴얼을 읽어보세요."
      ]
    },
    {
      principle: "공감과 이해",
      do: [
        "불편을 드려 죄송합니다.",
        "답답하셨겠네요. 바로 확인해보겠습니다.",
        "좋은 제안 감사합니다!"
      ],
      dont: [
        "그런 일은 없을 텐데요.",
        "다른 사용자는 문제없이 사용하고 있습니다.",
        "사용법이 틀렸습니다."
      ]
    },
    {
      principle: "명확하고 구체적인",
      do: [
        "다음 3단계를 따라해주세요:",
        "이 문제는 보통 24시간 내에 해결됩니다.",
        "Chrome 브라우저 버전 100 이상에서 가장 잘 작동합니다."
      ],
      dont: [
        "곧 해결될 겁니다.",
        "여러 가지 방법을 시도해보세요.",
        "최신 브라우저를 사용하세요."
      ]
    }
  ],

  responseTemplates: {
    greeting: {
      firstContact: "안녕하세요! YouTube Shorts 큐레이션 서비스입니다. 어떤 도움이 필요하신가요?",
      returning: "다시 연락주셔서 감사합니다. 이전 문제가 해결되셨나요?",
      followUp: "안녕하세요, {{name}}님. 지난번 문의하신 {{issue}}에 대해 추가 도움이 필요하신가요?"
    },

    problemAcknowledgment: {
      technical: "기술적인 문제로 불편을 드려 죄송합니다. 바로 확인해보겠습니다.",
      billing: "결제 관련 문제는 신중히 처리하겠습니다. 자세한 정보를 확인하는 동안 잠시만 기다려주세요.",
      feature: "좋은 아이디어 감사합니다! 제품팀과 공유하여 검토하겠습니다."
    },

    resolution: {
      solved: "문제가 해결되어 기쁩니다! 다른 도움이 필요하시면 언제든지 문의해주세요.",
      partial: "임시 해결 방법을 제공해드렸습니다. 완전한 해결을 위해 계속 노력하겠습니다.",
      escalated: "이 문제는 전문팀에서 검토가 필요합니다. {{timeframe}} 내에 다시 연락드리겠습니다."
    },

    closing: {
      satisfied: "도움이 되었다니 기쁩니다! 좋은 하루 보내세요 😊",
      neutral: "추가 질문이 있으시면 언제든지 문의해주세요.",
      dissatisfied: "만족스러운 해결책을 제공하지 못해 죄송합니다. 개선할 수 있도록 노력하겠습니다."
    }
  },

  // 이모지 사용 가이드
  emojiUsage: {
    appropriate: ["😊", "👍", "✅", "💡", "🎉", "⚡"],
    contexts: {
      success: "✅ 해결되었습니다!",
      idea: "💡 팁: ~",
      celebration: "🎉 축하합니다!",
      fast: "⚡ 빠른 해결 방법"
    },
    avoid: ["😡", "😭", "🤬", "💩", "🙄"]
  }
};

```

## 14.4 성능 튜닝 가이드

### 데이터베이스 최적화

### 쿼리 성능 분석 및 개선

```sql
-- 느린 쿼리 로그 분석
-- 실행 시간이 1초 이상인 쿼리 찾기
SELECT
    query,
    calls,
    total_time,
    mean_time,
    max_time,
    stddev_time
FROM pg_stat_statements
WHERE mean_time > 1000  -- 1초 이상
ORDER BY mean_time DESC
LIMIT 20;

-- 인덱스 사용률 확인
SELECT
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch,
    pg_size_pretty(pg_relation_size(indexrelid)) as index_size
FROM pg_stat_user_indexes
ORDER BY idx_scan ASC;

-- 테이블 블로트 확인
WITH constants AS (
    SELECT current_setting('block_size')::numeric AS bs, 23 AS hdr, 8 AS ma
),
no_stats AS (
    SELECT table_schema, table_name,
        n_live_tup::numeric as est_rows,
        pg_table_size(relid)::numeric as table_size
    FROM information_schema.columns
        JOIN pg_stat_user_tables as psut
           ON table_schema = psut.schemaname
           AND table_name = psut.relname
        LEFT OUTER JOIN pg_stats
        ON table_schema = pg_stats.schemaname
            AND table_name = pg_stats.tablename
            AND column_name = attname
    WHERE attname IS NULL
        AND table_schema NOT IN ('pg_catalog', 'information_schema')
    GROUP BY table_schema, table_name, relid, n_live_tup
)
SELECT
    table_schema,
    table_name,
    pg_size_pretty(table_size) AS table_size,
    pg_size_pretty((table_size - (ceil(est_rows * 40))::bigint)) AS bloat_size,
    round((table_size - (ceil(est_rows * 40))::numeric) / table_size * 100, 1) AS bloat_ratio
FROM no_stats
WHERE table_size > 1024*1024*10  -- 10MB 이상 테이블만
ORDER BY bloat_ratio DESC;

```

### 자동 최적화 스크립트

```jsx
// 데이터베이스 성능 튜너
class DatabasePerformanceTuner {
  constructor(dbConnection) {
    this.db = dbConnection;
    this.recommendations = [];
  }

  async analyzePerfomance() {
    const report = {
      timestamp: new Date(),
      issues: [],
      recommendations: []
    };

    // 1. 느린 쿼리 분석
    const slowQueries = await this.findSlowQueries();
    if (slowQueries.length > 0) {
      report.issues.push({
        type: 'SLOW_QUERIES',
        severity: 'HIGH',
        details: slowQueries,
        recommendation: await this.generateQueryOptimizations(slowQueries)
      });
    }

    // 2. 인덱스 분석
    const indexIssues = await this.analyzeIndexes();
    if (indexIssues.missing.length > 0) {
      report.issues.push({
        type: 'MISSING_INDEXES',
        severity: 'MEDIUM',
        details: indexIssues.missing,
        recommendation: this.generateIndexCommands(indexIssues.missing)
      });
    }

    // 3. 테이블 통계 분석
    const staleStats = await this.checkTableStatistics();
    if (staleStats.length > 0) {
      report.issues.push({
        type: 'STALE_STATISTICS',
        severity: 'LOW',
        details: staleStats,
        recommendation: 'ANALYZE ' + staleStats.join(', ')
      });
    }

    // 4. 연결 풀 분석
    const connectionPool = await this.analyzeConnectionPool();
    if (connectionPool.utilization > 80) {
      report.issues.push({
        type: 'CONNECTION_POOL_HIGH',
        severity: 'HIGH',
        details: connectionPool,
        recommendation: 'Increase max_connections or optimize connection usage'
      });
    }

    return report;
  }

  // 느린 쿼리 찾기
  async findSlowQueries() {
    const query = `
      SELECT
        query,
        calls,
        total_time,
        mean_time,
        max_time
      FROM pg_stat_statements
      WHERE mean_time > 1000
      ORDER BY mean_time DESC
      LIMIT 10
    `;

    const results = await this.db.query(query);
    return results.rows.map(row => ({
      query: this.normalizeQuery(row.query),
      calls: row.calls,
      avgTime: row.mean_time,
      totalTime: row.total_time,
      optimization: this.suggestQueryOptimization(row.query)
    }));
  }

  // 쿼리 최적화 제안
  suggestQueryOptimization(query) {
    const suggestions = [];

    // SELECT * 검사
    if (query.includes('SELECT *')) {
      suggestions.push('특정 컬럼만 선택하도록 변경');
    }

    // JOIN 없는 여러 테이블 검사
    if (query.match(/FROM\s+\w+\s*,\s*\w+/i)) {
      suggestions.push('명시적 JOIN 사용 권장');
    }

    // LIKE '%...' 검사
    if (query.match(/LIKE\s+'%[^']+'/i)) {
      suggestions.push('전체 텍스트 검색 또는 trigram 인덱스 고려');
    }

    // ORDER BY RANDOM() 검사
    if (query.includes('RANDOM()')) {
      suggestions.push('TABLESAMPLE 또는 사전 계산된 랜덤 값 사용');
    }

    return suggestions;
  }
}

```

### 애플리케이션 성능 최적화

### Node.js 성능 튜닝

```jsx
// 성능 모니터링 및 최적화
class ApplicationPerformanceMonitor {
  constructor() {
    this.metrics = {
      requests: new Map(),
      memory: [],
      cpu: [],
      eventLoop: []
    };

    this.startMonitoring();
  }

  startMonitoring() {
    // 메모리 사용량 추적
    setInterval(() => {
      const memUsage = process.memoryUsage();
      this.metrics.memory.push({
        timestamp: Date.now(),
        heapUsed: memUsage.heapUsed,
        heapTotal: memUsage.heapTotal,
        external: memUsage.external,
        rss: memUsage.rss
      });

      // 메모리 누수 감지
      if (this.detectMemoryLeak()) {
        this.handleMemoryLeak();
      }
    }, 60000); // 1분마다

    // 이벤트 루프 지연 측정
    let lastCheck = process.hrtime();
    setInterval(() => {
      const delay = process.hrtime(lastCheck);
      const delayMs = delay[0] * 1000 + delay[1] / 1000000 - 100;

      this.metrics.eventLoop.push({
        timestamp: Date.now(),
        delay: delayMs
      });

      if (delayMs > 50) {
        console.warn(`Event loop delay: ${delayMs}ms`);
      }

      lastCheck = process.hrtime();
    }, 100);
  }

  // 메모리 누수 감지
  detectMemoryLeak() {
    if (this.metrics.memory.length < 10) return false;

    const recent = this.metrics.memory.slice(-10);
    const trend = this.calculateTrend(recent.map(m => m.heapUsed));

    // 지속적인 증가 추세
    return trend.slope > 1000000 && trend.r2 > 0.8; // 1MB/분 이상 증가
  }

  // 메모리 누수 대응
  handleMemoryLeak() {
    console.error('Memory leak detected!');

    // 힙 스냅샷 생성
    if (process.env.NODE_ENV === 'production') {
      const v8 = require('v8');
      const fs = require('fs');

      const snapshotFile = `/tmp/heap-${Date.now()}.heapsnapshot`;
      const snapshotStream = v8.getHeapSnapshot();
      const fileStream = fs.createWriteStream(snapshotFile);

      snapshotStream.pipe(fileStream);
      console.log(`Heap snapshot saved to ${snapshotFile}`);
    }

    // 가비지 컬렉션 강제 실행
    if (global.gc) {
      global.gc();
      console.log('Manual GC triggered');
    }

    // 알림 발송
    this.sendAlert({
      level: 'CRITICAL',
      message: 'Memory leak detected',
      metrics: this.getMemoryMetrics()
    });
  }

  // API 응답 시간 최적화
  optimizeRoutes() {
    return {
      // 응답 압축
      compression: {
        enable: true,
        options: {
          level: 6,
          threshold: 1024,
          filter: (req, res) => {
            if (req.headers['x-no-compression']) {
              return false;
            }
            return compression.filter(req, res);
          }
        }
      },

      // 캐싱 헤더
      caching: {
        static: {
          maxAge: 86400 * 30, // 30일
          immutable: true
        },
        api: {
          '/api/trending': 300, // 5분
          '/api/search': 3600, // 1시간
          '/api/user/*': 0 // 캐시 안함
        }
      },

      // Rate limiting
      rateLimiting: {
        windowMs: 15 * 60 * 1000, // 15분
        max: {
          anonymous: 100,
          authenticated: 1000,
          premium: 5000
        },
        handler: (req, res) => {
          res.status(429).json({
            error: 'Too many requests',
            retryAfter: req.rateLimit.resetTime
          });
        }
      }
    };
  }
}

```

### 프론트엔드 성능 최적화

### 로딩 성능 개선

```jsx
// 프론트엔드 성능 최적화 유틸리티
class FrontendPerformanceOptimizer {
  constructor() {
    this.metrics = {
      resources: new Map(),
      interactions: []
    };
  }

  // 이미지 최적화
  setupImageOptimization() {
    // Lazy loading
    if ('IntersectionObserver' in window) {
      const imageObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = entry.target;
            img.src = img.dataset.src;
            img.classList.remove('lazy');
            observer.unobserve(img);
          }
        });
      });

      document.querySelectorAll('img.lazy').forEach(img => {
        imageObserver.observe(img);
      });
    }

    // WebP 지원 체크
    const supportsWebP = () => {
      const canvas = document.createElement('canvas');
      canvas.width = 1;
      canvas.height = 1;
      return canvas.toDataURL('image/webp').indexOf('image/webp') === 0;
    };

    if (supportsWebP()) {
      document.documentElement.classList.add('webp');
    }
  }

  // 리소스 우선순위 설정
  setPriorities() {
    // Critical CSS 인라인
    const criticalCSS = `
      /* 초기 렌더링에 필요한 최소 CSS */
      body { margin: 0; font-family: system-ui; }
      .header { height: 60px; background: #fff; }
      .main { padding: 20px; }
      .loading { display: flex; justify-content: center; }
    `;

    const style = document.createElement('style');
    style.textContent = criticalCSS;
    document.head.insertBefore(style, document.head.firstChild);

    // 중요 리소스 프리로드
    const preloads = [
      { href: '/api/trending', as: 'fetch' },
      { href: '/fonts/main.woff2', as: 'font', type: 'font/woff2' },
      { href: '/js/vendor.js', as: 'script' }
    ];

    preloads.forEach(({ href, as, type }) => {
      const link = document.createElement('link');
      link.rel = 'preload';
      link.href = href;
      link.as = as;
      if (type) link.type = type;
      document.head.appendChild(link);
    });
  }

  // 코드 스플리팅 및 동적 임포트
  async loadComponent(componentName) {
    // 컴포넌트별 청크 로딩
    const components = {
      'video-player': () => import('./components/VideoPlayer.js'),
      'chat-interface': () => import('./components/ChatInterface.js'),
      'trending-section': () => import('./components/TrendingSection.js'),
      'user-profile': () => import('./components/UserProfile.js')
    };

    if (components[componentName]) {
      try {
        const module = await components[componentName]();
        return module.default;
      } catch (error) {
        console.error(`Failed to load component: ${componentName}`, error);
        // 폴백 컴포넌트 반환
        return this.getFallbackComponent(componentName);
      }
    }
  }

  // 런타임 성능 모니터링
  measurePerformance() {
    // Core Web Vitals 측정
    if ('PerformanceObserver' in window) {
      // LCP (Largest Contentful Paint)
      new PerformanceObserver((entryList) => {
        const entries = entryList.getEntries();
        const lastEntry = entries[entries.length - 1];
        console.log('LCP:', lastEntry.startTime);
        this.sendMetric('lcp', lastEntry.startTime);
      }).observe({ entryTypes: ['largest-contentful-paint'] });

      // FID (First Input Delay)
      new PerformanceObserver((entryList) => {
        const firstInput = entryList.getEntries()[0];
        const fid = firstInput.processingStart - firstInput.startTime;
        console.log('FID:', fid);
        this.sendMetric('fid', fid);
      }).observe({ entryTypes: ['first-input'] });

      // CLS (Cumulative Layout Shift)
      let clsValue = 0;
      new PerformanceObserver((entryList) => {
        for (const entry of entryList.getEntries()) {
          if (!entry.hadRecentInput) {
            clsValue += entry.value;
          }
        }
        console.log('CLS:', clsValue);
        this.sendMetric('cls', clsValue);
      }).observe({ entryTypes: ['layout-shift'] });
    }
  }

  // 메모리 사용 최적화
  optimizeMemoryUsage() {
    // 사용하지 않는 DOM 노드 정리
    const cleanup = () => {
      // 이벤트 리스너 정리
      const oldNodes = document.querySelectorAll('[data-cleanup]');
      oldNodes.forEach(node => {
        node.remove();
      });

      // 캐시된 데이터 정리
      if (this.cache.size > 100) {
        const entries = Array.from(this.cache.entries());
        entries.sort((a, b) => a[1].lastAccessed - b[1].lastAccessed);

        // 오래된 항목 50개 제거
        for (let i = 0; i < 50; i++) {
          this.cache.delete(entries[i][0]);
        }
      }
    };

    // 페이지 전환 시 정리
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        cleanup();
      }
    });
  }
}

```

### 캐싱 전략 최적화

### 다층 캐싱 구현

```jsx
// 고급 캐싱 시스템
class AdvancedCachingSystem {
  constructor() {
    this.layers = {
      memory: new Map(),
      indexedDB: null,
      cdn: {
        url: process.env.CDN_URL,
        purgeKey: process.env.CDN_PURGE_KEY
      }
    };

    this.strategies = {
      'cache-first': this.cacheFirst.bind(this),
      'network-first': this.networkFirst.bind(this),
      'stale-while-revalidate': this.staleWhileRevalidate.bind(this)
    };

    this.initializeIndexedDB();
  }

  // IndexedDB 초기화
  async initializeIndexedDB() {
    const request = indexedDB.open('AppCache', 1);

    request.onsuccess = (event) => {
      this.layers.indexedDB = event.target.result;
    };

    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains('cache')) {
        db.createObjectStore('cache', { keyPath: 'key' });
      }
    };
  }

  // 캐시 전략: Cache First
  async cacheFirst(key, fetcher, options = {}) {
    // 1. 메모리 캐시 확인
    const memoryCache = this.layers.memory.get(key);
    if (memoryCache && !this.isExpired(memoryCache)) {
      return memoryCache.data;
    }

    // 2. IndexedDB 확인
    const dbCache = await this.getFromIndexedDB(key);
    if (dbCache && !this.isExpired(dbCache)) {
      // 메모리 캐시에도 저장
      this.layers.memory.set(key, dbCache);
      return dbCache.data;
    }

    // 3. 네트워크 요청
    try {
      const data = await fetcher();
      await this.setCache(key, data, options.ttl);
      return data;
    } catch (error) {
      // 4. 만료된 캐시라도 반환
      if (memoryCache) return memoryCache.data;
      if (dbCache) return dbCache.data;
      throw error;
    }
  }

  // 캐시 무효화 전략
  async invalidateCache(pattern) {
    const invalidated = {
      memory: 0,
      indexedDB: 0,
      cdn: 0
    };

    // 메모리 캐시 무효화
    for (const [key, value] of this.layers.memory) {
      if (this.matchesPattern(key, pattern)) {
        this.layers.memory.delete(key);
        invalidated.memory++;
      }
    }

    // IndexedDB 무효화
    if (this.layers.indexedDB) {
      const tx = this.layers.indexedDB.transaction(['cache'], 'readwrite');
      const store = tx.objectStore('cache');
      const request = store.openCursor();

      request.onsuccess = (event) => {
        const cursor = event.target.result;
        if (cursor) {
          if (this.matchesPattern(cursor.value.key, pattern)) {
            cursor.delete();
            invalidated.indexedDB++;
          }
          cursor.continue();
        }
      };
    }

    // CDN 캐시 퍼지
    if (pattern.cdn) {
      await this.purgeCDN(pattern.cdn);
      invalidated.cdn++;
    }

    return invalidated;
  }

  // 캐시 워밍
  async warmCache(keys) {
    const results = {
      success: 0,
      failed: 0,
      errors: []
    };

    const batchSize = 5;
    for (let i = 0; i < keys.length; i += batchSize) {
      const batch = keys.slice(i, i + batchSize);

      await Promise.all(batch.map(async ({ key, fetcher, ttl }) => {
        try {
          const data = await fetcher();
          await this.setCache(key, data, ttl);
          results.success++;
        } catch (error) {
          results.failed++;
          results.errors.push({ key, error: error.message });
        }
      }));

      // Rate limiting
      await new Promise(resolve => setTimeout(resolve, 100));
    }

    return results;
  }

  // 캐시 통계
  getStatistics() {
    const stats = {
      memory: {
        size: this.layers.memory.size,
        bytes: this.calculateMemorySize(),
        hitRate: this.calculateHitRate('memory')
      },
      indexedDB: {
        size: 0, // IndexedDB 크기 계산
        hitRate: this.calculateHitRate('indexedDB')
      },
      performance: {
        avgMemoryAccess: this.metrics.memoryAccess.average(),
        avgDBAccess: this.metrics.dbAccess.average(),
        avgNetworkFetch: this.metrics.networkFetch.average()
      }
    };

    return stats;
  }
}

```